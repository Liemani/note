webserv.txt

# pc
config parsing
    location은 어떻게 저장되고 사용되는지
method 별 requirement
header field 정리
    예쁘지 않은 것 다시 정리
chunked에 대한 더 깊은 이해
    0x0d0a가 아닌 값으로 끝난 data를 recv()로 읽을 가능성도 있는가?
    여러 recv()로 나뉘어 들어오는 것만은 아닌 것 같다.
    chunked면 request body limit 체크는 어떻게 해야 하는가?
cgi, status code
(갑자기 드는 생각)POST를 위해 authority가 필요할까?
- 이 선택을 결정하는 가장 큰 요인은 "평가지에 평가 항목이 있느냐" 일 것 같다.
- 두번째는 테스트 툴
잘 모르는 부분은 왜 그렇게 생각했는지 더 물어보도록 하자.
HTTP 완전 정복 읽기
이슈 생성해도 되는지 직접 보여주며 mosong님과 상의하기
- 내가 이걸 왜 적었더라?
상대경로인 URI가 root 밖을 가리키는 경우 처리
1차적으로는 HTTP 이외의 상황을 처리하지 않도록 한다.
workflow()에 code review 추가하는 것 건의하기
CI/CD 알아보기
개발 단계를 이렇게 구분해봐도 좋겠다.
1. 정상적인 인자를 처리하도록 구현
2. 각종 error response를 구현
VIP를 정하면 좋을 것 같다.
- 중간 제출을 이 VIP를 구현한 결과물을 제출하면 좋겠다.(big webserv가 되지 않도록)
jihokim님이 layer마다 상속을 하도록 했는데, 그 이유를 들어보고, 필요에 따라 circle과 elipsis를 설명한 c++ primer plus에 글을 알려주자.
RFC - chunked
server_name directive를 생략하는 경우 처리
Because you won’t call the CGI directly, use the full path as PATH_INFO.
- CGI를 직접 호출하지 않는다는건 동적으로 입력받은 경로를 사용한다는 것일 것 같은데 PATH_INFO는 왜 필요한걸까?
- CGI의 환경 변수 중에 PATH_INFO가 있다. 이걸 알아보자.
Just remember that, for chunked request, your server needs to unchunked it and the CGI will expect EOF as end of the body.
Make the route able to accept uploaded files and configure where they should be saved.
event? worker의 갯수?
- 굳이 worker_connections를 구현하여 configuration file을 읽어서 연결 가능한 client 수 제한을 설정할 필요는 없을 것 같다.
root가 server block 안에 있을 때 같은 server block 안에 있는 location block 안의 root가 server의 root에 영향을 받을까?
error response를 위한 html 파일을 각각 준비하는 것의 장점 -> 동적으로 파일을 생성하기 위해 필요한 cpu 자원을 아낄 수 있다.
테스트는 어떻게 진행할 것인가?
https로 접속하면 client는 server에 http와 어떻게 다른 request message를 보낼까?
어떤 이상한 header 입력은 잘 처리하고 어떤 이상한 header 입력에는 400 error를 내며 접속을 중단한다.
nginx
- webserv tutorial 페이지 3개 읽어보기.
    - 그 전에 mosong님이 보여주셨던 최소한의 필요한 부분을 뽑아낸 configuration file을 다시 보고 싶다.
configuration file
- syntax 정의하기
nginx cgi
- nginx config 파일의 location 부분을 알아보기
서브젝트 이외
- workflow
    - 생성 -> 초안 -> 리뷰 -> 완료
- 미래 계획하기
- 멘탈 관리하기
    - 나 + 팀원
- 에너지 관리하기
    - 팀원들의 에너지를 관리하기 위해 내가 너무 high-tension이면 안된다!
- mind setting
    - 말을 끊고 알고 있음을 어필하는 것은 효율적일 수 있으나 악감정을 만들 수 있다.
        - 이 경우 악감정 및 안좋은 분위기 및 안좋은 문화를 만드는 것은 얻은 효율에 비해 잃는게 더 크다고 생각한다.
        - 따라서 상대의 말을 끊는 행위는 내가 도움이 필요한 경우가 아니라면 하지 말자.
    - 열심히 참여하기
        - 필요한 학습 사항이 있으면 적극적으로 조사하겠다고 하기
        - 잘 모르는 부분과 필요하다고 생각되는 부분은 바로바로 말하기
        - 상대방의 의견 수렴해서 ambiguos하지 않게 상황 매듭짓기
            - 그럼 이거랑 이거 더 조사해봐서 뭐가 더 좋을지 알아볼까요?
        - 혼자 다 짊어질 필요는 없다
        - 왜 이런 것이 필요한가?
            - 팀원들의 맨탈 케어는 프로젝트 진행에 필수 요소!
            - 의욕이 저하되는 팀원이 있다면 그만큼 프로젝트는 더뎌질 것이다!
    - 감사합니다를 잘 말하기
    - 잘 진행된 작업에 대해서는 긍정적인 표현하기
    - 할 일이 많아 보이는 사업 파트너를 보았을 때
        - 제가 도울 수 있는 일 있으면 알려주세요!
    - 고생하셨습니다.
server가 client에게 write에 실패할 경우
- client와의 connection이 유지되고 있다고 판단하는 동안에는 계속 write를 시도하겠지?
플로우 차트 만들어서 설계 해보신 분 있는지
- 우리가 설계한다는 것은 어떻게 진행될 것인지
- 피그마!
nginx 테스트
- mandatory에 명시된 내용이 실제 nginx에서는 어떻게 적용되어 있는지 조사하기
짬짬이 RFC 읽기
- 7230, 7231
원하는 browser와 호환되도록 하기 위해서는 해당 browser가 HTTP message의 header를 어떤 식으로 구성하는지도 알아두는 것이 좋겠다.
HTTP message의 길이 제한이 존재할까?
what header should implement
what status code should implement
configuration file parsing
is POST differ between file and text?
client로부터 전달받은 path가 configuration에서 정의한 root의 밖을 접근하는 경우 처리
MacOS는 다른 Unix OS들과는 다른 방식으로 write()를 구현했기 때문에 non-blocking으로 write()를 하기 위해서 fcntl()을 호출하여 fd를 non-blocking fd로 만들어야 한다고 한다.
    구체적으로는 어떤 차이가 있는 것일까?
    상상1: 다른 Unix OS들은 fd를 non-blocking fd로 만드는 방법 이외의 다른 방식으로 non-blocking으로 작동하는 write()를 호출할 수 있는 것이 아닐까?

# finish
평가를 미리 한 번 받아서 평가지를 볼 필요가 있다.
nginx directive syntax 사이트 올리기
send에 대해 읽었던 영문 페이지 올리기
우선 recv()의 크기 제한에 대한 부분은 무시하도록 하자.
    필요하면 추가하자.
git pull request 처리하기
- webserve, playground
git에 올려둔 슈도 코드를 회의록에 첨부하자!
playground의 branch rule 확인하기
mosong님이 말한 root의 작동을 명확히 조사하기
The first server for a host:port will be the default for this host:port (that means it will answer to all the requests that don’t belong to an other server).
- 구체적인 의미를 생각해보기
Limit client body size.
Define a list of accepted HTTP methods for the route.
Set a default file to answer if the request is a directory.
- index일까?
- 스터디 학습 일지 작성하기
    - 내 발표 자료 + 코드
- 스터디 피드백
    - 팀원들이 모두 열심히 참여해줘서 좋았다.
- 자리 정하기
- 음료 사기
    - 오고 가는 정!
config parsing
    default error page's'
_가 host name에는 들어올 수 없는 걸까?
send가 tcp까지 처리하는지 읽어보기
send를 할 때 '\n'가 '\r\n'으로 바뀔까?
- '\n'이 있는 문자열을 전송하고 총 전송 byte를 비교해서 '\r'이 추가되는지 확인해보자.
65kB이상의 데이터를 전송하면 send가 모든 값을 다 출력하지 못할 수 있다고 한다. 테스트해보자.
- body가 response message에 제대로 안들어갔나? 다시 확인하고 테스트해보자.
- 261676보다 큰 값을 보내면 여기서 짤리는 것 같다.
github organization 알아보기
내 HTTP demonstration 프로그램의 example을 server가 아닌 Worker? 로 수정하기
- 아니, Worker는 thread의 갯수니까 class name이 Worker인 것은 사실 적절하지 않다. 좋은 이름을 생각해보자.
class나 structure의 초기 값을 직접 설정하고 컴파일해보기
class나 structure를 생성할 때 = {};로 값을 초기화할 수 있나 컴파일해보기
worker보다 좋은 이름 생각해보기
server와 virtual server 등 이름 정하고 confluence에 올리기?
session의 다른 이름 생각해봤는지 물어보고 virtual server를 주장하기
오늘까지 설계를 마치는 부분이므로 이제 각 class의 동작을 인식한 부분이다. 다음 회의 때까지 각 class의 이름을 원하는 만큼 생각해오고 투표 등으로 결정하기
mandatory에서 요구하는 cgi가 fast cgi인지 알아보기
우리가 CGI 프로그램도 작성해야 하는가?
- (아마 그런 것 같다.)
- 그냥 있는거 가져와서 사용해도 될 것 같다.
CGI 프로그램이 값을 반환하지 않는 경우도 생각해야 할까?
public, private convention 조사하기
- google convention에서 이 순서를 따로 지정하는 부분이 존재하는지?
에러코드 에러넘버 관리하는 부분 만들기
typedef 사용하기
생각
- CGI를 지원하더라도 fully static website라고 할 수 있는가?
- fully static website를 어떻게 말로 정의할 수 있을까?
- fully static website는 화면에 보여주는 html문서에 대해서 static이면 될 것 같다.
- 추가로 file upload등 CGI와 작업을 수행하고 그 결과를 반환받는 것은 static 여부와 상관 없다고 할 수 있을 것 같다.
blocking, non-blocking 더 이해하기(mosong)님이 보내주신 link 토대로
telnet 써보기
허용 함수 전부 알아보기
- 허용 함수 부족한 부분 알아보기
- poll(), kqueue()
    - 찾아놓은 multiplex 관련 글
kevent가 내부적으로 어떻게 동작하는지 더 구체적으로 이해하고 있으면 좋을 것 같다.
- 저번에 본 jinbekim님의 자료를 다시 한 번 보자.
mosong 님이 notion에 올린 사이트 읽어보기
mosong 님이 슬랙에 올린 사이트 읽어보기
그럼 socket을 close하면 select가 readable이지 않다고 판단할까?
- 그건 확실하지 않지만, readfds에서 해당 socket을 remove해야 하는 것은 확실하다.
poll() 사용해보기
select() 더 파기 (왜 client socket이 여전히 redable인가?)
non-blocking fd의 의미를 생각해보기
socket에 fcntl()을 사용하여 non-blocking socket을 만들면 이전 socket과 달라지는 부분?(non-blocking 작동은 당연하고)
syn, async
muliti plexing
- async + non-blocking
select() 쓰지 말고 poll() 쓰라고 서브젝트에 있는 모양이다.
- select() -> poll() -> epoll()로 발전
mosong님이 올린 질문 글 첫 답글의 웹 페이지
blocking non-blocking
허용 함수 전부 알아보기
- 허용 함수 부족한 부분 알아보기

# postpone
request target은 relative일 수도 있나..?
- absolute path일 수도 있다.
- scheme 등가지 포함한 uri일 수도 있다.
    - RFC7230 등을 참고할 것
send
- 없는 fd에 send()를 하려고 하면 errno에 EPIPE가 저장되며 socket의 type이 SOCK_STREAM인 경우 SIGPIPE가 발생한다.
- 이것을 처리해줘야 할까?
- 나중에 SIGPIPE로 인한 프로그램 termination을 피해야하면 그 때 signal을 제어하는 부분을 추가하도록 하자.

# data
????-??-??
https://kb.iu.edu/d/afqs
> ARCHIVED: If my computer has an underscore ( _ ) in its name, why am I having trouble accessing network services?
host name is case-insensitive

2022-05-03
https://stackoverflow.com/questions/14700906/socket-programming-send-return-value
> Socket programming send() return value
저번 회의에서 send()의 반환값이 일반적으로는 인자로 전달한 buffer의 size 또는 -1이 반환되지만 fd가 non-blocking일 때는 또 다를지 모르겠다고 했었는데 이 사이트에 딱 알맞는 답변이 있습니다.
fd가 non-blocking일 때는 [0, buffer)를 반환할 수 있다고 합니다.
하지만 직접 테스트를 해 본 결과 이것은 틀린 얘기라는 것을 알게 되었습니다.

/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/event.h
> struct kevent filter type value
```
#define EVFILT_READ             (-1)
#define EVFILT_WRITE            (-2)
#define EVFILT_AIO              (-3)
#define EVFILT_VNODE            (-4)
#define EVFILT_PROC             (-5)
#define EVFILT_SIGNAL           (-6)
#define EVFILT_TIMER            (-7)
#define EVFILT_MACHPORT         (-8)
#define EVFILT_FS               (-9)
#define EVFILT_USER             (-10)
#define EVFILT_VM               (-12)
#define EVFILT_EXCEPT           (-15)
```
bit flag 모델이 아니기 때문에 '|'로 동시에 여러개의 filter를 set하여 설정하는 기법을 사용할 수 없다.

## https://m.blog.naver.com/migurazi/70048236691
> Socket send()함수의 Return값
send()는 remote로 데이터를 보내기까지를 담당하는 것이 아니라 단순히 socket의 write buffer에 

2022-05-02
kqueue의 udata를 사용하면 좋을 것 같다.
- map의 key를 탐색하는 시간을 절약할 수 있다.
```
// 타입 정의
class VirtualServer {
    // configuration file
    host;
    port number;
    name;
    default error page path;
    client body size limit;
    list of accepted HTTP methods for route;
    HTTP redirection;
    nginx location;
    directory listing toggle;
    default file to answer if the request is a directory;
    CGI based on certain file extension;

    // run time
    socket;
};

Class ClientClerk {
    server;

    request buffer;

    should write;
    response buffer;
};

typedef VSMap map<int, VirtualServer>;


// 글로벌 수준 영역
VSMap vs_map;

// virtual server sock 추가
while (config 파일의 모든 virtual server마다) {
    int server_sock = socket(PF_INET, SOCK_STREAM, 0);

    VirtualServer new_vs = VirtualServer(server_sock/*, config_data*/);

    vs_map[server_sock] = new_vs;
}

while {
    event_count = kevent(kqueue_fd, NULL, 0, event_array, DEFAULT_EVENT_ARRAY_SIZE, &timeout);

    for (int i = 0; i < event_count; ++i) {
        const struct kevent& event = event_array[i];
        VirtualServer& vs = event.udata;

        if (event.filter == EVFILT_READ) {
            if (static_cast<int>(event.ident) == server_sock)
                acceptServer(server_sock, kqueue_fd);
            else
                if (readClient(event.ident, msg_buf, BUF_SIZE) != 0)
                    runRequest(msg_buf, response_message_array[event.ident], response_message_should_write[event.ident]);
                else
                    deleteEventClient(event.ident, kqueue_fd);
        }
        else if (event.filter == EVFILT_WRITE)
            if (response_message_should_write[event.ident]) {
                const std::string response_message = response_message_array[event.ident];
                send(event.ident, response_message.c_str(), response_message.length(), 0);
                response_message_should_write[event.ident] = false;
            }
    }
}

```

```
VirtualServer vs;

EV_SET(&event, sock, filter, flags, 0, 0, vs);
kevent(kqueue_fd, &event, 1, NULL, 0, NULL);

while {
    event_count = kevent(kqueue_fd, NULL, 0, event_array, DEFAULT_EVENT_ARRAY_SIZE, &timeout);

    for (int i = 0; i < event_count; ++i) {
        const struct kevent& event = event_array[i];
        VirtualServer& vs = event.udata;

        if (event.filter == EVFILT_READ) {
            if (static_cast<int>(event.ident) == server_sock)
                acceptServer(server_sock, kqueue_fd);
            else
                if (readClient(event.ident, msg_buf, BUF_SIZE) != 0)
                    runRequest(msg_buf, response_message_array[event.ident], response_message_should_write[event.ident]);
                else
                    deleteEventClient(event.ident, kqueue_fd);
        }
        else if (event.filter == EVFILT_WRITE)
            if (response_message_should_write[event.ident]) {
                const std::string response_message = response_message_array[event.ident];
                send(event.ident, response_message.c_str(), response_message.length(), 0);
                response_message_should_write[event.ident] = false;
            }
    }
}

```
