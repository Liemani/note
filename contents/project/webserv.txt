webserv.txt

# pc
nginx는 1 분 동안 완성된 요청을 받지 못하는 경우 연결을 끊는다.
REUSEADDR은 동일 주소에 동일 포트를 대비한 것인가? REUSEPORT를 사용하면 두 서버가 열린다. 그리고 첫 서버가 처리하다가 닫히면 두 번째 서버가 해당 포트의 요청을 전달받는다.
non-blocking fd에 file read를 수행할 때 끝을 알기 위해서는 read가 BUF_SIZE보다 작은 값을 가지고 있는지를 확인하는 것이 아니라 read()의 결과가 EOF인지를 확인해야 할 것 같다.
directory listing이 index of path를 출력하도록 수정하기
response.appendMessage()를 inline으로 만들어보자
EventHandler::~EventHandler()가 close(kqueue)를 하면 문제가 있을 것 같다.(이미 close한 fd를 close하려고 시도)
root를 route로 설정했을 때 특정 파일이 404 응답읇 반환하는 문제
연결을 끊어야 하는 경우
processRequest가 RC_FAIL인 경우 프로그램 종료를 요구하는 치명적인 에러일 것 같다.
config file의 설정에 문제가 있을 경우 segfault가 발생할 수 있는 문제
stream에 대한 지식이 부족하다...
memcpy()의 assembly code?
	이걸 내가 재현하려면?
보다보니 Connection에 있는 Response는 Sender가 되야 할 것 같고, Response는 VirtualServer에 있어야 할 것 같다.
	일단은 지금 상태로 유지하고, VirtualServer에 추가로 Response를 만들기 보다는, VirtualServer에 Response의 member variable들을 전부 정의해서 사용해보자.
Request
	EOF 신호를 전송했을 때 400 전송
	불필요한 body가 추가로 들어왔을 때, 이전 요청 처리 후 400 전송
각 라이브러리 함수의 에러 처리
heap에 동적 할당에 실패하는 경우 처리하기
client tcp의 timeout을 설정했을 때 구체적으로 어떤 동작을 하며, 그에 따라 어떻게 우리의 socket의 destructor를 호출하도록 만들지 알아보자.
코드 작성
    kevent timeout 등록하기
매 connection에서 하나의 request의 service를 제공하고 연결을 끊어야 하는가?(jihokim)
HTTP 완전 정복 읽기
CI/CD 알아보기
개발 단계를 이렇게 구분해봐도 좋겠다.
1. 정상적인 인자를 처리하도록 구현(프로토타입)
2. 각종 error response를 구현
MVP를 정하면 좋을 것 같다.
- 중간 제출을 이 VIP를 구현한 결과물을 제출하면 좋겠다.(big webserv가 되지 않도록)
Because you won’t call the CGI directly, use the full path as PATH_INFO.
- CGI를 직접 호출하지 않는다는건 동적으로 입력받은 경로를 사용한다는 것일 것 같은데 PATH_INFO는 왜 필요한걸까?
- CGI의 환경 변수 중에 PATH_INFO가 있다. 이걸 알아보자.
테스트는 어떻게 진행할 것인가?
non-MVP
	어떤 이상한 header 입력은 잘 처리하고 어떤 이상한 header 입력에는 400 error를 내며 접속을 중단한다.
서브젝트 이외
- workflow
    - 생성 -> 초안 -> 리뷰 -> 완료
- 미래 계획하기
- 멘탈 관리하기
    - 나 + 팀원
- 에너지 관리하기
    - 팀원들의 에너지를 관리하기 위해 내가 너무 high-tension이면 안된다!
- mind setting
    - 말을 끊고 알고 있음을 어필하는 것은 효율적일 수 있으나 악감정을 만들 수 있다.
        - 이 경우 악감정 및 안좋은 분위기 및 안좋은 문화를 만드는 것은 얻은 효율에 비해 잃는게 더 크다고 생각한다.
        - 따라서 상대의 말을 끊는 행위는 내가 도움이 필요한 경우가 아니라면 하지 말자.
    - 열심히 참여하기
        - 필요한 학습 사항이 있으면 적극적으로 조사하겠다고 하기
        - 잘 모르는 부분과 필요하다고 생각되는 부분은 바로바로 말하기
        - 상대방의 의견 수렴해서 ambiguos하지 않게 상황 매듭짓기
            - 그럼 이거랑 이거 더 조사해봐서 뭐가 더 좋을지 알아볼까요?
        - 혼자 다 짊어질 필요는 없다
        - 왜 이런 것이 필요한가?
            - 팀원들의 맨탈 케어는 프로젝트 진행에 필수 요소!
            - 의욕이 저하되는 팀원이 있다면 그만큼 프로젝트는 더뎌질 것이다!
    - 감사합니다를 잘 말하기
    - 잘 진행된 작업에 대해서는 긍정적인 표현하기
    - 할 일이 많아 보이는 사업 파트너를 보았을 때
        - 제가 도울 수 있는 일 있으면 알려주세요!
    - 고생하셨습니다.
MacOS는 다른 Unix OS들과는 다른 방식으로 write()를 구현했기 때문에 non-blocking으로 write()를 하기 위해서 fcntl()을 호출하여 fd를 non-blocking fd로 만들어야 한다고 한다.
    구체적으로는 어떤 차이가 있는 것일까?
    상상1: 다른 Unix OS들은 fd를 non-blocking fd로 만드는 방법 이외의 다른 방식으로 non-blocking으로 작동하는 write()를 호출할 수 있는 것이 아닐까?

# finish
processRequest가 fail인 경우 어떻게 처리해야 할까?
redirection을 할 때 해당 resourceURI를 같이 가져가야 하지 않을까?
	뭐 아니면 아닌대로 구현하면 되지 POST나 DELETE 등이 제대로 동작하지 않겠지만
server가 client에게 write에 실패할 경우
- client와의 connection이 유지되고 있다고 판단하는 동안에는 계속 write를 시도하겠지?
https://sunyzero.tistory.com/269
	> graceful shutdown 읽어보기
header field 정리
    예쁘지 않은 것 다시 정리
nginx 테스트
- mandatory에 명시된 내용이 실제 nginx에서는 어떻게 적용되어 있는지 조사하기
짬짬이 RFC 읽기
- 7230, 7231
원하는 browser와 호환되도록 하기 위해서는 해당 browser가 HTTP message의 header를 어떤 식으로 구성하는지도 알아두는 것이 좋겠다.
HTTP message의 길이 제한이 존재할까?
what header should implement
what status code should implement
configuration file parsing
is POST differ between file and text?
client로부터 전달받은 path가 configuration에서 정의한 root의 밖을 접근하는 경우 처리
플로우 차트 만들어서 설계 해보신 분 있는지
- 우리가 설계한다는 것은 어떻게 진행될 것인지
- 피그마!
nginx
- webserv tutorial 페이지 3개 읽어보기.
    - 그 전에 mosong님이 보여주셨던 최소한의 필요한 부분을 뽑아낸 configuration file을 다시 보고 싶다.
configuration file
- syntax 정의하기
nginx cgi
- nginx config 파일의 location 부분을 알아보기
https로 접속하면 client는 server에 http와 어떻게 다른 request message를 보낼까?
Just remember that, for chunked request, your server needs to unchunked it and the CGI will expect EOF as end of the body.
Make the route able to accept uploaded files and configure where they should be saved.
event? worker의 갯수?
- 굳이 worker_connections를 구현하여 configuration file을 읽어서 연결 가능한 client 수 제한을 설정할 필요는 없을 것 같다.
root가 server block 안에 있을 때 같은 server block 안에 있는 location block 안의 root가 server의 root에 영향을 받을까?
error response를 위한 html 파일을 각각 준비하는 것의 장점 -> 동적으로 파일을 생성하기 위해 필요한 cpu 자원을 아낄 수 있다.
jihokim님이 layer마다 상속을 하도록 했는데, 그 이유를 들어보고, 필요에 따라 circle과 elipsis를 설명한 c++ primer plus에 글을 알려주자.
RFC - chunked
server_name directive를 생략하는 경우 처리
상대경로인 URI가 root 밖을 가리키는 경우 처리
1차적으로는 HTTP 이외의 상황을 처리하지 않도록 한다.
workflow()에 code review 추가하는 것 건의하기
cgi, status code
(갑자기 드는 생각)POST를 위해 authority가 필요할까?
- 이 선택을 결정하는 가장 큰 요인은 "평가지에 평가 항목이 있느냐" 일 것 같다.
- 두번째는 테스트 툴
잘 모르는 부분은 왜 그렇게 생각했는지 더 물어보도록 하자.
chunked에 대한 더 깊은 이해
    0x0d0a가 아닌 값으로 끝난 data를 recv()로 읽을 가능성도 있는가?
    여러 recv()로 나뉘어 들어오는 것만은 아닌 것 같다.
    chunked면 request body limit 체크는 어떻게 해야 하는가?
    다 사용한 fd close하기
    serverVector와 socketMap이 소멸자에서 할당 해제를 하도록 하기
잘못된 URL을 어떻게 처리하나?
    root를 벗어나는 URL은?
ServerManager::run()의 잘못된 방식 수정하기
    close()를 하도록 하여 한 번만 실행되도록 수정하기
ServerManager::read()에서 ServerManager::getTargetServer()가 잘못 행동하는 것을 바로잡기
VirtualServer의 멤버 변수를 사용해서 GET 구현하기
일단은 정해진 버퍼 양을 보내도록 하고, 이후에 실제 커널의 버퍼 크기 변화를 관찰하면서 얼마 크기의 buf를 만들어서 파일을 읽어야 할지 생각해보자.
response message는 crnl을 지켜주어야 한다.
request에서 getHeaderField
target server를 반환하는 메서드
config로 server initialize하기
process get pr 날리기
Request에서 헤더 필드 벨류를 반환할 때 양 옆에 불필요한 스페이스 제거 후 getTargetVirtualServer에 있는 코드 수정하기
_mConnection이 fd index에 해당 connection을 저장하는가?
Request
    chunked를 읽을 수 있도록 기능 추가
	헤더 필드 네임을 소문자 등으로 바꿔서 저장하여 case-insensitive하게 인식하도록 만들자
	Request frame이 끝난 후 들어온 값은 유지시키기
	request method가 unknown일 때 동작은 평가지를 따르도록
	clientMaxBodySize 적용하기
Location::_allowedHTTPMethod에 옳바른 값 넣기
Location::isRequestMethodAllowed() 로직 수정
index.html을 실행할 때 representationURI의 MIME type을 Content-Type에 넣어주는 문제
autoindex off 인데 directory를 GET하는 경우 403 forbidden
header field는 로워케이스
delete의 body는 mdn을 참고하여 작성하자.
chunked를 파싱할 때 길이 유효성 검사를 하지 않는다.
client_body_size는 chunked 위에서 구현되어야 한다.
chunked body의 chunk를 chunk size씩 읽도록 수정하기
크롬은 Host에 포트 번호도 넣는다.
    Host를 사용할 때 포트 번호가 있다면 제거해주도록 하자.
post에서 원하는 location을 발견하지 못한 경우 405에 두 번째 인자로 location이 NULL이 들어가는 경우 405()에서 segfault가 발생할 것이다.
	이 경우 405도 이상하긴 하다. 404로 바꿔야 하나?
    400 응답을 반환하자.
host가 없는 경우 segfault 없애기
잘못된 POST 파이리 끝 endl 제거
모든 fd를 가지는 것에 대해 kevent를 거쳐야할까?
	https://42born2code.slack.com/archives/CU6MU5TB7/p1645572737334529
	엄밀하게는 yes 일 것 같다.
	일단은 fd가 바로 노출되는 경우가 아니면 kevent 없이 사용하고, 나중에 문제가 될 것 같으면, 혹은 여유가 있을 때 바꾸자
ftserver 인가 inline 함수들의 주석이 없었다.
Connection::setResponse() 없애기? 어디서 사용하는지 찾아보기
새로운 함수들 주석 추가하기
Location method를 필요에 따라 inline으로 빼기
method 정리하기
평가지에는 recv()와 send()가 실패하면 연결이 끊어져야 한다고 기술되어 있는 것 같다.
    recv()에서 실패하면 끊어져야 하겠지만 send()에서 실패해도 끊어져야 하는 것일까?
    아하, 0이 아니라 -1이 반환되는 경우라면 연결을 끊어야 할 것 같기는 하다.
상태 코드 계속 조사하기
평가지 읽어보고 어떻게 구현해 나갈지 생각해보기
inet_pton() 사용 가능할지 더 생각해보기
dev branch rebase하기
mosong 님이 슬랙에 올려주신 글 읽어보기
nginx에 body가 있는 GET 요청을 보내면?
	400이 발생한다.
Response 만들기
ServerManager::read() 기능 조정하기
Response class 작성
응답 상태 코드 정리 끝내기
mosong이 제시한 평가지의 애매한 해석을 가진 요구사항
회의
    chunked 추가 내용
        [RFC7230.4.1.3.]
코드 작성
    convention 지키도록 수정
        주석 추가
        name convention
        tab to space
    setUpServer() 지우기
        initializeServers()와 겹침
풀 리퀘스트에서 받은 피드백을 이슈로 생성하기
Server::process()의 첫 번째 인자의 label 수정하기
이슈 생성해도 되는지 직접 보여주며 mosong님과 상의하기
confluence 내용 수정하기
    body, chunked
config parsing
    location은 어떻게 저장되고 사용되는지
ip address로 virtual server를 구분하여 request를 보내는 것이 가능한가?
평가를 미리 한 번 받아서 평가지를 볼 필요가 있다.
nginx directive syntax 사이트 올리기
send에 대해 읽었던 영문 페이지 올리기
우선 recv()의 크기 제한에 대한 부분은 무시하도록 하자.
    필요하면 추가하자.
git pull request 처리하기
- webserve, playground
git에 올려둔 슈도 코드를 회의록에 첨부하자!
playground의 branch rule 확인하기
mosong님이 말한 root의 작동을 명확히 조사하기
The first server for a host:port will be the default for this host:port (that means it will answer to all the requests that don’t belong to an other server).
- 구체적인 의미를 생각해보기
Limit client body size.
Define a list of accepted HTTP methods for the route.
Set a default file to answer if the request is a directory.
- index일까?
- 스터디 학습 일지 작성하기
    - 내 발표 자료 + 코드
- 스터디 피드백
    - 팀원들이 모두 열심히 참여해줘서 좋았다.
- 자리 정하기
- 음료 사기
    - 오고 가는 정!
config parsing
    default error page's'
_가 host name에는 들어올 수 없는 걸까?
send가 tcp까지 처리하는지 읽어보기
send를 할 때 '\n'가 '\r\n'으로 바뀔까?
- '\n'이 있는 문자열을 전송하고 총 전송 byte를 비교해서 '\r'이 추가되는지 확인해보자.
65kB이상의 데이터를 전송하면 send가 모든 값을 다 출력하지 못할 수 있다고 한다. 테스트해보자.
- body가 response message에 제대로 안들어갔나? 다시 확인하고 테스트해보자.
- 261676보다 큰 값을 보내면 여기서 짤리는 것 같다.
github organization 알아보기
내 HTTP demonstration 프로그램의 example을 server가 아닌 Worker? 로 수정하기
- 아니, Worker는 thread의 갯수니까 class name이 Worker인 것은 사실 적절하지 않다. 좋은 이름을 생각해보자.
class나 structure의 초기 값을 직접 설정하고 컴파일해보기
class나 structure를 생성할 때 = {};로 값을 초기화할 수 있나 컴파일해보기
worker보다 좋은 이름 생각해보기
server와 virtual server 등 이름 정하고 confluence에 올리기?
session의 다른 이름 생각해봤는지 물어보고 virtual server를 주장하기
오늘까지 설계를 마치는 부분이므로 이제 각 class의 동작을 인식한 부분이다. 다음 회의 때까지 각 class의 이름을 원하는 만큼 생각해오고 투표 등으로 결정하기
mandatory에서 요구하는 cgi가 fast cgi인지 알아보기
우리가 CGI 프로그램도 작성해야 하는가?
- (아마 그런 것 같다.)
- 그냥 있는거 가져와서 사용해도 될 것 같다.
CGI 프로그램이 값을 반환하지 않는 경우도 생각해야 할까?
public, private convention 조사하기
- google convention에서 이 순서를 따로 지정하는 부분이 존재하는지?
에러코드 에러넘버 관리하는 부분 만들기
typedef 사용하기
생각
- CGI를 지원하더라도 fully static website라고 할 수 있는가?
- fully static website를 어떻게 말로 정의할 수 있을까?
- fully static website는 화면에 보여주는 html문서에 대해서 static이면 될 것 같다.
- 추가로 file upload등 CGI와 작업을 수행하고 그 결과를 반환받는 것은 static 여부와 상관 없다고 할 수 있을 것 같다.
blocking, non-blocking 더 이해하기(mosong)님이 보내주신 link 토대로
telnet 써보기
허용 함수 전부 알아보기
- 허용 함수 부족한 부분 알아보기
- poll(), kqueue()
    - 찾아놓은 multiplex 관련 글
kevent가 내부적으로 어떻게 동작하는지 더 구체적으로 이해하고 있으면 좋을 것 같다.
- 저번에 본 jinbekim님의 자료를 다시 한 번 보자.
mosong 님이 notion에 올린 사이트 읽어보기
mosong 님이 슬랙에 올린 사이트 읽어보기
그럼 socket을 close하면 select가 readable이지 않다고 판단할까?
- 그건 확실하지 않지만, readfds에서 해당 socket을 remove해야 하는 것은 확실하다.
poll() 사용해보기
select() 더 파기 (왜 client socket이 여전히 redable인가?)
non-blocking fd의 의미를 생각해보기
socket에 fcntl()을 사용하여 non-blocking socket을 만들면 이전 socket과 달라지는 부분?(non-blocking 작동은 당연하고)
syn, async
muliti plexing
- async + non-blocking
select() 쓰지 말고 poll() 쓰라고 서브젝트에 있는 모양이다.
- select() -> poll() -> epoll()로 발전
mosong님이 올린 질문 글 첫 답글의 웹 페이지
blocking non-blocking
허용 함수 전부 알아보기
- 허용 함수 부족한 부분 알아보기

# postpone
의문
    recv()와 send() 뒤에서 errorno를 확인하지 말라는 구체적인 이유는 무엇일까?
        getsockopt()로 error code를 확인해도 그럼 안되는 것일까?
request target은 relative일 수도 있나..?
- absolute path일 수도 있다.
- scheme 등가지 포함한 uri일 수도 있다.
    - RFC7230 등을 참고할 것
send
- 없는 fd에 send()를 하려고 하면 errno에 EPIPE가 저장되며 socket의 type이 SOCK_STREAM인 경우 SIGPIPE가 발생한다.
- 이것을 처리해줘야 할까?
- 나중에 SIGPIPE로 인한 프로그램 termination을 피해야하면 그 때 signal을 제어하는 부분을 추가하도록 하자.

# data
2022-06-01
# git PR 양식
```
## Description

request line 파싱 에러 등으로 인해 타겟 가상 서버가 존재하지 않는 요청을 처리하기 위한 용도의 더미 가상 서버를 ftServer._vVirtualServers에 추가했습니다.

## Test

make re && ./webserve custom.conf 자체 설정 파일 테스트를 통과했습니다.
GET 요청 메서드 테스트를 통과했습니다.

리뷰 해주시고 문제 없으면 approve 해주시면 감사하겠습니다. 🙂
```
```
## Description

- `RCRECV_PARSING_SUCCESS`을 `RCRECV_PARSING_FINISH`로 변경하였습니다.
- 파싱 상황에 따라 `request._message`와 `request._headerSection`의 값을 적절히 초기화 하도록 수정했습니다.
- request 에 내부적으로 추가적인 상태 값을 기록하는 `_status` 변수를 추가했습니다.
	- 추가된 Request::Status 타입을 가지며, 파싱의 성공, 실패(400) 및 411 응답을 반환해야 하는 상태인지를 저장합니다.
		- 400 과 411 은 메서드에 따른 요청 처리가 실행되기 전에 응답을 반환하고 요청 처리를 마칩니다.
- Content-Length 헤더 필드의 값만큼 body를 읽도록 수정하였습니다.
- 405 응답이 두 번째 인자로 NULL을 받을 때 nginx 처럼 `Allow` 헤더 필드를 출력하지 않도록 수정하였습니다.
- 요청 헤더 필드의 이름을 lower case 로 저장

## Test

`make re && ./webserve custom.conf`로 컴파일 및 자체 설정 파일 테스트를 통과했습니다.

GET 요청 메서드 테스트를 통과했습니다.
POST 요청 처리 테스트를 통과했습니다.
여러 POST 요청을 연속하여 처리하는 테스트를 통과했습니다.
chunked body를 가지는 POST 요청에 대해 제대로 파싱하는 것을 확인했습니다.
chunked body를 가지는 POST 요청에 대해 형식이 틀렸을 때 400 응답을 반환하는 테스트를 통과했습니다.
DELETE 요청 처리 테스트를 통과했습니다.
요청 메세지 파싱에 실패했을 때 400응답을 반환하지는 확인하는 테스트를 통과했습니다.
GET, POST, DELETE 가 아닌 것이 요청 메세지의 메서드 위치에 올 경우 nginx와 마찬가지로 405 응답을 반환하는지 확인하는 테스트를 통과했습니다.
POST 요청 메세지에 `Transfer-Encoding`이 없는데 `Content-Length`도 없을 때 411 응답을 반환하는지 확인하는 테스트를 통과했습니다.
client_max_body_size를 넘으면 413 응답을 반환하는지 확인하는 테스트를 통과했습니다.

리뷰 해주시고 문제 없으면 approve 해주시면 감사하겠습니다. 🙂
```
```
2022-06-05
## Description

default error page를 동적으로 생성하는 함수 작성 및 적용
- POST, DELETE, 301, 400, 404, 405, 411, 413, 500에 적용
config의 error_page 지시자를 사용하여 명시된 파일의 내용을 error page로 사용하는 기능 구현
- 사용법: `error_page 404 /Users/jeonpark/git/debug/contents/webserv/404error.html;`

## Test

make re && ./webserve custom.conf 자체 설정 파일 테스트를 통과했습니다.
error_page를 바꾸면 잘 적용되는 것을 확인했습니다.

리뷰 해주시고 문제 없으면 approve 해주시면 감사하겠습니다. 🙂
```
```
2022-06-06
## Interface Description

요청에 따른 target virtual server를 반복적으로 계산하는 것을 피하기 위해 Connection 객체에 _targetVirtualServer 멤버 변수를 추가했습니다.
EventContext::EventType을 추가했습니다.
- EV_SetVirtualServerErrorPage: error page로 지정한 파일을 읽어야 함
- EV_GETResponse: GET의 요청 파일을 읽어야 함
- EV_POSTResponse: POST의 요청 파일을 써야 함

해당 이벤트 플래그와 함께 매칭되는 함수도 추가했습니다.

## Implementation Description

기존에 int를 반환하던 VirtualServer의 메서드들을 VirtualServer::ReturnCode 및 EventContext::EventType을 반환하도록 수정하였습니다.
VirtualServer의 몇몇 메서드들이 추가 인자로 EventHandler를 전달받도록 수정하였습니다.

## Test

make re && ./webserve custom.conf 자체 설정 파일 테스트를 통과했습니다.
GET, POST, DELETE가 전과 같이 잘 동작하는 것을 확인했습니다.

리뷰 해주시고 문제 없으면 approve 해주시면 감사하겠습니다. 🙂
```

2022-05-19 ~
# HTTP Request Method

# GET
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET

HTTP GET 메서드는 명시된 resource의 representation을 요청한다.
GET을 사용하는 요청은 오직 데이터를 요청하는데 사용되어야 한다.(스스로 데이터를 포함하지 않아야 한다.)

Note: GET 요청에서 body나 payload를 보내는 것은 요청을 거절하는 구현을 야기할 수도 있다 - specification에 금지되어 있지는 않다, 문법은 정의되어 있지 않다.
GET 요청에서 payload를 보내는 것은 피하는 것이 낫다.

### https://www.rfc-editor.org/rfc/rfc7231.html#section-4.3.1

2022-05-10 ~ 2022-05-18
# Status Code

# 소개
---
https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
이 사이트(iana)가 HTTP의 status code를 관리한다.
하지만
https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/200
MDN에 정리된 목록을 기준으로 조사를 진행하였다.
RFC723x < MDN < iana 순으로 리스트된 상태 코드의 갯수가 많았고,
iana에는 있는데 MDN에 없다면 빠르게 조사할 수 없기 때문이다.
MDN에 없는 상태 코드라면 잘 안쓰이지 않을까 하는 기대도 있다.

# MVP(Minimum Viable Product)
---
200 OK
201 Created
301 Moved Permanently
400 Bad Request
403 Forbidden
404 Not Found
405 Method Not Allowed
411 Length Required
413 Payload Too Large
500 Internal Server Error
505 HTTP Version Not Supported

# RFC[7231.6.]
---
상태 코드의 첫 숫자가 응답의 분류를 정의한다.
첫 숫자로 5개의 값이 존재한다.

- 1xx (Informational): 요청을 받았으며, 아직 처리중임.
- 2xx (Successful): 요청을 성공적으로 받았고 이해했으며 수용되었음.
- 3xx (Redirection): 요청을 완료하기 위해 추가 행동이 필요함.
- 4xx (Client Error): 요청이 나쁜 문법을 포함하거나 fulfill될 수 없음.
- 5xx (Server Error): 서버가 외관상 올바른 요청을 fulfill하는데 실패함.

# 100 Continue
---
# 101 Switching Protocols
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/101

### [RFC7231.6.2.2.]
Upgrade 헤더 필드가 있는 요청을 받았을 때 해당 요청을 처리했으면 upgrade를 처리했다는 의미에서 101 상태 코드로 응답한다.

### 의견:
Upgrade를 구현하지 않는다면 101도 구현할 필요가 없을 것 같습니다.

# 103 Early Hints
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/103

서버가 아직 요청을 처리중인데 클라이언트에게 미리 로딩을 하라고 하기 위해 Link 헤더 필드와 함께 103 상태 코드로 응답한다.

### 의견:
HTTP 서버를 위한 최소 요구 사항은 아닌 것 같습니다.

# 200 OK
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/200

요청이 성공했음을 표시한다.
default로 cacheable이다.
요청 메서드에 따라 다른 의미를 지닌다.
- GET: 자원이 fetch되었고 message body로 전달되었다.
- POST: 행동의 결과를 의미하는 자원이 message body로 전달되었다.

- DELETE의 성공적인 결과는 종종 200 (OK) 라기 보다는 204 (No Content) 이다.

### [RFC7231.6.3.1.]

요청이 성공했음을 표시한다.
200 요청으로 전달되는 payload는 요청 메서드에 따라 다르다.

- GET: target resource의 representation
- POST: action의 상태의 representation 또는 action으로 얻은 결과의 representation
- DELETE: action의 상태의 representation

### 의견:
정상적으로 요청을 처리했을 경우, 200 상태 코드를 갖는 응답 메세지를 전달하면 될 것 같습니다.

# 201 Created
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/201

요청이 성공했고, 그 결과로 어떤 resource가 생성됐음을 표시한다.
새로운 resource가 사실상 이 응답을 전송하기 전에 생성됐고 새로운 resource가 메세지의 body로 반환된다.
생성된 resource의 location은 요청의 URL이거나 Location 헤더의 값이다.
이 상태 코드의 일반적인 쓰임은 POST 요청의 결과로서의 응답이다.

### [RFC7231.6.3.2.]

요청이 fulfill되었고, 그 결과 하나 이상의 새로운 resource가 생성됐음을 표시한다.
요청으로 생성된 primary resource는 응답의 Location 헤더 필드로 식별되거나, 또는 Location 필드가 없다면, effective 요청 URI로 식별된다.
응답의 payload는 일반적으로 생성된 resource(s)를 묘사하고 link한다.

### 의견:
POST 요청 메서드를 갖는 요청을 성공적으로 처리한 결과로, 201 상태 코드를 갖는 응답을 전달하면 될 것 같습니다.
이 때 저희 서버는 요청 메세지에 적힌 target URI에 파일을 생성할 것이므로 따로 Location 헤더 필드를 생성하지는 않아도 될 것 같습니다.
응답의 message body에는 생성한 파일을 담으면 될 것 같습니다.

# 202 Accepted
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/202

요청 처리가 받아들여 졌음을 표시한다, 하지만 아직 다 처리되지는 않았다; 사실 처리가 시작되지도 않았을 수 있다.
요청은 실제 요청을 처리하는 동안 거부될 수 있기 때문에 요청이 결국 처리될 수도 있고 처리되지 않을 수도 있다.

202는 non-committal이다.
HTTP가 나중에 요청 처리의 결과물을 표시하는 asynchronous 응답을 보낼 방법이 없다는 것을 의미한다.
다른 프로세스나 서버가 요청을 다루는 경우나 batch processing을 의도되었다.

### [RFC7231.6.3.3.]

요청 처리가 받아들여 졌음을 표시한다, 하지만 아직 다 처리되지는 않았다.
요청은 실제 요청을 처리하는 동안 거부될 수 있기 때문에 요청이 결국 처리될 수도 있고 처리되지 않을 수도 있다.
HTTP에는 asynchronous 작용으로 상태 코드를 추가로 보내는 설비는 없다.

202 응답은 의도적으로 noncommittal이다.
202의 목적은 요청 처리가 완료될 때까지 UA의 연결이 유지돌 필요 없이 서버가 다른 프로세스(가령 하루에 한 번 실행되는 batch-oriented 프로세스)를 위한 요청을 받는 것을 허용하는 것이다.
이 응답으로 전달되는 표현은 요청의 현재 상태를 묘사해야 하며, 사용자에게 요청이 언제쯤 fulfill될지 예상을 제공할 수 있는 상태 모니터를 point하거나 embed해야 한다.

### 의견:
우리는 처리가 완료되기까지 오랜 시간이 걸리는 프로세스를 따로 명시하여 호출하는 기능을 제공하지 않을 것이기 때문에 구현하지 않아도 될 것 같습니다.

# 203 Non-Authoritative Information
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/203

처리는 성공했지만 proxy가 임의로 payload를 수정했을 때 응답하는 status code

### 의견:
구현하지 않아도 될 것 같습니다.

# 204 No Content
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/204

요청이 성공했지만 클라이언트가 현재 페이지를 떠나 탐색할 필요가 없음을 표시한다.

### 의견:
응답을 받아도 현재 페이지에 머물러도 된다는 정보를 전달하는 용도의 추가적인 기능 같습니다.
굳이 구현하지 않아도 될 것 같습니다.

# 205 Reset Content
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/205

클라이언트에게 form에 내용을 clear하거나 canvas 상태를 리셋하거나 또는 UI를 refresh하기 위해 document view를 리셋하라고 말하는 것이다.

### 의견:
이 status code도 구현하지 않아도 될 것 같습니다.

# 206 Partial Content
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/206

요청이 성공했고 요청의 Range 헤더에 묘사된 range의 데이터를 body가 담고 있음을 표시한다.

### 의견:
Range 헤더를 구현한다면 이 상태 코드를 갖는 응답을 하도록 구현하면 될 것 같습니다.
일단은 Range 헤더를 가지는 요청을 처리하는 기능을 구현할지 안할지 모르기 때문에 간단한 조사만 했습니다.
필요에 따라 위 모질라 링크로 가서 내용을 더 읽고 RFC 문서도 읽으세요.

# 300 Multiple Choices
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/300

요청에 대한 가능한 응답이 하나 이상 있음을 표시한다.
UA나 사용자는 그 응답들 중 하나를 선택해야 한다.
응답들 중 하나를 선택하는 표준화된 방식이 없기 때문에, 이 응답 코드는 매우 희귀하게 사용된다.

### 의견:
좀 특별한 기능을 위한 상태 코드인 것 같습니다.
일단은 그냥 넘어가도 될 것 같습니다.

# 301 Moved Permanently
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/301

요청한 resource가 Location 헤더에 있는 URL로 명백하게 옮겨져 있음을 표시한다.
브라우저는 새로운 URL로 리다이렉트하고, 검색 엔진은 그 resource에 대한 그들의 링크를 업데이트 한다.

Note: RFC의 specification에서는 리다이렉션이 수행되었을 때 메서드와 바디가 변하지 않고 남아 있어야 함을 요구함에도 불구하고, 모든 UA가 이 요구사항을 지키는 것은 아니다.
GET이나 HEAD 메서드의 응답을 위해서만 301 코드를 사용하고, POST 메서드를 위해서는 대신 308 Permanent Redirect를 사용해라, 308은 메서드 변경이 명시적으로 금지되어 있다.

### [RFC7231.6.4.2.]

target resource가 새로운 영구적인 URI를 할당받았고, 미래에 이 resource로의 참조들은 동봉된 URI들 중 하나를 사용해야 함을 표시한다.
링크를 수정하는 능력을 가진 클라이언트들은 reference들을 가능할 때 자동으로 하나 이상의 새로운 reference들(서버가 보낸)로의 effective 요청 URI로 re-link 해야 한다.

서버는 응답에 새로운 영구적인 URI를 위한 선호하는 URI reference를 담고 있는 Location 헤더 필드를 생성해야 한다.(SHOULD)
UA는 자동 리다이렉션을 위해 Location 필드의 값을 사용할 수도 있다.(MAY)
서버의 응답 payload는 대게 새로운 URI(s)로의 hyperlink가 있는 짧은 hypertext note를 담고 있다.

Note: 역사적인 이유로, UA는 subsequent 요청에서 POST에서 GET으로 요청 메서드를 바꿀지도 모른다.(MAY)
만약 이 행동을 원하지 않는다면, 307 (Temporary Redirect) 상태 코드를 대신 사용할 수 있다.

301 응답은 default가 cacheable이다; 즉, 메서드 정의나 명시적 캐시 제어로 달리 표시되지 않는 한.

### 의견:
config 파일에서 return 지시자의 값으로 특정 URI를 명시했을 때, 해당 서버가 return 행동을 해야 하는 요청을 받았을 때 GET 메서드 요청이라면 301 상태 코드를 가지는 응답을 전달해야 할 것 같습니다.
이 때 해당 응답은 Location 헤더 필드를 가지며 그 값은 return 지시자의 값을 가질 것 같습니다.
만약 POST 메서드 요청이라면 307이나 308 상태 코드를 갖는 응답을 전달해야 할 것 같습니다.

# 302 Found
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/302

요청한 resource가 Location 헤더에 주어진 URL로 임시적으로 옮겨졌음을 표시한다.
브라우저는 이 페이지로 리다이렉트를 하지만 검색 엔진은 그들의 링크를 그 resource로 업데이트 하지 않는다.

### 의견:

301과 비슷하지만 검색 엔진에게 해당 리다이렉트를 업데이트 할지에 대해서만 다른 의미를 갖는 상태 코드 같습니다.
굳이 검색 엔진 측면까지 고려하여 서버를 만들지는 않아도 될 것 같습니다.

# 303 See Other
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/303

리다이렉트가 요청한 resource에 링크되지 않고, 다른 페이지(confirmation 페이지나 현실 object의 표현(HTTP range-14를 봐라) 또는 업로드 진행 페이지 같은)에 링크되어 있음을 나태낸다.
이 요청 코드는 종종 PUT이나 POST의 결과로 전달받는다.
이 리다이렉트된 페이지를 화면에 띄우기 위해 사용되는 메서드는 항상 GET이다.

### 의견:
기본적인 리다이렉션 이상의 추가 기능을 부여하기 위한 용도의 상태 코드인 것 같습니다.
단순 리다이렉션을 구현할 때는 불필요할 것 같습니다.

# 304 Not Modified
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/304

요청한 resource들을 재송신할 필요가 없음을 표시한다.
cached resource로의 묵시적 리다이렉션이다.
요청 메서드가 GET이나 HEAD 같은 safe method일 때 발생한다.
또는 요청이 conditional이고 If-None-Match나 If-Modified-Since 헤더를 사용할 때 발생한다.

### 의견:
수정되지 않았으니 캐시에 있는 데이터를 사용하면 된다는 것을 의미하는 상태 코드인 것 같습니다.
저희는 캐시를 구현하지 않을 것이기 때문에 이 상태 코드도 신경쓰지 않아도 될 것 같습니다.

# 307 Temporary Redirect
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/307

요청한 resource가 일시적으로 Location 헤더에 있는 URL로 옮겨졌음을 표시한다.

original 요청의 메서드와 바디는 리다이렉트된 요청을 수행하기 위해 재사용된다.
사용된 메서드가 GET으로 바뀌길 원하는 경우라면 303 See Other를 대신 사용해라.
PUT 메서드의 응답으로 업로드된 resources가 아니라 확인 메세지를 주고 싶을 때 유용하다.("XYZ 업로드에 성공했다" 같은)

307이 302와 다른 유일한 차이점은 307은 리다이렉트 된 요청을 생성할 때 메서드와 바디가 바뀌지 않을 것을 보장한다는 점이다.
302 응답 시, 몇 오래된 클라이언트들은 부정확하게 GET으로 메서드를 바꿀 것이다.
GET이 아닌 메서드와 302의 행동은 결국 Web에서 예측 불가능하다, 반면 307의 행동은 예측이 가능하다.
GET 요청의 경우는 두 상태 코드의 행동이 동일하다.

### 의견:
302를 구현한다면 GET 이외의 메서드를 위해 307도 구현해야 할 것입니다.
하지만 지금 저희 서버는 302를 구현할지 확실하지 않습니다.(저는 안해도 된다고 생각합니다.)
만약 302와 307을 구현한다면 RFC 문서에서 307에 대한 내용을 추가로 읽으십시오.

# 308 Permanent Redirect
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/308

요청한 resource가 Location 헤더에 있는 URL로 명백히 옮겨졌음을 표시한다.
브라우저는 이 페이지로 리다이렉트하고, 검색 엔진은 그들의 링크들을 이 resource로 업데이트한다.

요청 메서드와 바디는 수정되지 않을 것이다. 반면 301은 때때로 부정확하게 GET 메서드로 변할 것이다.

Note: 몇몇의 Web 어플리케이션들은 308 Permanent Redirect를 non-standard 방식이나 다른 목적으로 사용할지도 모른다.
예를 들어, 구글 드라이브는 클라이언트에게 불완전한 업로드가 멈춘 것을 표시하기 위해 308 Resume Incomplete 응답을 사용한다.

### 의견:
이 상태 코드를 구현할지 말지를 판단하기 위해서는 GET이외의 메서드를 갖는 요청에 대해 리다이렉션을 수행하는 경우를 구현할지를 결정해야 합니다.
만약 POST 등에 대해 리다이렉션을 하도록 지원하고자 한다면 308 상태 코드를 구현해야 할 것 같습니다.
하지만 평가지에 그런 구체적인 내용은 존재하지 않습니다.
서브젝트 pdf의 내용에서도 HTTP의 리다이렉션을 구현하라고만 나와 있습니다.
따라서 GET에 대해서만 리다이렉션을 하도록 파싱을 강제하여 서버를 구현하고 301 까지만 구현하면 될 것 같습니다.

# 400 Bad Request
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/400

클라이언트 에러로 인지되는 무언가로 인해 서버가 요청을 처리할 수 없거나 처리하지 않을 것임을 표시한다.(예를 들어, 잘못된 형식의 요청 문법, 부적절한 요청 메세지 framing, 또는 악의적인 요청 routing 등)

Warning: 클라이언트는 수정 없이 이 요청을 반복하지 않아야 한다.

### [RFC7231.6.5.1]

클라이언트 에러로 인지되는 무언가로 인해 서버가 요청을 처리할 수 없거나 처리하지 않을 것임을 표시한다.(예를 들어, 잘못된 형식의 요청 문법, 부적절한 요청 메세지 framing, 또는 악의적인 요청 routing 등)

### 의견:
위 설명에 나와 있듯이 요청 메세지의 문법 에러 등 클라이언트의 문제라고 판단되는 경우 400 상태 코드를 갖는 응답을 전송하면 될 것 같습니다.

# 401 Unauthorized
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401

권한 자격이 없어 클라이언트의 요청을 거부하는 경우 이 상태 코드를 갖는 응답을 전송합니다.

### 의견:
권한(Authentication) 관련 상태 코드라서 더 조사하지는 않았습니다.
만약 권한 관련 구현을 한다면 더 구체적인 조사를 해야 할 것입니다.

# 402 Payment Required
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/402

미래에 사용할 것을 위해 보존해둔 비표준 응답 상태 코드이다.
이 상태 코드는 디지털 cash나 지불 시스템을 가능하게 하기 위해 생성되었다.
그리고 이 상태 코드는 요청한 콘텐트가 클라이언트가 지불을 완료할 때까지 사용을 할 수 없을 것임을 표시한다.

### 의견:
이건 그냥 아닌 것 같습니다.

# 403 Forbidden
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/403

서버가 요청을 이해했으나 권한을 부여하기 위해 거절함을 표시한다.

이 상태는 401과 유사하다, 그러나 403 Forbidden 상태 코드에서는 re-authenticating이 차이를 만들지 않는다.
접근은 영원히 금지되어 있고 어플리케이션 로직과 엮여 있다, resource에 대한 불충분한 권한과 같은.

### [RFC7231.6.5.3.]

서버가 요청을 이해했으나 권한을 부여하기 위해 거절함을 표시한다.
왜 요청이 금지됐는지를 public으로 만들기 원하는 서버는 그 이유를 응답의 payload에 묘사할 수 있다.

만약 권한 자격이 요청에서 제공됐다면, 서버는 그것들이 접근에 불충분하다고 여긴다.
클라이언트는 이 요청을 같은 자격으로 자동으로 반복하지 말아야 한다.(SHOULD NOT)
클라이언트는 새로운 거나 다른 자격으로 요청을 반복할 수도 있다.(MAY)
하지만 요청은 자격과 관련 없는 이유로 금지될 것이다.

금지된 target resource의 현재 존재를 "숨기고" 싶어하는 origin 서버는 대신 404 (Not Found)로 응답할 수도 있다.(MAY)

### 의견:
HTTP에서 정의하는 권한 시스템과 별개로 서버 내에서 파일 접근 등에 관련된 실질적인 권한이 존재하지 않는 경우 403 상태 코드를 갖는 응답을 전송하면 될 것 같습니다.
서버의 파일 시스템 상, 하려는 작업의 권한이 존재하지 않는 경우가 해당될 것 같습니다.

# 404 Not Found
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/404

서버가 요청한 resource 찾을 수 없다는 것을 표시한다.
404 페이지로 이끄는 링크들은 종종 broken 또는 dead links라고 불리고, link rot의 주제가 될 수 있다.

404 상태 코드는 resource가 없다는 것만을 표시한다: 부재가 일시적인지 영구적인지는 알 수 없다.
만약 resource가 영구적으로 제거된 것이라면, 대신 410 (Gone) 상태를 사용해라.

### [RFC7231.6.5.4.]

origin 서버가 target resource를 위한 현재 표현을 찾지 못했다는 것을 표시한다.
또는 존재하는 resource를 disclose하지 않을 것을 표시한다.
404 상태 코드는 표현의 결핍이 일시적인지 또는 영구적인지를 표시하지는 않는다; 만약 상태가 영구적일 것 같은 것을 origin 서버가 알 때는(아마도 어떤 configurable 수단으로) 410 (Gone) 상태 코드가 404보다 선호된다.

404 응답은 default가 cacheable이다; 즉, 메서드 정의나 명시적 캐시 제어로 달리 표시되지 않는 한.

### 의견:
target resource가 없을 때는 404 상태 코드를 갖는 응답을 전송하면 될 것 같습니다.
다만 config file에서 autoindex 여부와 index 여부에 따라 404로 응답할지 지정된 특정 행동을 할지가 달라질 것 같습니다.

# 405 Method Not Allowed
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405

서버가 요청 메서드를 알지만 target resource가 해당 메서드를 지원하지 않음을 표시한다.

서버는 반드시 404 상태 코드 응답에서 Allow 헤더 필드를 생성해야 한다.
이 필드는 반드시 target resource가 현재 지원하는 메서드 리스트를 담아야 한다.

### [RFC7231.6.5.5.]

origin 서버가 request-line 안에 전달받은 메서드를 알지만 target resource가 지원하지 않음을 표시한다.
origin 서버는 405 응답에 반드시 target resource가 현재 지원하는 메서드의 리스트를 담는 Allow 헤더 필드를 생성해야 한다.(MUST)

405 응답은 default가 cacheable이다; 즉, 메서드 정의나 명시적 캐시 제어로 달리 표시되지 않는 한.

### 의견:
target resource에 대해 config file에서 허용하지 않은 메서드 요청이 들어오는 경우 405 상태 코드를 갖는 응답을 전송하면 될 것 같습니다.
이 때 해당 응답 메세지에는 Allow 헤더 필드를 넣고, 값으로 허용된 메서드의 목록을 넣어주면 될 것 같습니다.

# 406 Not Acceptable
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/406

### 의견:
Accept, Accept-Encoding, Accept-Language 등 content negotiation(위 링크 참고)에 사용되는 헤더 필드를 해석하여 적용한다면 필요할 것 같습니다.
하지만 저희는 이 헤더 필드를 사용하지 않을 것 같기 때문에 더 조사하지 않고 넘어가도록 하겠습니다.

# 407 Proxy Authentication Required
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/407

### 의견:
Authentication 관련된 상태 코드인 것 같습니다.
넘어가도록 하겠습니다.

# 408 Request Timeout
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/408

서버가 사용하지 않는 이 연결을 끊고자 한다는 것을 표시한다.
클라이언트의 요청이 없어도, 서버가 놀고 있는 연결에게 전달한다.(일반적으로는 요청이 있어야 응답을 전송함)

서버는 이 응답에 "close" Connection 헤더 필드를 전달해야 한다, 408은 서버가 계속 기다리는 것보다 연결을 끊기로 결정했음을 내포하기 때문에.

몇몇 브라우저들(크롬, 파이어폭스, IE)이 HTTP pre-connection 매커니즘을 사용하여 서핑 속도를 올리기 때문에 이 응답이 더 자주 사용된다.

Note: 몇몇 서버들만이 이 메세지 없이 연결을 끊는다.

### [RFC7231.6.5.7.]

서버가 기다리기로 준비한 시간 안에 완전한 요청 메세지를 받지 못했다는 것을 표시한다.
서버는 응답에 "close" 연결 옵션을 보내야 한다, 408은 서버가 계속 기다리는 것보다 연결을 끊기로 결정했음을 내포하기 때문에.(SHOULD)
만약 클라이언트가 outstanding 요청을 전송 중이었다면, 클라이언트는 그 요청을 새로운 연결에서 재전송할 수도 있다.(MAY)

### 의견:
이 상태 코드는 구현할 수도 있지만 평가지에서 특별히 평가하는 대상은 아니기 때문에 중요도는 낮다고 생각합니다.
게다가 nginx는 이 상태 코드를 갖는 응답을 전송하지 않고 연결을 끊습니다.
따라서 1차적으로는 구현하지 않아도 괞찮을 것 같습니다.

# 409 Conflict
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/409

요청이 현재 target resource의 상태와 모순됨을 표시한다.

conflict는 대부분 PUT 요청의 응답에서 발생한다.
예를 들어, 서버에 존재하는 파일보다 더 오래된 파일을 업로드하려고 할 때 버전 컨트롤 conflict를 초래하며 409 응답을 받을 것이다.

### 의견:
중요도는 낮은 것 같습니다.
추후 필요할 것 같은 곳에 적용할 수 있도록 용도만 익혀두면 될 것 같습니다.
이 상태 코드를 요구하는 딱 떠오르는 과제의 요구사항은 모르겠습니다.
아마 존재하더라도 평가 때 이거에서 걸리지는 않을 것 같습니다.

# 410 Gone
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/410

origin 서버에서 target resource의 접근이 더 이상 가능하지 않음과, 이 상태가 영원할 것 같음을 표시합니다.

만약 이 상태가 일시적일지 영원할지 알 수 없다면 대신 404 상태 코드를 사용해야 할 것입니다.

Note: 410 응답은 default가 cacheable입니다.

### [RFC7231.6.5.9.]

origin 서버에서 target resource의 접근이 더 이상 가능하지 않음과, 이 상태가 영원할 것 같음을 표시합니다.
만약 origin 서버가 이 상태가 영원할지 아닐지 알 수 없거나 결정할 수 있는 설비가 없다면 대신 404 (Not Found) 상태 코드를 사용해야 할 것입니다.

410 응답은 주로 수용자에게, resource가 의도적으로 이용 불가능함과, 서버 소유자가 그 resource로의 원격 link를 삭제하기를 원함을 알려 web 관리를 보조하도록 의도되었다.
이러한 이벤트는 흔히 제한된 시간동안 판촉 서비스나, 더이상 origin 서버 사이트와 관련이 없이 개별적인 존재에 속하는 resource들을 위한 것이다.
영구적으로 사용 불가능한 모든 resource들을 "gone"으로 표시하거나, 표시를 어떤 정해진 시간 동안 유지할 필요는 없다 -- 서버 소유자의 판단으로 남아 있다.

410 응답은 default가 cacheable이다; 즉, 메서드 정의나 명시적 캐시 제어로 달리 표시되지 않는 한.

### 의견:
우리는 특정 resource에 대해 접근을 짧은 시간동안 허용했다가 차단하는 형식의 기능을 제공하지 않을 것이기 때문에 이 상태 코드를 사용할 일은 없을 것 같습니다.

# 411 Length Required
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/411

서버가 Content-Length 헤더 없는 요청 수용을 거부함을 표시한다.

Note: specification에 의하면, chunked로 데이터를 보낼 때는, Content-Length 헤더가 생략되고 각 chunk의 앞에 현재 chunk의 길이를 16진수 형식으로 둬야 한다.

### [RFC7231.6.5.10.]

서버가 Content-Length 헤더 없는 요청 수용을 거부함을 표시한다.
만약 요청 메세지에 message body의 크기를 갖는 타당한 Content-Length 헤더 필드를 추가한다면 클라이언트는 요청을 반복할 수도 있다.(MAY)

### 의견:
chunked가 아닌 POST 메서드 요청이 Content-Length 헤더 필드를 가지고 있지 않다면 411 상태 코드를 갖는 응답을 전송하면 될 것 같습니다.

# 412 Precondition Failed
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/412

### 의견:
conditional 요청에 대해 특정 상황에 전송되는 응답입니다.
서브젝트와 평가지에서 conditional에 대해 확인하지 않기 때문에 conditional을 구현하지 않아도 된다고 생각하고, 따라서 이 상태 코드는 신경쓰지 않아도 될 것 같습니다.

# 413 Payload Too Large
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/413

요청 entity가 서버에서 정의된 제한보다 더 큼을 표시한다; 서버는 연결을 끊거나 Retry-After 헤더 필드를 반환할 것이다.

### [RFC7231.6.5.11.]

서버가 처리하기 원하거나 처리할 수 있는 정도보다 요청 payload가 크기 때문에 요청을 거부함을 표시한다.
서버는 클라이언트가 계속 요청하는 것을 막기 위해 연결을 닫을 수도 있다.(MAY)

만약 상태가 일시적이라면 서버는 Retry-After 헤더 필드를 생성해서 이것이 일시적이며 어느 정도의 시간 뒤에 클라이언트가 재시도(MAY)할 수 있을지를 표시해야 한다.

### 의견:
client_max_body_size과 관련이 있는 상태 코드인 것 같습니다.
client_max_body_size보다 요청의 payload body가 크다면 413 상태 코드를 갖는 응답을 전송하고 연결을 닫으면 될 것 같습니다.
일시적인 상태라면 Retry-After 헤더 필드를 전송하라고 하지만, 저희는 일시적인 상태를 구현하지 않을 것이기 때문에 Retry-After는 구현하지 않아도 될 것 같습니다.

# 414 URI Too Long
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/414

클라이언트에 의해 요청된 URI가 서버가 해석하고자 하는 것보다 김을 표시한다.

이것이 발생할 몇 가지 희귀한 경우가 있다:

- 클라이언트가 긴 쿼리 정보를 가진 POST 요청을 부적절하게 GET 요청으로 변환할 때.
- 클라이언트가 리다이렉션 loop 속으로 빠져들 때(예를 들면, 자기 자신을 접미사로 가리키는 리다이렉션된 URI의 접두사)
- 또는 잠재적 보안 구멍을 exploit하는 시도를 하는 클라이언트에게 서버가 공격 받고 있을 때

### [RFC7231.6.5.12.]

요청 target이 서버가 해석하기 원하는 더 길기 때문에 요청 서비스 제공을 거부함을 표시한다.
이 희귀한 상태는 오직
- 클라이언트가 긴 쿼리 정보를 가진 한 POST 요청을 GET 요청으로 부적절하게 변환했을 때,
- 클라이언트가 리다이렉션 "블랙홀" 속에 빠져들 때(예를 들면, 자기 자신을 접미사로 가리키는 리다이렉션된 URI의 접두사),
- 또는 잠재적 보안 구멍을 exploit하는 시도를 하는 클라이언트에게 서버가 공격 받고 있을 때
발생할 것 같다.

414 응답은 default가 cacheable이다; 즉, 메서드 정의나 명시적 캐시 제어로 달리 표시되지 않는 한.

### 의견:
target URI의 길이에 제한을 둘 것이라면 이 상태 코드를 갖는 응답을 전송하면 될 것 같습니다.
하지만 저희 프로젝트의 서브젝트 요구사항이 아니고 평가표에서도 확인하지 않기 때문에 필수 항목은 아니라고 생각합니다.

# 415 Unsupported Media Type
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/415

payload 형식이 지원하지 않는 형식이기 때문에 서버가 요청 받아들이는 것을 거부함을 표시한다.

형식 문제는 요청의 Content-Type 또는 Content-Encoding 때문일 수도 있다.
또는 데이터를 직접 조사한 결과일 수도 있다.

### [RFC7231.6.5.13.]

payload의 형식이 target resource로의 요청 메서드가 지원하지 않는 형식이기 때문에 origin 서버가 요청을 처리하는 것을 거부하는 것을 표시한다.
형식 문제는 요청의 Content-Type 또는 Content-Encoding 때문일 수도 있다.
또는 데이터를 직접 조사한 결과일 수도 있다.

### 의견:
target resource와 요청 메서드에 따라 특정 MIME type을 특별히 지원하거나 지원하지 않는 기능을 제공하는 것은 서브젝트나 평가지의 요구사항이 아니라고 생각합니다.

# 416 Range Not Satisfiable
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/416

### 의견:
Range 헤더 필드와 관련된 내용인 것 같습니다.
Range 헤더 필드를 구현하지 않을 것 같기 때문에 넘어가도록 하겠습니다.

# 417 Expectation Failed
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/417

요청의 Expect 헤더에 주어진 예측이 만족될 수 없음을 표시한다.

자세한 내용은 Expect 헤더를 참고하라.

### 의견:
Expect 헤더 필드를 해석하여 사용하는 기능을 구현한다면 이 상태 코드를 갖는 응답을 전송하는 경우가 존재하겠지만
Expect 헤더 필드를 해석하는 기능을 구현하지 않는다면 이 상태 코드를 갖는 응답을 전송하는 경우는 없을 것 같습니다.
Expect 헤더 필드를 해석하는 것은 서브젝트나 평가지의 요구사항이 아닌 것 같습니다.

# 418 I'm a teapot
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/418

### 의견:
joke로 만들어진 상태 코드입니다.

# 422 Unprocessable Entity
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/422

서버가 요청 entity의 content type을 이해하고, 요청 entity의 문법이 올바르지만, 담고 있는 instruction들을 처리할 수 없었음을 표시한다.

Warning: 클라이언트는 이 요청을 수정 없이 반복하지 않아야 한다.

### https://datatracker.ietf.org/doc/draft-ietf-httpbis-semantics/
> 15.5.21.  422 Unprocessable Content

서버가 요청 content의 content type을 이해했고 (415 (Unsupported Media Type) 상태 코드가 부적절하기 때문에), 요청 content의 문법이 올바르지만, 담고 있는 instruction들을 처리할 수 없었음을 표시한다.
예를 들어, 이 상태 코드는 만약 XML 요청 content가 형식을 잘 지킨 content를 담고 있지만, semantically erroneous XML instruction인 경우 보내질 수 있다.

### 의견:
HTTP 상에는 문제가 없지만 body가 담고 있는 데이터를 instruction으로 사용하여 어떤 작업을 하는 동안 에러가 발생할 때 이 상태 코드를 갖는 응답을 전송할 것 같습니다.
저희는 body를 instruction으로 사용하는 기능을 구현하지 않을 것이기 때문에 이 상태 코드를 구현하지 않아도 될 것 같습니다.

# 425 Too Early
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/425

### 의견:
실험적인 코드로서, 크롬이 이 상태 코드에 호환되는지 여부도 확실하지 않은 상태 코드입니다.
구현하지 않아도 될 것 같습니다.

# 426 Upgrade Required
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/426

현재 프로토콜을 사용하여 요청을 수행하는 것을 서버가 거부하지만 클라이언트가 다른 프로토콜로 upgrade를 한 후에는 요청을 수행할지도 모름을 표시한다.

서버는 필요한 프로토콜(들)을 표시하기 위해 요청과 함께 Upgrade 헤더를 보낸다.

### 의견:
저희는 HTTP 단일 프로토콜을 구현할 것이기 때문에 다른 프로토콜로 전환하는 기능을 위한 Upgrade 헤더 필드도 구현하지 않을 것이고,
다른 프로토콜로의 전환을 요구하는 이 상태 코드도 구현하지 않아도 될 것 같습니다.

# 428 Precondition Required
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/428

서버가 요청이 conditional일 것을 요구함을 표시한다.

일반적으로, If-Match와 같은 precondition 헤더가 필요한데 없는 것을 의미한다.

precondition 헤더가 서버 쪽의 상태와 일치하지 않으면, 응답은 412 Precondition Failed가 될 것이다.

When a precondition header is not matching the server side state, the response should be 412 Precondition Failed.

### 의견:
서버가 클라이언트에게 conditional일 것을 요청하는 기능은 서브젝트나 평가지에 명시되어 있지 않기 때문에
이 상태 코드는 구현하지 않아도 될 것 같습니다.

# 429 Too Many Requests
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429

사용자가 일정 시간 안에 너무 많은 요청을 보냈음을 표시한다("rate limiting").

새로운 요청을 만들기 위해 얼마나 오래 기다려야 하는지를 표시하기 위해 이 응답에 Retry-After 헤더가 포함될 수도 있다.

### 의견:
일정 시간 안에 사용자로부터 받아들이는 요청의 수에 제한을 두는 기능은 서브젝트나 평가지에 명시되어 있지 않기 때문에
이 상태 코드는 구현하지 않아도 될 것 같습니다.

# 431 Request Header Fields Too Large
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431

요청의 HTTP 헤더들이 너무 길기 때문에 서버가 요청 처리를 거부했음을 표시한다.
요청 헤더들의 크기를 줄인 후에, 요청은 다시 제출될 수도 있다.

431은 요청 헤더들의 총 크기가 너무 클 때 사용될 수 있다.
또는 단일 헤더 필드가 너무 길 때 사용될 수 있다.
이 오류가 발생하는 사람들을 돕기 위해 응답 body에 둘 중 어느 것이 문제인지 표시하십시오.
이상적으로는 너무 큰 헤더도 포함하십시오.
이것은 사용자가 문제를 고치도록 시킨다, 쿠키를 지우는 것 같이.

서버는 종종 이 상태를 생산할 것이다 만약:
- Referer URL이 너무 길 때
- 요청에서 보내진 쿠키가 너무 많을 때

### 의견:
한 헤더나 총 헤더의 길이가 너무 길 때를 처리하는 기능은 서브젝트나 평가지에 명시되어 있지 않기 때문에
이 상태 코드는 구현하지 않아도 될 것 같습니다.

# 451 Unavailable For Legal Reasons
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/451

사용자가 법적인 이유로 가능하지 않은 resource를 요청했음을 표시한다, 법적 행동이 issue가 되는 web 페이지 같은.

### 의견:
저희는 법적인 부분을 다루지 않습니다.
넘어가겠습니다.

# 500 Internal Server Error
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500

서버가 요청 처리를 막는 예상치 못한 상태에 직면했음을 표시한다.

이 에러 응답은 전형적인 "catch-all" 응답이다.
대게, 500 상태 코드는 서버가 응답할 더 적절한 5xx 에러 코드를 찾지 못함 표시한다.
때때로, 서버 관리자는 미래에 같은 에러가 반복되는 것을 막기 위해 500 상태 코드 같은 에러 응답의 로그를 요청의 상세 사항들과 함께 남긴다.

### [RFC7231.6.6.1.]

서버가 요청 처리를 막는 예상치 못한 상태에 직면했음을 표시한다.

### 의견:
서버가 지속될 수 없는 에러가 발생했다면 500 응답을 하지 않아도 되겠지만,
서버가 지속될 수 있는 예상치 못한 에러가 발생한다면 500 상태 코드를 갖는 응답을 전송하면 될 것 같습니다.
로그를 남기는 추가 기능은 서브젝트나 평가지에 명시되지 않기 때문에 구현하지 않아도 될 것 같습니다.

# 501 Not Implemented
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/501

요청을 처리하기 위해 필요한 기능을 서버가 지원하지 않음을 의미한다.

이 상태는 또한 Retry-After 헤더를 전송할 수 있다.
이 Retry-After는 요청을 보낸 자에게 언제 기능이 지원될 수 있을지를 말해준다.

501은 서버가 요청 메서드를 인지하지 못할 때 적절한 응답이다.
그리고 any resource에 대해 그 요청 메서드를 지원할 수 없을 때 적절한 응답이다.
서버들이 501을 반환하지 않도록 지원할 필요가 있는 메서드는 오직 GET과 HEAD이다.

만약 서버가 메서드를 인지했지만 의도적으로 지원하지 않는다면, 적절한 응답은 405 Method Not Allowed이다.

Note:
501 에러는 당신이 고칠 수 있는 것이 아니라 당신이 접근을 시도한 웹 서버가 고칠 필요가 있는 것이다.(아마 client 관점의 서술인 듯 하다.)
501 응답은 default가 cacheable이다; that is, unless caching headers instruct otherwise.

### [RFC7231.6.6.2.]

요청을 처리하기 위해 필요한 기능을 서버가 지원하지 않음을 의미한다.
501은 서버가 요청 메서드를 인지하지 못할 때 적절한 응답이다.
그리고 any resource에 대해 그 요청 메서드를 지원할 수 없을 때 적절한 응답이다.

501 응답은 default가 cacheable이다; 즉, 메서드 정의나 명시적 캐시 제어로 달리 표시되지 않는 한.

### 의견:
평가지에는 UNKNOWN 메서드일 때 "크래쉬가 나지 않아야 한다"라고 되어 있는데,
크래쉬가 나지 않는건 당연하고, 501 상태 코드를 갖는 응답을 전송해야 맞는 것 같습니다.
하지만 다양한 사이트에 의미없는 메서드를 담은 요청 메세지를 보냈을 때 501이 아닌 다양한 응답을 전송했습니다.
nginx: 405 Not Allowed
naver.com: 302 Moved Temporarily
google.com: 404 Not Found
profile.intra.42.fr(nginx): 405 Not Allowed
따라서 501은 여러 사이트의 예시를 들며 디펜스가 가능하기 때문에 MVP에서 제외하도록 하겠습니다.
이 때, nginx의 행동을 따르는 식으로, 알 수 없는 메서드를 갖는 요청을 받는 경우 501이 아닌, 405 Not Allowed 상태 코드를 갖는 응답을 전송하면 좋을 것 같습니다.

# 502 Bad Gateway
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/502

게이트웨이나 프록시로서, upstream 서버로부터 타당하지 않은 응답을 받았음을 표시한다.

Note: 게이트웨이는 네트워킹에서 다른 것을 나타낼 수도 있고, 502 에러는 대게 당신이 고칠 수 있는 것이 아니고, 웹 서버나 접속하려고 한 프록시가 고쳐야 한다.

### [RFC7231.6.6.3.]

게이트웨이나 프록시로서, 요청을 처리하려고 시도하는 중에 접속한 inbound 서버로부터 타당하지 않은 응답을 받았음을 표시한다.

### 의견:
서브젝트나 평가지에 게이트웨이나 프록시의 기능에 대한 명시가 없기 때문에
구현하지 않아도 될 것 같습니다.


# 503 Service Unavailable
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503

서버가 요청을 처리할 준비가 되지 않음을 표시한다.

흔히 유지보수를 위해 내려가 있거나 overload된 서버에서 발생한다.
이 응답은 일시적인 상태를 위해 사용되야 한다.
그리고 가능하다면 Retry-After HTTP 헤더가 서비스 복구 예측 시간을 담아야 한다.

Note: 이 응답과 함께, 문제를 설명하는 유저 친화적인 페이지가 전송되어야 한다.
이 응답과 함께 전송된 Caching 관련된 헤더들은 주의해야 한다, 503 상태는 주로 일시적 상태이고 응답이 cache되지 않아야 하기 때문에.

### 의견:
서브젝트나 평가지에 유지보수나 overload 시에 추가 처리 기능을 명시하고 있지 않기 때문에
구현하지 않아도 될 것 같습니다.

# 504 Gateway Timeout
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/504

게이트웨이나 프록시로서, 제 때에 upstream 서버로부터 요청을 완료하기 위해 필요한 응답을 받지 못함을 표시한다.

### 의견:
502 (Bad Gateway)와 마찬가지로
서브젝트나 평가지에 게이트웨이나 프록시의 기능에 대한 명시가 없기 때문에
구현하지 않아도 될 것 같습니다.

# 505 HTTP Version Not Supported
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/505

서버가 요청에서 사용된 HTTP 버전을 지원하지 않음을 표시한다.

### [RFC7231.6.6.6.]

서버가 요청 메세지에서 사용된 HTTP의 major 버전을 지원하지 않거나, 지원하기를 거부함을 표시한다.
서버는 이 에러 메세지 외에 클라이언트와 같은 major 버전을 사용해서 요청을 완료할 수 없거나 완료하기를 원치 않음을 표시한다.
서버는 왜 그 버전이 지원되지 않는지와 서버가 어떤 다른 프로토콜들을 지원하는지를 묘사하는 505 응답을 위한 representation을 생성해야 한다.(SHOULD)

### 의견:
요청의 HTTP의 major 버전이 1이 아닐 경우 이 상태 코드를 갖는 응답을 전송하면 될 것 같습니다.
nginx에 HTTP 버전으로 HTTP/5.0 등을 주었을 때 505 응답을 하는 것을 확인했습니다.
만약 'HTTPP/1.1', 'HTTP//1.1' 등을 전송하면 400 (Bad Request) 응답을 받게 됩니다.

# 506 Variant Also Negotiates
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/506

Transparent Content Negotiation의 문맥에서 전달받을 수도 있다.

### 의견:
서브젝트나 평가지에서 content negotiation 기능을 명시하지 않기 때문에
구현하지 않아도 될 것 같습니다.

# 507 Insufficient Storage
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/507

Web Distributed Authoring and Versioning (WebDAV) 프로토콜의 문맥 중에 받을 수도 있다.

### 의견:
서브젝트나 평가지에서 WebDAV 기능을 명시하지 않기 때문에
구현하지 않아도 될 것 같습니다.

# 508 Loop Detected
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/508

Web Distributed Authoring and Versioning (WebDAV) 프로토콜의 문맥 중에 받을 수도 있다.

### 의견:
서브젝트나 평가지에서 WebDAV 기능을 명시하지 않기 때문에
구현하지 않아도 될 것 같습니다.

# 510 Not Extended
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/510

HTTP Extension Framework의 문맥 중에 전달받을 수 있다.

### 의견:
서브젝트나 평가지에서 HTTP Extension Framework 기능을 명시하지 않기 때문에
구현하지 않아도 될 것 같습니다.

# 511 Network Authentication Required
---
### https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/511

클라이언트가 네트워크에 접근하기 위해 authenticate할 필요가 있음을 표시한다.

이 상태는 origin 서버에 의해 생성되지 않는다.
네트워크에서 접근을 제어하는 프록시에 의해 생성된다.

### 의견:
이 상태 코드도 기본 서버가 아닌 프록시 서버에서 특정 상황에 응답할 때 사용하는 상태 코드인 것 같습니다.
서브젝트나 평가지에서 프록시 서버에 대해 명시하지 않기 때문에
구현하지 않아도 될 것 같습니다.

????-??-??
https://kb.iu.edu/d/afqs
> ARCHIVED: If my computer has an underscore ( _ ) in its name, why am I having trouble accessing network services?
host name is case-insensitive

2022-05-03
https://stackoverflow.com/questions/14700906/socket-programming-send-return-value
> Socket programming send() return value
저번 회의에서 send()의 반환값이 일반적으로는 인자로 전달한 buffer의 size 또는 -1이 반환되지만 fd가 non-blocking일 때는 또 다를지 모르겠다고 했었는데 이 사이트에 딱 알맞는 답변이 있습니다.
fd가 non-blocking일 때는 [0, buffer)를 반환할 수 있다고 합니다.
하지만 직접 테스트를 해 본 결과 이것은 틀린 얘기라는 것을 알게 되었습니다.

/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/event.h
> struct kevent filter type value
```
#define EVFILT_READ             (-1)
#define EVFILT_WRITE            (-2)
#define EVFILT_AIO              (-3)
#define EVFILT_VNODE            (-4)
#define EVFILT_PROC             (-5)
#define EVFILT_SIGNAL           (-6)
#define EVFILT_TIMER            (-7)
#define EVFILT_MACHPORT         (-8)
#define EVFILT_FS               (-9)
#define EVFILT_USER             (-10)
#define EVFILT_VM               (-12)
#define EVFILT_EXCEPT           (-15)
```
bit flag 모델이 아니기 때문에 '|'로 동시에 여러개의 filter를 set하여 설정하는 기법을 사용할 수 없다.

## https://m.blog.naver.com/migurazi/70048236691
> Socket send()함수의 Return값
send()는 remote로 데이터를 보내기까지를 담당하는 것이 아니라 단순히 socket의 write buffer에 

2022-05-02
kqueue의 udata를 사용하면 좋을 것 같다.
- map의 key를 탐색하는 시간을 절약할 수 있다.
```
// 타입 정의
class VirtualServer {
    // configuration file
    host;
    port number;
    name;
    default error page path;
    client body size limit;
    list of accepted HTTP methods for route;
    HTTP redirection;
    nginx location;
    directory listing toggle;
    default file to answer if the request is a directory;
    CGI based on certain file extension;

    // run time
    socket;
};

Class ClientClerk {
    server;

    request buffer;

    should write;
    response buffer;
};

typedef VSMap map<int, VirtualServer>;


// 글로벌 수준 영역
VSMap vs_map;

// virtual server sock 추가
while (config 파일의 모든 virtual server마다) {
    int server_sock = socket(PF_INET, SOCK_STREAM, 0);

    VirtualServer new_vs = VirtualServer(server_sock/*, config_data*/);

    vs_map[server_sock] = new_vs;
}

while {
    event_count = kevent(kqueue_fd, NULL, 0, event_array, DEFAULT_EVENT_ARRAY_SIZE, &timeout);

    for (int i = 0; i < event_count; ++i) {
        const struct kevent& event = event_array[i];
        VirtualServer& vs = event.udata;

        if (event.filter == EVFILT_READ) {
            if (static_cast<int>(event.ident) == server_sock)
                acceptServer(server_sock, kqueue_fd);
            else
                if (readClient(event.ident, msg_buf, BUF_SIZE) != 0)
                    runRequest(msg_buf, response_message_array[event.ident], response_message_should_write[event.ident]);
                else
                    deleteEventClient(event.ident, kqueue_fd);
        }
        else if (event.filter == EVFILT_WRITE)
            if (response_message_should_write[event.ident]) {
                const std::string response_message = response_message_array[event.ident];
                send(event.ident, response_message.c_str(), response_message.length(), 0);
                response_message_should_write[event.ident] = false;
            }
    }
}

```

```
VirtualServer vs;

EV_SET(&event, sock, filter, flags, 0, 0, vs);
kevent(kqueue_fd, &event, 1, NULL, 0, NULL);

while {
    event_count = kevent(kqueue_fd, NULL, 0, event_array, DEFAULT_EVENT_ARRAY_SIZE, &timeout);

    for (int i = 0; i < event_count; ++i) {
        const struct kevent& event = event_array[i];
        VirtualServer& vs = event.udata;

        if (event.filter == EVFILT_READ) {
            if (static_cast<int>(event.ident) == server_sock)
                acceptServer(server_sock, kqueue_fd);
            else
                if (readClient(event.ident, msg_buf, BUF_SIZE) != 0)
                    runRequest(msg_buf, response_message_array[event.ident], response_message_should_write[event.ident]);
                else
                    deleteEventClient(event.ident, kqueue_fd);
        }
        else if (event.filter == EVFILT_WRITE)
            if (response_message_should_write[event.ident]) {
                const std::string response_message = response_message_array[event.ident];
                send(event.ident, response_message.c_str(), response_message.length(), 0);
                response_message_should_write[event.ident] = false;
            }
    }
}

```
