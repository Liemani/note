pour.txt

2022-01-05
- PM: Project Manager: 프로그램 전반적으로 굴러가는데 차질이 없도록 관리하는 역할
- PD: Project Director: 프로그램의 핵심적인 부분이 잘 작성되도록 관리하는 역할
- Programming in C++
	- 29p
		- expression: 반환값이 존재
		- statement: 반환값이 없음(?)
			- expression 은 statement 에 포함된다
	- 34p
		- getopt() 라는 library function 도 있구나?!
- interface vs implementation
	- ISO 에서 열람할 수 있는 자료는 interface 에 해당한다
	- 실제 구현된 compiler 등은 implementation 에 해당한다
	- 따라서 우리는 범용적인 spec 을 확인하기 위해서 ISO 등의 spec 문서를 보아야 하고, spec 문서에서 명시하지 않는 실제 구체적인 동작을 확인하기 위해서는 implementation 을 보거나 test 를 하여 알아내야 한다
- https://www.youtube.com/watch?v=MOYymnAFhY0
	- 성공하는 사람들의 공통적인 특징 3가지 (천인우 전 페이스북 LV5개발자)
	- assume good intentions: 상대가 선한 의도를 가지고 말을 한다고 가정해라
	- psychological safty: 심리적 안정감
		- 리더로서 심리적 안정감이 있는 조직문화를 만드는 것이 중요하다
	- 성과를 잘 내는 것도 중요하지만 주변 사람들을 얼마나 잘 retain 하느냐
- https://www.youtube.com/watch?v=Geb5ScWrGhA
	- 페이스북 개발자 시간관리의 5가지 비밀 (천인우 2부 전 페이스북 LV5 개발자)



2022-01-04
- zero-overhead rule
	- What you don't use, you don't pay for. And further: What you do use, you couldn't hand code any better
	- runtime type identification 과 exception 만이 예외라고 한다
- https://www.stroustrup.com/ETAPS-corrected-draft.pdf
	- Foundations of C++
	- object: set of data member and method for a notion
	- data member: variable of object



2022-01-03
- ':set all': display all set
- 함수 이름을 여러개로 쓸 수 있도록 필요할 때마다 추가할 수 있도록 하면 결국 지저분해질 뿐이다, 따라서 문서 편집기에서 특정 이름들을 특정 상수로 바꾸도록 처리하여 서로 다른 이름을 쓰더라도 결국 같은 상수가 되도록 처리하는 것이 좋다. 일괄적으로 변수 이름을 바꾸는 기능을 상위단에서 제공하는 것이다
- 여러 이름들, 최선의 이름은 있겠지만 최고의 이름은 없다
	- 하지만 한 번 정해진 이름은 여기 저기서 쓰이게 되면 나중에 다른 이름으로 바꾸기가 쉽지 않은걸?
- 'cut -f 9-': 9 번째 word 부터 끝까지 출력
- 'c_<C-R>_<C-L>': insert the line under the cursor
- ':range': 명령을 할 대상의 범위를 명시하는 방법들
- :[range]m[ove] {address}			*:m* *:mo* *:move* *E134*
			Move the lines given by [range] to below the line
			given by {address}.
	- 이 때 address 에 마크를 넣어주면 지정된 위치로 텍스트를 보낼 수 있어서 편리하다
		- ex> '<,'>m 'f
- ':*'
								*cpo-star*
		*	Use ":*" in the same way as ":@".  When not included,
			":*" is an alias for ":'<,'>", select the Visual area.



2022-01-02

- 'git status' 는 한글을 제대로 출력하지 못하므로 가능하면 파일명에 영어 이외의 문자는 사용하지 말도록 하자



2022-01-01

- vim: 가끔 한글이 마지막에 위치했을 때 보이지 않는 문제.
	- 아마 여러 공간을 차지하는 문자가 마지막에 왔을 때, 표기를 다음 줄로 넘기기 위해 공백을 의미하는 '>' 를 쓰고 다음 줄에 출력하는데 이로 인한 버그로 이전 줄로 되돌아갈 때 표시하지 않게 되는 것이 아닐까?
	- 마지막 2 칸에 한글 한 문자가 위치할 때 이전 한글 문자를 'r' 을 사용하여 다른 한글 문자로 수정하면 마지막 2 칸에 있던 한글 한 문자가 안보이게 되는 문제를 확인했다.
- '<S-R>' in netrw: rename file
- '<S-D>' in netrw: delete file
- 아침에 작업을 시작하기 전에 backup 을 한 번씩 해주는 것은 어떨까?



2021-12-31

- https://www.sciencedirect.com/topics/engineering/memory-address-register
	- pc: program counter



2021-12-30

# 시작 문서
getting started: 아주 기초적인 사용법부터~
	- 주로 실행 가능한 프로그램 등의 사용법을 소개하는 용도
tutorial: 간단한 모든 자료
tour: 다른 것과 비교되는 특징적 자료
reference: 모든 자료
예시
	- tutorial
		- https://lldb.llvm.org/use/tutorial.html
			- LLDB Tutorial
	- tour
		- https://docs.swift.org/swift-book/GuidedTour/GuidedTour.html
			- A Swift Tour



2021-12-27

- project base learning 의 개념을 가져와서 sprint base working 은 어떨까?
	- 작업을 진행할 때 한 번에 큰 일을 처리하는 것이 아니라 sprint 로 구분하여 작업을 처리하는 것이지
		- 게다가 에자일 이념을 붙여서 계획-수행-회고 과정을 수행하는 것도 좋을 것 같다.
- vim/help/usr_12.txt
	- ':%s/four/4/g': The "%" range means to replace in all lines.  The "g" flag at the end causes all words in a line to be replaced.
	- ':%s/\([^,]*\), \(.*\)/\2 \1/': "Last, First" -> "First Last"
		- '\2' and '\1' is called backreferences
			- They refer to the text matched by the "\( \)" parts in the pattern.
	- 'g<C-G>' in normal mode: count things of file in various aspects
	- 'g<C-G>' in visual mode: count things of selected range in various aspects
- git status 시 한글 파일의 이름이 아래와 같이 깨져서 나오는데 git status 는 한글 출력을 못하던가?
```
Untracked files:
  (use "git add <file>..." to include in what will be committed)
	"contents/list: \352\260\200\353\263\264\352\263\240 \354\213\266\354\235\200 \352\263\263.txt"
```



2021-12-25

- 아이폰에 한 손 키보드 모드가 있는지 몰랐다. 이게 그로스 해킹인가 뭔가 하는 녀석인가? 하지만 치명적인 문제가 있으니.. 아무리 한 손 키보드 모드라고 해도 결국 한 손으로 모든 조작을 처리하는 것은 불가능에 가까우며, 키보드가 더 작아져서 오타도 많아진다. 개인적으로 오타가 나지 않으려면 가로모드는 필수라고 생각한다. 키보드여서야 세로 모드의 빽빽한 키보드에서는 오타가 날 수밖에 없다. 다만, 한 손 키보드 모드가 두 손 사용을 전제로, 한 손만으로 타이핑을 하는 것을 목표로 만들어졌을 수 있다. 이 경우 그래도 약간은 의미가 있다고 생각한다.
- 밸런스가 중요하다. 트레이드 오프에서는 무게에 따라 명칭을 달리하면 좋다. 가령 캐쉬-메모리 처럼, 개인화 정도에 따른 명칭이 있다면 좋을 것. 영화 inside 정도의 피망 개인화를 나타내는 단어가 있다면 좋을 것이다. 그리고 그모다 더 시간을 들인 최적화도 있을 것이다. 동시에 이보다 적은 시간으로 개인화하는 '더빙' 등을 의미하는 단어도 붙여줄 수 있겠다.
- 일단 떠오른 단어를 먼저 적도록 하자. 서술하여 기록하다가는 10 중에 일부가 사라진다. 하지만 단어도 세세가 사라짐 가능, 동시 세세 선도 사라짐 추적 가능. 하지만 큰 틀을 잡는 것이 더 좋아보임. 마치 계획을 세우고 실천하는 느낌.
- 오늘 서울에서 본가로 내려가고 있다.
	- 8시 30분 버스를 타려고 했는데 몇 분 차이로 놓치고 말았다.
	- 그래서 9시 기차를 타기로 경로를 수정했다.
	- 일단 기차를 오랜만에 타서 좋은 경험이긴 하다. 버스보다 흔들림이 적어서 굳이 모바일을 사용할 필요도 없이 컴퓨터를 꺼내서 이 글을 작성할 수 있는 것이 좋았다. 그리고 자리가 넉넉하게 넓어서 비좁게 타는 버스보다 좋았다. 하지만 2시간 정도 걸리는 버스에 비해 싸고 느린 기차를 골랐기 때문에 3시간이나 걸리는 것은 단점이었다.
	- 그리고 난 용산역에서 기차를 탔는데 다음에 또 이런 일이 있다면 영등포역에서 타는 것을 고려해보고 싶다.



2021-12-23

- 다른 것을 하고 싶은 마음이 생길 때 나를 올바른 길로 이끌 것이 필요하다.
	- 이런 목적을 가진 무언가를 준비하도록 하자.
- [초청특강] 알아두면 쓸데없는 신비한 개발잡담 BY LG유플러스 신정호 CTO
	- 예측: 난이도/양/기간
	- 도메인 지식이 중요하다
	- 왜 이렇게 작성했어?
		- 예외 상황을 우회하기 위한 최선의 노력이다.
			- 이를 제대로 파악하지 못하면 요구 사항에 맞지 않는 작동을 하는 프로그램을 만들게 될 수도 있다.
	- 고객이 항상 맞지는 않다. 고객이 표현하지 못하지만 내면에 원하는 것을 파악하는 것은 엄청난 능력이다.
	- 현상
		- 빠르게 해결이 가능하다
		- 사이드 이팩트가 날 확률이 크다
	- 원인
		- 빠른 해결이 불가능하다
		- 사이드 이팩트가 덜하다
- case by case 인가?
	- 참이라면 데이터를 수집하여 어떤 case 에 어떤 것을 적용하는 것이 좋을지 파악한다.
- ':sort' in vim normal mode: sort lines
- ':g/<pattern>/y A' in vim normal mode: append all lines matching to register a



2021-12-20

- 동영상을 압축해서 단말기로 전송하는 것처럼, 만약 게임의 데이터가 크다면 압축해서 전송할 수 있을 것이다.
	- link: https://www.youtube.com/watch?v=itdPTcBHRbM
- 뭔가 정리를 할 때 정리할 대상의 규모가 예측 불가능해서 의지를 뺏기는 효과가 있다. 만약 정리할 대상의 규모가 예측 가능하다면 정리를 하면서도, '이 정도 시간이 걸리겠구나' 라는 생각을 가지고 각오를 다지고 진행할 것이다. 따라서 정말 끝까지 정리를 완료하고 싶다면 우선 무엇을 정리할 것인지를 정리하는 것이 필요해 보인다.
- 일을 처리하는 과정
	- 일의 규모를 예측한다.
	- 각오를 다지고 일을 진행한다.
- 환경만을 의지해서는 안된다. 자기 통제도 동시에 필요하다. 자기 통제란 스스로 약속하고 못지켜서 비참해지는 것이 아니라. 긴 시간의 사고 후 어떤 약속을 만들었으면 다음부터는 긴 시간을 들이는 사고 없이 그 약속을 지키는 것이다.



2021-12-19

- '날씨의 아이(2019)'를 보았다.
	- '너의 이름은(2016)'을 만든 신카이 마코토 감독의 만든 작품이라고 한다. 사실 '너의 이름은'을 봤을 당시 너무 별로여서 큰 기대를 하지는 않았는데, 바로 다음 작품인 '날씨의 아이'를 보고 작품의 전체적인 밀도가 굉장히 빽빽해진 것을 보고 대단하다고 생각했다. 다음 작품도 정말 기대가 된다.
	- 나는 최근에 어떻게 해야 다시 열심히 할까를 생각하고 있었는데, 이 작품을 보면서, 이런 작품이 나오기까지 정말 오랜 시간이 걸릴텐데, 어떤 과정으로 작품이 탄생했을까를 살짝 생각해 보았다. 그러다가 역시 뜬구름 잡는 이론을 주구장창 공부하는 것은 혼자 하기 힘들고, 뭔가 결과물이 있고 재밌는 프로젝트 베이스로 배우는 것이 좋겠다는 생각을 다시 해보았다. '날씨의 아이' 가 탄생하기까지 거쳐온 이전 작품들이 존재하기 때문에, 나도 뭔가 하려고 한다면 그런 식으로 실질적인 프로젝트 기반 학습을 하는 것이 좋을 것이라고 생각했다.



2021-12-17

- safari 에서 tab group 을 변경하면 이전 탭 그룹에 있던 tab 들의 memory 들은 활성 상태 보기 창에서 cache 로 상태가 변한다.
- AppleScript 를 사용하면 System Preferences 의 설정을 매크로처럼 바꿀 수 있는 것 같았지만 cluster mac 의 administrator 권한이 없이는 제대로 사용할 수 없다



2021-12-16

- 도어락
	- 마스터 비밀번호 여부
	- 교통카드로 열 수 있는 도어락도 존재한다
		- 그런 경우 card 표시가 도어락에 존재하는 경우가 있다
		- 하지만 7분만에 복제가 가능해서 보안이 좋지 않은 경우 사용하면 위험할 수 있다.
	- 도어락에 지문 보안을 강화하기 위해 단순히 매번 화면이 켜질때마다 숫자가 한 칸씩 밀리도록 만들면 되지 않을까?
		- 그러면 각 숫자 위치의 디스플레이가 모든 숫자를 표시할 수 있게 되어야 하기 때문에 구조가 복잡해지고 비용이 늘어나는 문제가 있다.
		- 때문에 비밀 번호 전 후에 의미 없는 숫자를 누르도록 유도하는 허수 기능이 큰 변화 없이 문제를 해결하는 좋은 방법이라고 생각한다.
			- 단, 이 허수 기능으로 인해 비밀번호와 일치하는 패턴이 더 많아지는 것은 아닌가?



2021-12-15

- http://beemarketer.co.kr/youtube/timetag/
	- 유튜브 링크에 시간 추가하는 방법
- https://www.youtube.com/watch?v=1bcmmc2rTBE#t=9m26s
	- 증명할 수 없는 것은 크게 자료로서 가치가 없다
		- 증명을 위해 구체적인 루틴 등을 제시하는 것이 좋다
	- 결국 시스템을 만든 사람이 목표를 달성한다
		- 열정: 나는 한 달 동안 10kg을 뺄 거야
		- 시스템: 나는 매일 1만 보를 걸을 거야
	- 단순히 목표만을 제시하거나 추상적인 단어를 쓰기 보다는 시스템을 만들고 제시해라
		- 시스템의 예: 루틴, 규칙
- https://www.youtube.com/watch?v=7zI4qyLBEOM
	- 2021 데이터 그랜드컨퍼런스 Track3 데이터와 기술
		- 그로스해킹, 초 개인화, 개인정보보호의 상위일체 '고영혁'
		- 점점 동의하지 않으면 데이터를 수집하지도 못하는 식으로 변화하고 있다
			- ex> apple
		- 서비스가 진짜 올바른지를 데이터를 통해 객관적으로 확인
		- 사회가 파편화됨에 따라 최대한 잘게 쪼개서 봐야한다
	- 판매업의 고객 파악, 조선사의 조선 중 배를 특정 위치로 이동, 축산업에서 데이터 수집, 개인 데이터 수집을 통한 맞춤형 서비스, ai를 활용한 고객 응대, 건설 시 설계, 자제 관리, 시공 시뮬레이션, 유지관리 데이터 관리
- xcrun xctrace record --output philo.trace --template 'Time Profiler' --launch -- philo 200 210 100 100 5
	- cli 에서 특정 command 를 실행하고 실행 중의 다양한 수치를 기록한다. 이후 생성된 philo.trace 파일은 apple 의 instruments app 에서 열 수 있다.
	- 뭔가 함수 내부 코드 중에 어디에서 자원을 많이 사용하는지를 대략 보여주는 것 같지만 측정 프로그램과 분리된 독립된 프로세스가 일정 주기마다 측정하는 것이다 보니 아주 정밀하지는 않은 것 같다. 그래서 거대한 프로그램에서 대략적인 성능을 측정할 때는 좋겠지만 작은 프로그램의 성능을 측정하기에는 조금 아쉬운 부분이 있는 것 같다. 그 외에 어셈블리 코드를 보여주는 것은 objdump 와 같이 disassemble 해서 출력한다.
- command + shift + .: finder 에서 숨김 파일 보기
- 'file://<path>' on safari address line: open a file on safari
- https://en.wikipedia.org/wiki/Timeline_of_programming_languages
	- 프로그래밍 언어 타임라인
	- 1943-1946년에 한참 ANIAC 을 위한 프로그래밍 언어를 만들다가 1972 년에는 C언어, 1977년에는 APPLE2 가 출시되면서 APPLE2 를 위한 BASIC 언어가 생기기까지 했다. 그 사이에도 다양한 언어가 치열하게 생겨났다. 1980년에는 c++ 가 만들어졌다.



2021-12-13

- thread list
- thread backtrace all
- thread select 2



2021-12-12

- 두 쓰레드에서 동시에 printf 를 찍고 mutex 를 걸지 않는다면 아래와 같이 출력이 섞일 가능성이 있다.
```
// 섞임
expect sleep: [0 199990]                   1024          86 has taken a fork
, real sleep: [0 200345]
```
```
// 기대한 출력
expect sleep: [0 199990], real sleep: [0 200345]
                   1024          86 has taken a fork
```
- philosopher 과제를 진행하다보니 걱정했던 것보다 sleep 을 많이 걸어주니 실제 돌아가는 thread  가 적어져서 usleep() 의 오차가 심하지 않았다.(200ms 을 주면 205ms 슬립 정도, 걱정은 1ms 만 줘도 160ms 정도 긴 잠을 자는 경우가 있지 않을까 생각했었음, 이 심각한 경우는 실제로 200 개의 쓰레드에 spin lock 을 걸면 관찰 가능)
- 새로운 형태의 인재를 만드는 교육과정을 존중하기 때문에 공개적으로 silent 클러스터를 두는 것은 좋지 않은 것 같다. 역시 조용히 숨겨진 그룹을 구성해보도록 하자



2021-12-11

- playground repo 에서 새로운 branch 를 만들고 변화 과정을 commit 으로 기록하였지만, 그것이 전체적인 git 의 data 크기를 줄이지는 못한다는 것을 안다. git 은 변화를 기록하는 것이 아니라 프로그램 자체를 기록해버리기 때문이다. 그러니 굳이 보기 힘들게 commit 형식으로 내용을 기록하지 말고 하나의 directory 를 만들어서 그 안에 변화 과정이 담긴 각 내용들을 추가적인 directory 안에 담아서 commit 하도록 하자
- 서브젝트에 있는 문장들을 아리송한 채로 놔두지 말고, 나의 언어로 정리하여 목적인 완성된 프로그램을 위한 구체적인 목표로 명시해두는 것이 좋다. 그렇지 않으면 구현할 때마다 아리송했던 정리되지 않은 명세 내역을 반복하여 확인하면서 매 상황에 따라 명세 내역을 새로 해석해야 할 것이다.
	- 하지만 처음부터 명세 내역을 명확하게 이해하기는 쉽지 않다. 구현을 진행하면서 생각지 못했던 부분이 존재하여 기존에 정의한 명세 내역이 적절하지 않다는 것을 알게 될 수도 있다. 따라서 가장 좋은 것은 명세 내역을 제시하는 사람과 의견 교환을 하여 뚜렷하게 하고, 구현 진행 중에 의문이 생길 때마다 명세 내역 제시자와 반복적으로 의견을 주고 받으면서 서로에게 바람직한 제품을 만드는 것일 것이다. 단, 질문을 할 때는 기본 원칙인, 상대방에 대한 존중을 지켜야 한다.
	- 마치 조각을 할 때 처음에 딱 불필요해 보이는 커다란 덩이들을 rough 하게 쳐낸다고 생각하면 된다. 그리고 그 계획에 따라 진행해나가다가 고려하지 못한 불명확한 부분이 있다면 명세의 내용을 세심하게 생각해보는 것이다.
- philosophers 의 philosophers_loop 에 state machine 을 적용하기에는 status 를 저장하는 변수도 기존에 따로 없고, 상태가 복잡한 것이 아니라 무조건 차례대로 바뀌기 때문에 적절하지 않다고 생각한다. 그냥 평범하게 작업을 순서대로 나열하는 것이 바람직해 보인다.
- race condition 이 발생하지 않도록 mutex 를 기술적으로 처리하는 코드가 삽입되면서 실제 원하는 작업이 가려져 가독성이 떨어지는 것 같다.



2021-12-10

- git stash pop == git stash apply && git stash drop
	- 만약 git stash apply 에서 conflict 가 발생하면 git stash drop 이 실행되지 않는다.
	- 출처: https://www.theserverside.com/video/How-to-easily-merge-and-resolve-git-stash-pop-conflicts
	- conflict 를 해결하고 git stash drop 을 하더라도 git stash 를 하려고 하면 '<path>: needs merge' 라는 문구가 출력되면서 실행되지 않는다.
		- 이 때 간단히 해당 파일을 git add 하고 다시 git stash 를 실행하면 제대로 수행된다.
- https://en.wikipedia.org/wiki/Lock_(computer_science)
	- coarse granularity: 굵직하게 mutex lock 을 거는 것, thread 가 적을수록 효율이 좋다. 당연히 mutex 가 겹칠 일이 적으니 lock overhead 를 줄이면 효율이 좋아진다.
	- fine granularity: 세세하게 mutex lock 을 거는 것, thread 가 많기 때문에 lock contention 을 줄여야 효율이 좋아진다.



2021-12-09

- 함수의 내부에서 사용하는 단어와 외부로 표출되는 단어가 다르다. 내부적으로 사용할 때는 굳이 해당 함수가 포함되는 구조체의 이름을 접두어로 붙일 필요도 없다.
- 행복한 완벽주의자가 되어라. 완벽주의 덕에 어떤 문제를 풀 때 여러 번 곱씹게 되지만, 스스로 원해서 그 문제를 완벽하게 푸는 것이기 때문에, 한 문제를 해결하는 과정에서 발생하는 수많은 의문과 작은 문제들을 추가적으로 맞닥뜨릴 때마다 새로운 특징과 기술을 학습하며, 이에 즐거움을 얻는다.

야곰맨토님 특강
	- 공유하라
		- 공유해서 그 내용이 다른 사람들에게 알려진다고 해도, 직접 내용을 작성한 사람과, 단순히 다른 사람이 작성한 내용을 보고 터득한 사람 간에는 깊이의 차이가 있다.
		- 공유를 할수록 내 특수성을 잃는 것이 아니고 기회가 많아지는 것이다.
	- 발표를 해보는 것은 공유하는 방법 중 훌륭한 방법이다.
	- 애매한 부분에서는 질문을 꼭 해야한다.
		- 의미 없는 삽질을 줄일 수 있다.
		- 사고치는 것 보다 질문을 하는 게 더 좋다.
		- 질문을 하지 않는 것 보다는 물음표 살인마가 되는 것이 좋다.
	- 작업의 목적이나 이유에 대해 이미 공유가 되어 있다고 착각을 하고 작업을 줄 수 있다. 왜 그 작업을 해야하는지 왜라는 질문을 통해 목적, 역사 등을 파악할 수 있다. 나아가 개선도 가능해진다!
	- 단순히 어떤 라이브러리를 조사해오라고만 해도 왜 조사해오라고하지? 라는 생각으로 질문한다면 조사 작업을 더 적합하게 진행할 수 있을 것이다!
	- 단
		- 같은 질문은 다시 하지 않는다.
		- 질문에 대한 배경 설명을 장황하지 않은 선에서 설명을 해야 한다.
			- 질문만 띡 던지지 말것!!
		- 쇠사슬은 이래서 좋고, 밧줄은 저래서 좋다고 하는데 어떻게 할까요?
			- 이 경우는 "아 이 친구가 내 의견도 존중해주는구나!" 라고 생각
			- 만약 그냥 쇠사슬이 좋다고 해서 쇠사슬로 만들었어요! 라고 한다면
				- 아니 누가 쇠사슬로 해도 된다고 허락했어?
	- 질문의 핵심은 존중과 배려이다
		- 내가 어떤 질문을 해야 상대가 더 명확한 대답을 해줄 수 있을까?

급변하는 세상에서 커리어란 <한기용>
- 급변하는 세상에서 전문성이란?
- 내가 가진 장점이 언젠가 단점이 되는 순간이 있다.
- 완벽주의자 -> 일의 경중을 따지지 않고 전부 열심히함 -> 오히려 단점
	- 중요하지 않은 것인데 필이 꽂히면 파고 든다.
	- 한 가지 해결 방법: 익숙한 것에서 벗어나보기
- 어떤 기술을 아느냐에 중요하지 않고, 결과를 내는 데 포커스를 하라
- 도메인에 따라 몸값이 달라진다
	- 물리학자 -> 데이터 과학자로 커리어 전환 (먹고 살기 위해서)
- 현재 일을 잘 하려고 하다보면 자신감이 생기게 된다.
- 요즘 세상의 전문성은 변화를 두려워하지 않는 것이다?
	- 자기 검열 안하기
		- non-동아시아권 -> 내가 승진하고 싶은데 내가 부족한게 뭐냐?
		- 동아시아권 -> 내가 열심히 해서 승진이 되길 바람
- 이력서 많이 넣기
	- 연락 오면 인터뷰 무조건 보기
		- 면접 보고 부족한거 보충해나가기
	- 가장 가고 싶은 곳은 마지막으로! (경험치 쌓고 도전)
	- 빨리 시작해서 발전해나가면 된다
	- 내 매니저가 누군지가 가장 중요하다!
		- nice 보다
		- 명확한가 피드백을 주는가, 윤리적인, 회사내 힘이 있는 사람
			- 나중에 그 사람이 가는 회사를 따라가면 된다.
	- 면접관들이 물어보는 거에만 답하지 말고 나도 많이 물어봐야한다 취직 후 3 달 간 무엇을 하는지?, 이 회사에서는 일을 잘하는 사람들의 특징이 무엇인가?
	- 면접관들의 질문을 통해, "아 내가 이런 쪽은 아예 모르는구나" 라는 것을 알수 있다
- 회사가 성장하면 내가 성장할 확률이 높다.
	- 회사가 성장하면 일하는 모두가 기분이 좋다.
	- 회사의 문화는 어떠한가?
- one way door vs two way door
	- two way door 라고 생각이 되면 일단 저지르고 본다
- scalar 가 중요한게 아니라 vector 가 중요하다
	- value 보다는 delta
- 매니저 입장에서 주니어의 무엇을 보는가? 가능성, 영향력, 긍정적
	- 얼마나 절실하고 얼마나 체계적으로 접근하는가?
- 시작할 때의 마음가짐
	- 처음 90 일이 가장 중요하다(첫인상)
		- 뭔가 하나라도 이뤄내기
		- 과거 상처어 얽매이지 말기
		- 일을 너무 열심히 할 필요는 없다
	-  새로운 기술의 습득이 아닌 결과를 내는데 초점 맞추기
- 공부를 위한 공부를 하기 보다는 일을 시작해보기
	- 남과 비교하지 말기
		- 어제의 나와 오늘의 나를 비교하라!
	- support network 가 있으면 좋다
		- 무조건적인 지지를 해주는
		- 딴지를 거는 것이 아니라, 만나고 나면 기분이 좋지 않는 경우, 사람들이 나를 서포트 해주지 않고 비판을 할 때
- 나의 장점이라고 생각했던 면이 나의 컴폴트 존이었고, 그로 인해 새로운 시도를 하지 못해 성장을 저해할 수 있다

설명
~해(주장) -> 되면 이렇게 안되면 이렇게(근거)

카카오 애자일
티켓에는 완성된 라면 한 그릇
이건 분업화 할 필요가 없다!
레스토랑에서 주문을 받을 때도 티켓에 하나의 음식 메뉴가 들어와도 여러 요리사가 완성된 하나의 음식을 만들어 낼 수 있다
만들려고 하는 대상에 대한 목표가 공유되어 있고 그것을 어떻게 구현해야 할까? 를 같이 고민하고 일을 나눠야만 한다! 그렇지 않으면 단순히 일 나누기가 되고, 각 나눠진 일 간에 디펜던시가 없을 수 없기 때문에 문제가 발생한다
숲을 구현할 때 숲에서 나뭇잎까지 구성원 모두가 파악할 수 있어야 한다.
충돌을 처음에 회피한다고 해도 나중 가서는 터지기 마련이다
한 프로젝트가 끝날 때 성공 또는 실패에 대한 이유를 객관적으로 생각해봐야 한다.
회고를 하기 위해서는 계획이 있어야 한다.
그렇지 않으면 단순한 감상적인 느낌만 나눌 수 있다.
궁극적인 목표를 위해 달리는 것보다 그 과정에 행위를 하면서 거기에 만족을 해버리는 것은 좋지 않다.
나뭇잎 하나하나 보면서 거기에 매몰되지 말고 숲을 향해 전진해야한다
일은 하고 있는데 전체적인 일이 어떻게 진행되고 있는지 모른다면 문제가 생길 것이다.
결과물, 미치는 영향, 리팩토링도 달라지게 된다.
축구 팀과 같다, 혼자 잘하는 것이 아니라 전략을 선수들이 모두 이해해야 한다.
넛지도 잘 하도록 하자. 일일이 참견하는 것이 아니라, 상대가 자신의 문제를 이해할 수 있도록 하는 질문을 잘 던져주는 것이 중요하다
매일 진행과정을 한 번씩 얘기를 나누는 것이 좋다 -> 데일리 미팅
아이데이션하는 프로젝트는 에자일을 적용할 필요가 없다.
축구 선수로서 기초 역량을 먼저 키우는 데에 집중하라
나는 이걸 이렇게 했는데 너한테도 이거 이렇게 좋다? 어때 좋아?
CI/CD 버튼 한번 누르면 사내 앱스토어에 배포되고 이렇게 테스트 할 수 있어~
새로운 급박한 일이 들어온다고 해도, 당장 하고 있던 일은 마무리 하고 넘어가야 한다.
중간 산출물들이 무엇이 될지, 언제까지 만들까? 이런 중간 산출물들을 만들려면 무엇이 필요해?
이걸 문서화해 놓고 모두가 볼 수 있는 곳에 놔야 한다.
코드의 문제는 얘기를 나누되, 너 왜 이렇게 짰어? 가 되면 싸우자는 것이 된다.
계획할 것 계획하고 회고하는 것이 가장 중요하다.
스프린트를 달리면서 힘조절을 계속 잘 조절해서 하라.
기본기가 충실해야 한다. 나의 무기 하나는 있으면 좋다. 왜 라는 질문을 던져라, 더 낫은 방법은 언제나 존재한다는 사실을 기억하자.



2021-12-08

- 소리의 착시를 이용해서 oni 에서 무한히 올라가는 음을 표현했다면, 색의 착시를 이용해서 무한히 어두워지는 색이나 무한히 밝아지는 색을 표현할 수 있을 것 같다
- <S-I> or <S_A> in visual block mode: insert text at the beginning of visual block of each line
- :'< or :'> in visual mode: the number of star or end line of block range
- :norm <commands>: Execute normal mode commands. <commands> are execute like they are typed.
- :let @a="" | g/<pattern>/y A: yank all line including <pattern>
- 이런 애니메이션 효과가 있으면 좋겠다. 전체 지도를 보다가 특정 지역을 자세히 보고 싶을 때가 있다. 이 때 화면 자체를 새로 만드는 것이 아니라 전체 지도에서 해당 지역이 줌 인 되는데, 이 때 피로도를 줄이기 위해 0.1s 정도 동안 전체 alpha 를  0.2 정도로 fade out 하고 0.1s 정도 동안 zoom in 하고 다시 0.1s 정도 동안 fade in 하는 것이다. 전체 지도로 돌아가는 것은 이 역순으로. 이 때 zoom 은 bazier 함수를 적용하여 둥글둥글한 s 곡선 느낌으로 처리한다. fade 는 선형으로
- 에측 가능성은 중요하다. 코드의 한 줄을 80 자로 제한해 한 줄 한 줄을 구분 가능하게 만들어 예측 가능하게 하고, 함수들의 크기를 25 줄 정도로 비슷하게 유지해서 한 함수를 예측 가능하게 하고, 한 파일에 함수를 5 개로 제한하 한 파일의 크기를 예측 가능하게 하는 것이 좋다. 한 디렉토리도 파일 갯수를 제한해서 예측 가능하게 하는 것이 좋을 수 있다. identifier 들에 특별한 규칙을 지니게 해서 어떤 곳에서 어떤 의미로 사용되는지 예측 가능하게 하고, 또 함수의 의치, 변수의 위치, 상수의 위치를 구체적으로 제한해 예측 가능하게 하는 것이 좋다. 어떤 특정 값을 찾으려면 어떤 파일의 어디를 가면 되겠구나가 보일 것이고, 어떤 위치의 어떤 상수를 보았을 때 어떤 역할에 사용되겠구나가 보일 것이다.
- define 이든지 enum 안에 정의된 constant 든지, constant 를 정의하기 전에 사용하면 compile step 에서 undeclared identifier error 가 발생하면서 진행되지 않는다.
- .w! >> <path>: write current line to the end of <path> file
- |usr_27.txt|
- /<pattern>/[be]+<number>: search <pattern> and jump to next <number> character from [end or begin] of a matching
- /\(ab\)*: search "", ab, abab, ababab...
- /a\+: If you want to avoid searching empty string, use '+' rather than '*'.
- /a\=: search 'a' as optional, so "" and "a"
- /a\{3,5}: Search only specific(3 <= x <= 5) number of repeat pattern
- /a\{3}
- 코드를 수정하는 것과 코드를 작성하는 일은 하는 것이 다른다.
- 코드를 작성하는 일은 함수의 작동 방식을 정의하고, 필요한 모듈 목록을 만들고, 함수 및 모듈을 작성하는 것이다.
- 코드를 수정하는 것은 이미 이 모든 것이 이루어져 있기 때문에 함수의 작동 방식 및 모듈들이 이미 문서로 존재할 것이고, 문서를 읽으면서 해당 함수가 문서에 따라 잘 작동하도록 버그 등을 수정해주면 되는 것이다.
- 즉, 일반적으로는 함수를 새로 작성하는 것 보다 이미 작성된 함수를 수정하는 일이 더 쉽다.
- 연산 결과가 포인터를 의미해야 할 때는 포인터를 operand 로 하는 포인터 연산을 하고, 결과가 배열의 index 번째 element 를 의미해야 하는 경우에는 [] 를 사용한 subscript 연산을 사용하도록 하자



2021-12-07

- _init() 을 실행하고 나면 해당 오브젝트를 바로 사용 가능하도록, 모든 property 에 적절한 값을 넣어 주도록 하자.
- sleep() 과 마찬가지로 mutex_lock() 도 때가 됐다고 바로 block 이 풀리는 것이 아니라 그 짧은 순간에 다른 thread 가 먼저 lock 을 걸어버리면 기존에 기다리던 thread 가 작동하기 전에 치고 들어온 thread 가 성공적으로 lock 을 걸면서 실행된다.
- 정리좀 하고 살자,, 메모랑 여기 pour 에 아마 엄청 다양한 생각들이 담겨 있을 텐데, 이거 나중에 어디에 나가서 발표라도 하려고 하면, 정리를 하지 못해 평소 하고 있던 생각을 제대로 발표할 수 없을 것이다.
- pthread_mutex 가 FIFO 가 아닌 것은 알았다. 그럼 다음으로 드는 생각이, FIFO 가 아니어도 그게 발생할 일이 thread 200 이하에서는 발생하지 않기 때문에 그냥 지나칠 것인지, 아니면 그럼에도 불구하고 정말 절묘한 타이밍에 FIFO 가 아니어서 발생하는 문제가 존재할 수 있기 때문에, 순서대로 write 하는 추가적인 처리를 하는 것이 맞을지 궁금할 수 있다.
	- 이 경우 나라면 먼저 FIFO 가 아니어서 발생할 수 있는 문제를 떠안고 프로그램을 작성하는 것이 무척 불편한 상황이기 때문에, 이를 어떻게 해결할 수 있을까 스스로 생각해본다. 지금 내가 할 수 있는 것으로부터 이 문제를 해결할 수 있는가를 생각해본다. 그리고 불가능하다면 무엇이 더 있어야 이 문제를 해결할 수 있을지 찾아본다. 그리고 해결책이 없다면 슬랙에 질문을 올려볼 것이다. 그렇게 해서 그나마 문제를 해결할 수 있는 방법을 발견했을 때, 만약 그 해결방법이 여러 이유로 마음에 들지 않거나, 적용에 투자하는 시간에 비해 얻는 것이 적다고 판단되면 과감히 버린다. 하지만 꼭 필요하거나, 불가능을 가능으로 만들어주는 부류의 내용이라면 가능하면 해보고 지나간다.
		- 이런 내용을 누군가에게 전달하는 것은 어떤 문제를 맞닥뜨렸을 때 그 문제를 해결하는 포괄적인 관점을 제공할 수 있다. 즉 물고기를 주는 것이 아니라 물고기 잡는 법을 알려주는 셈이다. 하지만 내가 얻은 것은 물고기 뿐만 아니라 물고기 잡는 법 뿐만 아니라 물고기 잡는 방법을 만들거나 알아내는 방법을 얻은 것이다. 즉, 직접 부딪혀서 문제를 해결법(물고기)을 찾아내는 방식(잡는 법) 을 스스로만의 방법으로 개척해나가는 것(물고기 잡는 방법을 만들거나 알아내는 방법) 은 물고기 잡는 방법을 알려주는 것만으로는 전달될 수 없다.
		- 다만 물고기 잡는 방법을 알려주면 다른 물고기 잡는 방법을 알아내기 위해 더 노력할 수도 있다. 혹은 반대로 앞으로도 물고기 잡는 방법을 직접 터득해나가지 않고 누군가에게 물어보는 수준에 머무르게 될 지도 모른다. 그것은 그 삶이 살아온 과거 성향을 통해 판가름날 것이다.



2021-12-06

- :ter[minal]: open terminal in vim
- ^: jump to the first not white space character of the line
- g_: jump to the last not white space character of the line
- <C-T> in insert mode: indent
- <C-D> in insert mode: unindent
- <C-N>, <C-P> in insert mode: 다음, 이전 단어 자동 완성
- gJ: 추가 공백 없이 행 연결
- o in visual mode: jump another end of the selected range
- O in visual block mode: jump another end of selected block
- u, U in visual mode: to lower case or upper case
- `., '.: jump to last edit
- ==: auto align
- cn, cp: vimgrep 으로 search 한 목록의 다음, 이전 item 으로 jump
- cope[n], ccl[ose]: search 한 item 목록을 list 하는 분할 창 띄우기, 닫기
- <C-W>x: 두 창의 위치 swap



2021-12-05

- 기본적으로 overflow 는 instruction 을 오용하는 방법이다. 그런데 unsigned int 의 경우 6.2.6.1:3 에 의해 overflow 이후의 값이 보장되고 signed int 는 undefined 로 정의된다
	- 6.2.5:9 도 참고
- thread 가 호출한 함수의 local variable 을 사용하여 값을 변경할 때, thread 보다 호출한 함수가 먼저 종료된다면, 이후 stack 에 다른 함수가 이 공간을 사용할 수 있기 때문에 thread 가 인자로 받은 변수의 값을 바꾸게 되면 엉뚱한 중요한 값이 바뀔 수 있다. -> segmentation fault 등 다양한 종류의 에러를 만날 수 있다.
- sleep() 의 특징
	- thread 의 수가 많아지면 초반에 thread 를 생성하느라 자원을 많이 소모하는데, 이 때 실행한 sleep 은 말도 안되는 수준으로 오래 걸릴 수 있다.
		- 1000us 를 sleep 했는데 162466us 가 걸린다거나!
- sleep() 에 대한 생각을 정리하고 나서 philosopher 프로그램으로 돌아와보니, 어디까지 작성했었는지 알 수가 없게 되버렸다.



2021-12-04

- 오늘은 벌써 토요일이다. 나의 일상을 전부 기록할 수 있는 것이 있으면 좋겠다. 그러면 다양한 정보가 나올 것이고, 그 정보를 바탕으로 다양한 개념 모델을 만들어볼 수 있을 텐데. 가령, 잠에 대한 개념 모델 같은 것 말이다.
- philosophers 에서 sleep() 을 예측하여 실행하는 방법은 썩 마음에 들지 않는다.
	1. 제대로 예측하지 못하는 경우에 대한 에러를 결국 해결하지 못한다.
	2. 모든 philosopher 들이 sleep() 을 호출하는데, 이에 따라 두 가지 구현이 가능할 것이다.
		1. 모든 philosopher 가 공유하는 공간에 예측을 위한 과거 데이터를 두고 사용한다.
			이 경우 이 예측을 위한 과거 데이터는 mutex 로 lock 을 해야 할 텐데, 성능 손실이 클 것 같다.
		1. 각 philosopher 마다 sleep 예측을 위한 이전 데이터를 저장하도록 한다.
			이 경우 예측을 위한 데이터 양이 적어지기 때문에 오차가 커질 것 같다.
- 컴파일과 링크 과정에서는 현재 파일에 있는 header file 은 따로 include option 을 주지 않아도 알아서 탐색하는 것 같다.
	- gcc main.c -> 같은 directory 의 .h 파일을 알아서 찾음
	- 하지만 '.o' file 을 생성하기 위해 'gcc -c' 에서 '.h' 파일을 탐색할 때는 해당 source 파일의 위치를 중심으로 상대 주소로 탐색한다.
- playground 에서 실험을 진행한 후에는 꼭 결과를 주석으로 남겨두도록 하자. 어떤 결과가 있었는지 확인하기 위해 다시 테스트를 진행해야 하는 불편함이 있다.
- playground 에서 작성한 예제에 대한 설명을 커밋을 사용하여 변화마다 주석을 달아줄 수 있는데, 이 경우 주석의 설명을 보기 위해 각 커밋에 checkout 해야 하므로 불편하다. 따라서 이럴 경우 각 커밋의 주석 설명을 동시에 Readme.md 등의 파일에도 똑같이 기록하여 파악하기 쉽도록 하자. 자세한 내용을 보고 싶으면 그 때 가서 checkout 하면 되니까
- 겨울은 눈이 부시다. 해가 낮게 떠서 여름에 비해 시야에 해가 들어온다
- 만약 그런거(드론의 속도, 가속도 센서 값 등 다차 방정식 꼴의 데이터)라면 몰라도 sleep() 은 system 에서 자체적으로 구현한 함수이기 때문에 걸리는 시간을 예측하는 것이 결국 오차가 클 수밖에 없다. (다차 방정식 꼴이 아니다) 그러므로 그냥 내 방식을 사용하도록 하자!
	- 그러므로 쓰레드의 갯수와 sleep 시간에 따른 평균 delay 를 이용하되, 크게 벗어난 값은 제외하는 방식으로 적용해보자!
- local variable 로 선언한 변수의 주소를 thread 의 인자로 넘겨주어 thread 가 dereferencing 하여 사용하는 경우, thread 의 종료를 확인하지 않고 main() 함수를 종료하게 되면, 끝나지 않고 작동중인 thread 가 free 된 stack 영역을 접근하여 segmentation fault 에러가 날 수 있나?
	- 그런 문제 때문에 segmentation fault 가 발생하지는 않는 것 같다. 내가 맞딱뜨린 segmentation fault 는 아래와 같은 이유로 발생했던 것이었다.
- int 가 overflow 하는 것은 UB 이고, unsigned int 가 overflow 하는 것은 UB 가 아니다?
	- https://stackoverflow.com/questions/59080105/illegal-hardware-instruction-from-very-simple-code



2021-12-03

- 테라리아 문로드를 잡았다. 그리고 다양한 유튜브 영상도 보았다.



2021-11-23

- 개념을 모듈화하면 모듈들을 사용해 더 거시적이고 재밌는 것들을 할 수 있다.



2021-11-18

- 무언가를 알아가고 마스터해가는 과정
	- 1. 필요성을 이해한다
	- 2. interface 를 이해한다
	- 3. implementation 을 이해한다
	- 4. 직접 만들어본다.(추상적인 구현에서 시작하여 점점 구체적으로)
- 4 frame 이 반복되도록 만들고 3 개의 image 를 1, 1, 2 frame 씩 설정해주면 꽤 흥미로운 그래픽이지 않을까?
	- 이런 식으로 음악의 규칙을 그래픽에 적용하는 것은 어떨까?
- 함수를 정의할 때 argument type 을 명시해준다. 그러면 caller 가 해당 argument type 의 값을 사용하여 함수를 호출하게 된다. 



2021-11-17

- 작동 설명 은 2 가지 관점으로 작성하면 좋다. 전체적인 관점과 내부적인 관점이다. 이는 마치 argument 와 parameter 의 label 을 각각 두는 것과 같다.
	- 즉 실 사용을 아는 것도 좋지만, 내부 동작을 아는 것도 좋다. 하지만 내부 동작에 대한 설명은 찾기 힘든 부분이 있다.
- 인자로 전달할 일이 많은 배열 데이터는 null terminated 하게 만드는 것이 좋다.
- 직접 내부 값을 변경하는 경우가 많은 배열 데이터는 시작과 끝의 주소를 저장하도록 하자.
- 실행 순서대로 서술되지 않은 코드는 이해하기가 끔찍하다. 가능하면 실행 순서대로 서술하도록 하자.
- 기능을 무작정 코드로 작성해나가기 보다는, 먼저 실제 언어로 서술해 보는 것이 도움이 된다.
	- 각 행위를 명명하는 단어를 끄집어내는 데 도움이 된다.
	- 큰 흐름을 잡는데 도움이 된다.
- 가능하면 바로 세밀한 부분을 서술하기 보다는 크게 크게 덩어리를 잘 나누도록 로직을 짜면서 서술해보자.
- local repository, wording directory
- recommand book: pro git
- binary large object
	- add 를 하면 blob 형태로 stage 에 올라간다.
	- git hash-object <file>: checksum 을 보여준다
		- 내용이 같으면 hash 값이 같다(메타 정보는 사용하지 않음)
	- tree .git: cli command
- 파일이 어떤 파일인지 보는거 어떤 명령어였더라?
- git add 시에 .git/ 에 파일이 저장된다.

- git cat-file -t <hash>: type 을 알려준다.
- git cat-file <type> <hash>: hash 파일을 type 으로 해석한 정보를 출력한다.

- git ls-files --stage: stage 를 출력해준다.

- git ls-tree <hash>: tree 의 내용을 읽기 좋게 보여준다.
- 이런 명령들을 메타 명령이라고 한다.

- git add: 대상 파일을 위한 blob 을 생성한다.
- git commit: 새로운 commit 을 위한 tree 와 commit 을 생성한다.

- git hash-object <file>: file 의 hash value 를 출력한다.
- git write-tree: stage 를 가지고 새로운 tree 를 만든다.
- echo "22" | git commit-tree <hash of tree> -p <hash of parent commit>
- git rm --cached <path>

#define STATE_NORMAL                    0
#define STATE_ENCOUNT_SLASH             1
#define STATE_IN_MULTI_LINE_COMMENT     2
#define STATE_ENCOUNT_ASTERISK          3
#define STATE_IN_SINGLE_QUOTE           4
#define STATE_IN_SINGLE_QUOTE_BACKSLASH 5
#define STATE_IN_DOUBLE_QUOTE           6
#define STATE_IN_DOUBLE_QUOTE_BACKSLASH 7

- 이런식으로 각 상수를 define 하는 것이 아니라 enum 을 사용한다면, 사이 사이에 새로운 constant 가 추가된다고 하더라도 아래의 숫자가 밀리지 않는 장점이 있다.!



2021-11-16

- c 에서는 데이터와 메타 데이터가 짝으로 활동하는 경우가 종종 있다.
	- array 와 array size: array 에 접근할 때 array 의 끝을 위한 메타 데이터가 함께한다
	- string 과 null character: string 을 다룰 때 string 의 끝을 표시하기 위해 null character 를 사용한다.
	- 이런 식의 pair 는 어떤 데이터를 표현할 때 반듯이 함께 다루어져야 한다. 만약 어느 하나를 생략한다면 데이터의 명시가 불명확해지기 때문에, 데이터의 범위를 제대로 표현하지 못하거나 데이터의 값을 제대로 표현하지 못하는 문제가 발생한다.
- 간단한 작동은 간단하게 만든다. 복잡한 작동은 통일화되도록 작성하여 가독성을 더 중시한다.
	- 작은 코드는 이해하기 어렵지 않다. 하지만 크기가 큰 코드는 이해하기 힘들기 때문에 오버헤드가 생기더라도 규격화된 형식을 따라 작성하는 것이 좋다.
- 어떤 source code 에서 source code 밖에 어떤 변수가 정의되어 있다고 가정하고 그 변수를 사용할 때 extern specifier 를 사용한다.
	- 하지만 컴파일 또는 링크 시에는 해당 변수가 포함된 source 파일을 포함해야 할지도 모른다.



2021-11-03

- 장점을 살리는 방법: 추가 구현 없이 base 의 특성으로 대체 가능한 경우
- 적절한 타협: 완전 무시하지는 않으나, base 가 제품 자체가 되지는 않음
- 특성을 무시하는 방법: base 에 얽매이지 않고 general 한 구현



2021-11-01

- 값을 변환할 때는 실패할 수도 있는데 메모리 관련으로 실패하면 어차피 exit() 을 할 것이니 파싱에 대한 성공 실패 여부만 return 하면 된다
- value type 은 NULL 이 인자로 들어와도 빈 data 를 할당하여 반환하고, 그 외에는 NULL 인자에 대해 NULL 을 반환한다
- 즉, value type 은 non-optional 을 반환하고, 그 외에는 optional 을 반환한다
- exit() 이 불가능한 환경에서는 _new() 를 만들지 말고 _init() 까지만 만들자
	- _new() 의 return 값으로 NULL 을 반환할 때 _init 의 실패만을 의미할 수 있다



2021-10-31

- write() 를 쓰는 프로그램에서는 가급적 printf() 를 사용하지 말자
- static 함수는 무조건 나만 호출하므로 내부에서 인자의 NULL 여부를 체크하지 않고, 호출하는 함수가 체크하도록 한다
	- 호출하는 함수는 어차피 특정 값이 NULL 등일 때 반환하도록 로직을 작성해야하기 때문에 최소한 callee 에서의 guard 를 줄일 수 있는 것이다
- 오늘 lmt_c_library 에서 exit() 을 제거하기 위해 노력했었다. 그런데 exit() 을 없애자 전체적인 코드의 가독성이 급격히 하락하는 큰 문제가 발생했다. 에러를 반환하고 이 값을 확인하기 위해 코드가 과하게 들어가다 보니 실제 실행에 필요한 로직을 읽기가 불편해졌다.



2021-10-30

- cherry-pick 은 delta 를 HEAD 에 적용하는 것이다
- malloc 을 _alloc() 에서 NULL 을 체크하여 exit() 을 호출하는 것은 좋지 않은 방식일까?
	- 만약 지금같이 작은 프로젝트가 아니라 더 큰 프로젝트의 모듈을 만든다면 exit() 을 할 일이 결코 없을 것이다. 에러가 발생하면 에러를 검사한 후 적절한 처리를 하여 반환하는 로직이 대다수 일 것이다. 그러니 무작정 exit 하는 코드를 작성하기 보다는 오류를 잘 처리하고 반환하는 방식으로 코딩을 미리미리 연습해두자



2021-10-28

- iterator 등의 protocol 을 따르는 경우, structure 를 생성할 때 미리 그 protocol 을 위한 공간을 memory 에 같이 할당하면 좋겠다. 비록 무의미한 메모리는 많이 차지할 수 있겠지만, 속도는 조금 빨라질 것 같다.
	- 즉, lazy type 은 메모리를 적게 먹는 대신 할당을 위해 시간이 더 걸릴 것이고, early type 은 메모리를 더 많이 먹지만 메모리 할당을 위한 런타임 시간이 줄어들 것이다. 초기 할당에는 근소하게 시간이 더 걸릴 수 있다.
- vim <(cat $(find . -name "*.[ch]") | grep -v "/\*")
	- 현재 directory 안의 파일 중 source file 들을 42header 를 제외한 코드를 vim 으로 실행하는 command



2021-10-27

- 띠용, function prototype 에 void 를 명시해주지 않으면 그 함수를 사용할 때 인자를 넣어줘도 오류를 발생시키지 않네?
	- 인자를 받지 않는 함수의 prototype 에는 반드시 void 를 명시해주도록 하자
- 함수가 개인적으로 동작할 때 segfault 가 발생하는 상황이 존재하는 것은 좋지 않다



2021-10-26

- 어제 main 에서 return 시에 segfault 가 생기는 현상은 not_builtin_cmd() 를 1 번 호출하면 문제가 없었는데, non_builtin command 인지 체크하기 위해 여러번 호출해서 생기는 문제였다.
- const 를 적지 않으니 해당 포인터의 내부 변수를 바꾸는지 확신하기가 힘들다.
	- const 는 대박이다!
- 와 진짜 이건 몰랐다!
	- child process 에서 누수가 나고 있었다!
	- should_execute_on_child() 가 child process 에서 실행 중이었는데, 여기서 호출하는 not_builtin_cmd 가 누수가 나고 있었을 것 같다
	- 그래서 lldb 로 parent process 에서 leak 을 체크해도 leak 이 나지 않았던 것이다.
	- 그 원인으로 인해 이번 문제인 main 문의 return 시 segfault 가 발생한 것 같다
	- 아니다 leak 은 없었다.. 코드를 읽었을 때는 있을 것 같았는데..
	- 잘은 모르겠지만 parent process 에서 not_builtin_cmd() 를 호출했을 때 동일한 문제가 발생하는 것을 확인하였다.




2021-10-25

- 프로젝트가 커짐에 따라 모듈화를 잘 해둬야 '버그를 잡기 쉬워진다'.
	- 모듈화가 잘 되지 않은 경우, 버그가 어디서 난 것인지 확인하기 힘들어진다.
		- 모듈화가 잘 되지 않았다는 뜻은, 전역 변수를 쓰는 것처럼, 수많은 많은 함수에 공통적인 인자로 들어가는 변수가 존재한다는 것이고, 따라서 이 변수가 어디서 변한 것인지 파악해야하는 일거리가 발생한다.
- service provider 가 정지해도 intranet 은 동작하네??
- debug 용 소스 코드를 분리해서 make 할 때 포함할지만 결정해주면 되겠네?
	- 컴파일 시에 'make debug' 로 make 하면 define <file_name> 을 해서 컴파일을 막는다던가?!
- 에러 체크의 흐름에 따라 장기 유지보수 가능한 코드
	- 새로운 에러 체크 작업을 간단히 추가할 수 있도록
- 오늘 알 수 없는 문제와 마주했다.
	- main() 이 return 할 때 segfault 가 발생하는 문제
		- minishell 프로그램에서 외부 함수를 호출한 후 이 segfault 가 발생한다
	- child process 를 실행한 후 wait 을 하는데 -1 이 반환되는 문제가 있었다.
		- 아마 그러면 제대로 wait 을 실행하지 못한 채 프로그램이 종료되었을 것이다.
		- 하지만 이전 커밋에서도 그런 문제를 그대로 가지고 있는 채로도 segfault 가 뜨지 않았었다.
		- 따라서 다른 system call 에서 비슷한 문제가 발생했을 것이고, 그 에러가 제대로 처리되지 않아 main() 의 return 시 segfault 를 발생시켰을 것 같다.
		- 왜냐하면 항상 main 의 retun 에서 segfault 가 날 때는 동시에 waitpid 가 -1 을 반환했기 때문이다.
		- 왜 한번에 모든 system_call 들이 interupt error 를 발생시키는 지는 모르겠지만, 그로 인해 발생한 segfault 일 것 같다
		- 직접 signal 을 찍어보니 waitpid 가 -1 을 return 할 때 아무런 signal 이 찍히지 않았다.
		- 즉, waitpid 는 signal 에 의해 -1 을 return 한 것이 아니었다!
		- 그래서 생각해볼 수 있는 가능성은, 아직 자식 process 가 제대로 생성되지 않았는데 waitpid 를 호출했을 가능성?
		- 그런데 fork 로 이미 pid 를 반환받았는데 그럴 수가 있나?
		- 그런데 waitpid 가 -1 을 return 한 후 perror() 를 호출하면 'Interrupted system call' 가 뜬다.
		- 즉, system call 에 의해 interrupt 된 것은 맞는 것 같다
		- lldb 의 특성이 한 몫 했다.
		- signal() 로 signal 이 특정 함수를 호출하도록 설정해도, lldb 안에서 실행할 때는 signal 이 적용되 버린다!
		- 따라서 모든 signal 에 대해 해당 signal 의 number 를 출력하는 함수를 호출하도록 signal() 을 호출해서 설정해 두었더라도 lldb 안에서 실행할 때는 이 custom signal function 이 작동하지 않게 되었던 것이다!
		- 왠지.. lldb 안에서 segfault 가 더 많이 뜨더라..
		- 이로 인해 main 의 return 에서 segfault 가 system call 이 signal 로 인해 interupt 되었을 때 오작동으로 인한 문제라는 것에 무게가 더 실렸다
		- 결국 최후의 방법으로,, 하나씩 지울만한 함수를 주석 처리해가며 컴파일, 실행을 반복하고 있다.
		- 그 결과 should_execute_on_child() 라는 함수의 유무로 segfault 가 나고 안나고가 결정된다는 사실을 알게 되었다.
- 프로그램을 많이 수정한 후 에러와 마주하면 상당히 난감해진다.
	- 반드시 조금씩 바꿔나가자!!!



2021-10-24

- 어떤 의도를 가지고 코드를 작성할 때, 의도에 의해 설정하는 규칙이 존재한다.
	- 이 때, 어떤 분기를 나눌 조건문을 작성한다면, 의도를 표현해야 읽기 좋다. 조건문에 규칙을 표현하지 말자.
- should_process_execute_on_child() 와 prev_or_current_process_op_is_pipe() 는 같은 역할을 수행하는 함수를 의미할 수 있다.
	- 즉 '이전 혹은 현재 프로세스의 op 가 pipe 일 때, 자식 프로세스를 만들어서 실행해라' 라고 하고 싶은 것이다.
	- 이 때 전자는 caller 에서 문맥상 읽기 쉬운 이름이고, 후자는 함수의 정의문에서 함수의 행동을 뚜렷하게 설명해주는 이름이다.
	- 함수를 설명하는 이름보다는 caller 에서 읽기 좋은 이름을 사용하자.
	- 후에 '그래서 언제 자식 프로세스에서 실행하는 건데?' 라는 의문이 든다면, 그 함수로 이동해 정의를 보려 할 것이고, 이 때 상단에 주석이라도 달아 놓아 이해를 돕도록 하자.
	- 즉, caller 에 적합한 이름은 주석 등으로 추가 설명을 달기 힘들지만 함수 정의를 위한 이름은 주석 등으로 추가 설명을 달기 쉽기 때문에 정보를 넣기 힘든 caller 를 위한 이름을 설정하는 것이다.
- case 에 벗어난 경우 오작동을 막기 위해 assertion 을 사용하고, 없으면 crash 를 내서 종료시키자.
- mandatory 와 bonus 를 분리시키는 것이 좋을까? 분리하라니까 분리하자!
- 말을 너무 빠르게 하지 말자, 상대를 당황시키게 만든다
	- 조근조근 천천히 말해야 상대방이 excite 하지 않고 이성적으로 받아들일 것이다.
	- 내가 excite 해서 빠르고 높은 톤으로 말을 하는 것은 안좋은 행동이다.
- issue 를 마구마구 날리고 나중에 같이, 혹은 인증된 사람이 검증을 쭉 하는 것도 좋겠다.
- 압박받는 듯한 느낌을 주는 것은 좋지 않다. 편안하고 편안하게 하자.



2021-10-23

- 프로그램 소스 코드는 1 차원적이다.(위, 아래의 선형 구조)
	- 때문에 이를 2 차원 이상으로 표현하여 정리하면 구조를 설계하고 이해할 때 도움이 된다. (공책 등에 구조를 정리해보기 == 2차원적)



2021-10-21

- structure 에 새로운 member variable 을 추가하면 바꿔야 할 것이 많아지는 경우가 있다.
- 가령 single linked list 를 double linked list 로 변경할 때, 새롭게 prev node 를 가리키는 member variable 이 추가될 것인데, 이 때 기존에 만들어 두었던, insert, append, remove 등의 element 추가 제거 함수에 코드를 추가해야 할 것이다. 이 때 무작정 생각나는, 보이는 부분부터 바꿔나가기 보다는, 바꿀 대상을 적당히 적어놓고 순차적으로 바꿔나가도록 하자. 생각대로 바꾸다보면 반드시 놓치는 부분이 생긴다. 만약 목록을 작성하고 바꿔나가는 중에 더 바꿔야 할 부분이 보인다면, 당장 바꾸는 것이 아니라!! 목록을 수정하고 순차적으로 바꿔나가자!
- man page 처럼 설명을 하면 될 것 같다. 설명을 할 때 대상이 무엇을 할 수 있는지 가능한 것을 먼저 제시해준다. 가령, "코드가 보고 싶으면 어떤 코드 보여달라고 얘기하고, 그림으로 그려달라고 하면 그려줄께!" 라는 얘기를 통해 상대방이 어떤 행동을 취하는 것이 허용되는지 알려주도록 한다.
- '_alloc': 메모리 할당
- '_init': shallow set
- '_set': deep set
- 데이터의 구조를 하나로 뭉치지 않고, 재귀적으로 작동하는 함수가 일부를 차지하도록 하면 데이터가 단절되어 서로 간의 접근이 불가능해진다. 만약 모든 데이터가 서로를 찾을 수 있게 하려면 하나의 뭉쳐진 구조로 모델링하라!



2021-10-20

- ps -o pid,ppid,pgid,tty,comm
- pgid 는 어떤 값으로 설정되는 것일까?
	- sleep 1000 | sleep 1000 을 실행하면 새로 생성된 두 자식 process 는 첫 프로세스의 pid 를 pgid 로 갖는다. 왜그럴까? 그리고 이런 특성하에서 wait4(0,,,) 는 caller 의 pgid 와 같은 child process 가 exit 하는 것을 기다린다고 하는데, 생성된 자식 프로세스는 왜 parent process 와 pgid 가 다른 것일까?



2021-10-19

- 주 작업이 무엇인지 확실히 하라
	- 주된 작업이 아니라면 비효율적이더라도 유지보수가 편한 방법 및 읽기 쉬운 방법, 그리고 생산성이 높은 방법을 선택하라!
- 시간이 남고 할게 없으면 이전에 만든 코드를 유지보수 하는 것은 어떨까?
	- 특히 variabledText!
- 계획을 변경했다면, 왜 계획을 변경한 것인지, 전과 후의 장단점은 무엇인지를 꼭 꼭 꼭 기록해두도록 하자.



2021-10-14

- 내부적으로 반환에 사용하는 ERROR, NORMAL 과, program 이 반환하는 ERROR_CODE, NORMAL_CODE 를 분리하여 사용하면 좋겠다.
- find . -not -path "./.git*" | grep "\.o"
- child process 가 exit 을 하지 않으면 그 뒤의 코드가 끝날 때까지 계속 실행된다
- 한 파일에 사용하지 않더라도 함수를 정의하면, 컴파일된 파일의 크기가 변한다.
	- 해당 함수의 어셈블리 코드가 실행 파일에 추가된다.
- 하지만 include 했던 stddef 를 stdlib 로 바꾸거나, include 하지 않도록 수정해도, 생성된 실행파일의 크기는 변하지 않았다.
- 아마 stddef 나 stdlib 는 함수의 정의를 담고 있지 않고, 단순히 prototype 만을 담고 있기 때문에 그런 것 같다. 아마 실제 해당 함수를 실행해야 할 때는 컴파일되어 있는 해당 함수를 시스템에서 찾아서 호출하여 사용할 것 같다. 나는 모든 실행 파일이 각각 그런 시스템 함수를 바이너리 상태로 가지고 있을 것이라고 생각했으나, 오늘 확인한 결과를 보니 그렇지 않을 것 같다는 생각을 했다.



2021-10-13

- 빠르게 구현 가능한 방식으로 프로그램을 구조화하고 작성하는 것도 중요하다. 당장 눈에 결과가 보여야 오류도 잡아내고 방향도 결정할 수 있기 때문이다.
- 하지만 동시에 확장성을 고려하여 작성하는 것도 무척 중요하다. 만약 내가 minishell 프로그램을 작성하기 시작했을 때 () 를 잘 고려해서 작성했더라면 lmt_process_manager 를 만들었다 지웠다 다시 만드는, 이렇게 큰 일이 되지 않았을 것이다. 또한 그런 확장성을 고려한 부분은 왜 그렇게 작성했는지 독자들에게 잘 전달되어야만 한다. 그렇지 않으면 불필요한 부분으로 여겨져 코드에서 삭제될 수 있다.
- 무언가 색이 완전 같은 것은 좋지 않다. 구별이 가지 않기 때문이다. 미세한 차이라도 랜덤하게 주자.
- 처음 한 번에 한해 수행하고 후에는 작동하지 않도록 함수를 작성하면 계속 호출해도 작동하지 않는 기능을 구현할 수 있다. 이런 특성을 담은 이름을 잘 지어주도록 하자.
- 즉, 최초 한 회만 실행해야 하는 기능이 필요한 경우가 있고, 계속 같은 작동을 해야 하는 경우가 있는 것이다.



2021-10-12

계발 방식을 공고히 정해놓고 진행하는 것이 좋다.
dev branch 에 항상 release 가능한 버전을 pull request 하는 식으로



2021-10-11

- 왜 rebase -i 를 해서 commit 의 순서를 바꾸면 Debug diff 와 일반 diff 가 섞이는 경우가 생기는 것일까?
	- Debug commit 에서 수정한 내용이 일반 commit 에 섞여들어간다



2021-10-10

- function declaration 과 function prototype 의 argument name 은 같을 필요가 없다. function declaration 의 parameter name 은 argument label 을 사용하고 function prototype 의 parameter name 에는 parameter name 을 사용한다.
return_type	function_prototype(parameter_type parameter_name);
return_type	function_declaration(argument_type argument_label)
{
}
- 따로 sequence structure 를 사용하지 않으니 발생하는 몇가지 문제가 있다. 반복을 담당하는 변수 element 가 내부 호출 함수로 전달되지 않으니, sequence 를 iterate 하는 중에 sequence 안의 element 들의 순서가 바뀐다면, 이런 정보가 element 에 적용되지 않는다.
- 반복 작업을 하다보면 일부 범위에서는 특수한 케이스로 반복해야 하는 경우가 있다.
	- 어디까지 작업했는지 인덱스 및 주소를 반환하기.
		- 이것이 편한 경우가 있다. inner function 이 재사용되지 않는 경우이다. 그리고 어떤 위치에서 정확히 발생하거나 발생하지 않는 경우 유용할 것 같다.
	- 작업 위치를 기억하는 변수의 주소를 인자로 전달하기.
		- 이 방법은 너무 별로다. 만약 iterate 하는 대상이 주소라면 이중 포인터를 사용해야 해서 가독성도 떨어진다.
	- 상위에 object 를 둬서 현재 작업 위치를 기억하도록 하고, 이 object 를 전달하여 사용하기
		- 이 방법은 가독성은 좋으나 모듈화되지 않는다는 점이 불편하다. object 가 inner function 까지 전달되기 때문에, inner function 에서는 사용하지 않는 object 의 다른 멤버 변수에 접근하는 등, 모듈화하기에 좋지 않다. 그리고 inner function 이 object 에 의존적이어지는 문제도 있다.
	- 특수한 작업을 하는 중인지를 flag 에 기록해두고 매 loop 마다 체크하여 필요한 routine 실행하도록 하기.
		- 매 loop 마다 어떤 상태인지 flag 를 확인해야하는 overhead 가 존재한다. 하지만 코드가 명확해지고 모듈화에 유리하다는 장점이 있다.



2021-10-09

- if 를 여러번 호출해야하는 함수가 있다면, 각 case 를 나누고, 그 case 에서 실행할 함수를 작성한 후 static array 에 저장하고, case 별로 index 를 return 하는 함수를 작성하여 static array 의 그 index 번째 함수에 접근하여 호출하는 방식이 좋겠다. static 사용에 제한은 없다.
	- 또, static 을 사용할 때는 thread safe 하게 만들기 위해, 변하는 값이 아닌, 상수형 값에 대해서만 사용하는 것이 좋겠다. 그럼 즉, const 값이네? 거기에 함수가 실행되어야만 처음으로 static 변수의 값이 초기화되니 lazy 하다고 할 수 있다.
- 함수의 분류
	- method: structure type 전용으로 묶인 함수
		- ex) _alloc, _init, _new, _free, 혹은 그 structure 전용 기능들
	- extension: 기존 structure 를 위한 나만의 추가적인 전용 함수
	- util: 분류되지 않은 함수 -> 이후 분리되서 독립적인 module 이 될 수 있다.
- 함수의 이름 앞에 lmt_ 접두사를 붙일 필요는 없다고 생각한다.
- 특히 이런 접두사는 structure 의 이름을 원천적으로 구분지어서 일반적인 structure 와 구분지을 때는 유용하지만. 누가 이 함수를 작성했는지를 구분하기 위한 목적으로 prefix 를 붙이는 것은 옳지 않다고 본다. 프로그램적 관점에서 볼 때, 하나의 프로그램 코드는 한 명의 사람이 작성한 것처럼 작성되어야 하는데, 작성한 사람을 구분하기 위한 목적의 prefix 는 이에 모순되기 때문이다.
- 하나의 ui 를 구성할 때 제공하는 기능의 범위에 따라 3 단계로 분류할 수 있다.
	1. 모든 것을 직접 컨트롤 할 수 있다.
	2. 제한적으로 직접 컨트롤 할 수 있다.
	3. 직접 컨트롤 할 수 있는 것이 없다.
- 어차피 git 의 기록은 github 에서 파일별로 message 가 표시된다. 따라서 파일을 생성했다는 message 등은 기록할 필요가 없는 것이다. message 에 파일 자체의 생성 소멸을 기록하기 보다는, object 나 function 에 중점을 둔 기록을 남기자.
- swift 의 Array structure 에는 pop() 을 구현할 필요가 없었다. remove 만으로 특정 위치의 element 를 제거할 수 있고, 반환값으로 나온 그 element 는 사용해도 되지만, @discardableResult directive 가 붙어있기 때문에, 그냥 무시한다면 warning 도 뜨지 않고 ARC 가 알아서 처리할 것이다.



2021-10-07

- 'ctags': aux ctags . .
- 지금 하고 있는 일이 어떤 경로로 지금에 이르렀는지 꾸준히 기록해두자. 뭘 위해 뭘 하고 있었는지 까먹는 경우가 종종 있다.
- 이미 compile 된 파일의 header 파일을 수정하는 경우 Makefile 을 해당 header 파일이 compile 을 위한 source file 의 의존성으로 고려하지 않기 때문에 re compile 되지 않는다



2021-10-06

- 'git branch -d -r origin/jeonpark_new'



2021-10-05

- 내가 짠 코드를 직접 읽기 보다는 위에 적힌 설명을 읽고 이해하기가 쉬웠다면, 코드를 예쁘게 작성하고 있지 않다는 뜻 아닐까?
- 실행 흐름에 따라 프로그램을 쌓아나가듯이 제작하면 추가적인 코드 테스트용 코드가 적어질 수 있다.
	- 만약 각자 맡은 모듈을 제작하고 결합하려고 한다면, 각 모듈별로 테스트용 코드가 필요할 것이다.
		- 하지만 각 모듈읠 안정성을 검증하기에는 더 좋을 것이다.



2021-10-04

- 한 번 잠을 자기 시작하면 3 시간은 자게 된다. 잠을 자지 않기 위해 노력을 해보도록 하자. 가장 좋은 방법은 생각했던 프로그램을 빠르게 코딩하는 것이다.



2021-10-03

- 코드의 원본에 직접 주석으로 설명을 다는 것이 아니라, 마치 숫자로 표시하고 밑에 주석을 달듯이 설명을 추가하면 보다 기존 코드를 방해하지 않는 채로 설명이 가능해질 것 같다
- xxd test.txt | xxd -r
- xxd test.txt | xxd -r -s 100
- echo "00000010:31" | xxd -r - <path>
- echo "100:41" | xxd -r > <path>
- echo "100:41" | xxd -r -s -0x100 > <path>
- 'man -k <keyword>'
- 'apropos <keyword>'
- 'which, type'



2021-10-02

- 제품을 만든다는 것은 가능한 모든 것을 우겨넣는 것이 아니다. 핵심적인 것을 추가하고, 불필요한 것은 차단하는 것이다. UNIX 도 그런식으로 모델을 디자인하여 구현된 것이다.



2021-09-27

- 함수가 반환하는 값에 따라 함수가 에러 상태로 반환됐는지 등을 확인하는 것은 필수적인 과정이다. 그리고 내가 그 함수의 에러 여부를 어느정도 입력값 등으로 통제할 수 있는가도 제대로 파악해두는 것이 함수를 제대로 사용하는 것이다
- 'Liemani/cLibrary' 에서 'general class' 를 구현하기 위해 'kernel class' 를 구현했었는데, 따라서 'kernel class' 는 'general class' 의 기능을 사용하는 것이 아니라 그 골격을 구성하는 구조로 만들었다.
	- 마찬가지로 os 의 page 관리 시스템이 메모리 할당을 담당할텐데, 자기 자신의 메모리 할당에 대해서는 generic 한 함수를 사용하지 않을 것 같다	- 이런식으로 우리는 단순히 malloc() 이라는 함수를 사용할 때, 사실 이 함수가 제대로 작동하기 위해서는 시스템이 그 기반을 마련해주기 때문에 가능한 것이다
- 프로그램 곳곳에서 magic number 를 마치 약속된 고정 수 인것처럼 사용하는 것이 아니라 define 등으로 상수를 선언하여 사용하는 것이 좋다
	-  상수 값을 바꾸어도 실제 문서에는 상수의 이름이 기록되어 있기 때문에, 모든 문서의 해당 상수를 변경할 필요 없이 완성된 프로그램의 상수 값을 간단히 수정할 수 있는 장점이 있다.
- 자료를 잘 모아두고 정리하는 것은 현대 사회에서 매우 중요한 작업이다. 그런데 이를 raw 하게 처리해주는 프로그램이 적다는 것이 아쉬울 따름이다. 데이터 자료를 구조화하는 standard model 을 정의하고 이로 encode, decode 하는 프로그램을 만들면 좋을 것 같다
- 'git rebase -i' 는 순서를 변경했을 때 단순히 기록된 차이점을 사용하는 것이 아니라, 각 commit 의 tree 를 그 때 그 때 비교하여 새로 추가된 파일을 탐색하는 것 같다



2021-09-21

- 'git checkout --ours -- <path>'
- 'git checkout --theirs -- <path>'
- 포인터 타입의 값을 읽고 쓰는 것과, 일반 변수를 읽고 쓰는 것에 속도 차이가 있을까?
	- 어셈블리 코드를 비교해봐야 알 수 있을 것이다
- 'git cherry-pick A^..B'
- 'git cherry-pick A..B'



2021-09-20

- 'man 2 execve'
- 'man 5 a.out'
- 'man 1 as'
- 'man 1 ld'
- 'man 7 environ'
- 'execve()' 가 성공하면 닫히고, 실패하면 닫히지 않도록 특정 fd 를 설정할 수 있다(fcntl() 로)
- argv 는 항상 null terminate 임이 보장되기 때문에 execve 의 두번째 인자로 사용할 수 있다
- 't_lmt_string *lmt_string_split_first(t_lmt_string *string, size_t count)' 처럼 전 후로 어차피 string->count > count 인지를 판단해야만 한다면, 굳이 이 함수의 구현에서 그 작업을 하지는 말자
	- 이 함수 내부에서 string->count > count 에 따른 처리를 해 준다고 해도, 호출부에서 return value 가 empty 인지를 확인하는 추가 작업을 해야하기 때문에, 처음부터 string->count > count 여부를 호출부에서 처리하도록 디자인하자
- [Apple Thread](https://developer.apple.com/documentation/foundation/thread)
	- When you need to perform a lengthy task, but don't want it to block the executioin of the rest of the application
	- In particular, you can use threads to avoid blocking the main thread of the application, which handles user interface and event-related actions
	- Threads can also be used to divide a large job into several smaller jobs, which can lead to performance increases on multi-core computers
- 프로그램이 종료되면 해당 프로그램에서 생성된 thread 들은 알아서 종료되는 것일까? 어떤 상황에서라도?
- [Thread wiki](https://en.wikipedia.org/wiki/Thread_(computing)
- 다 multi-thread 로 처리하면 되지 multi-process 는 왜 사용하는 거지?
	- minishell 과 philosophers bonus 가 multi-process 를 사용한다
	- thread 처럼 자원을 공유하지 않고 완전 별개의 프로그램처럼 취급하고 싶을 때 유리할 것 같다
	- A process is a unit of resources
	- A thread is a unit of scheduling and execution



2021-09-19

- predicate: iterate 하게 traverse 하면서 참과 거짓을 따질 때 그 참 거짓을 분별하는 함수를 predicate 라고 한다



2021-09-18

- 다양한 기능들을 복합적으로 섞지 말고 가능하면 쪼개서 추가/제거가 쉬운 구조로 만들자
- 다양한 타입의 list 를 구현할 때, 한 번 list 를 구현하고 사용하는 방법은 크게 2 가지가 있다
	- 'void *' 타입 의 member variable 을 content 로 갖는 list
		- 이 경우 간단하게 구현하여 사용이 가능하지만 element 의 값에 접근할 때 content 의 주소로 접근해야하는 오버헤드가 존재한다
	- list 로 만들 구조체를 위한 전용 list 형태의 구조체
		- 이 경우 각 list 구조체가 해당 type 의 구조체 데이터를 직접 소유하므로, 주소를 통해 데이터에 접근해야하는 오버헤드는 존재하지 않지만, list 화 할 type 에 대해 각각의 list 형태의 구조체를 정의해야만 하는 번거로움이 따른다, 따라서 실질적으로 이 것을 지원하기 위해서는, 이를 지원하기 위한 추가 작업이 선행되어야 한다
- list 는 append 에 불리하다
- 따라서 append 를 하고자 한다면 list 를 수정해서 사용해야만 한다
- set, array, list, stack, queue, dictionary, sequence, iterator
- sequence 를 구현하면서, append 함수를 만드는데, 만약 dummy node 를 두지 않는다면 append 시에 sequence 의 last 가 NULL 인지를 check 하여 다른 행동을 하도록 만들어야 한다. 이것이 싫어서 메모리를 조금 차지하지만 dummy node 를 두었다
- sequence 와 collection, 이 둘은 배열적 특성인 random access 가 가능한가를 기준으로 구분된다
	- sequence 는 random access 를 지원하지 않는다
	- collection 은 random access 를 지원한다
- traverse 는 방향과 차원에 상관 없이 탐색하는 느낌이고, iterate 는 선형적으로 진행하는 느낌이다



2021-09-16

- data segment 의 값을 프로그램이 바꾸려고 하면 bus error 가 발생한다
- general command tty: print current ttyname
- man stty
- man 4 termios
- [ieee](https://ieeexplore.ieee.org/document/6880751) 에서 발견한 문서의 doi 를 [sci-hub](https://sci-hub.se) 에서 검색하여 문서를 다운로드 할 수 있다?
- success & failure
- ps xao pid,ppid,pgid,comm
- ps -o tty,pid,ppid,pgid,comm



2021-09-15

- 생각은 기록보다 빠르다, private 암호와 등으로 속기 기술을 익힌다면 어떨까?
	- 복호화하여 public 이 이해 가능한 형태로 바꾸는 기술이 동반되어야 할 것이다
- minishell tokenize: structure 를 재귀적으로 사용했다면 어땠을까?
- mathmatical expression 을 tokenize 해보기
- <C-f>
- <C-b>

- <M-f>
- <M-b>

- <C-a>
- <C-e>

- <C-_>: undo
- <C-x C-u>: undo

- <C-d>
- <C-h>

- <M-d>
- <M-DEL>
- <C-w>

- <C-y>

- <M-digit><command>
- <M-TAB>: insert a tab character
- <C-t>: swap two characters
- <M-t>: swap two words
- <M-u>: uppercase current word
- <M-l>: lowercase current word
- <M-c>: capitalize current word
- 공부를 할 때 무엇을 참조했는지 기록해두는 것이 좋겠다
- [what is a buffer overflow](https://www.veracode.com/security/buffer-overflow)



2021-09-06

- 종이처럼 직접 만지고 필기할 수 있는 모니터 -> 아이패드처럼 필기가 가능하도록
- 더 나아가, 펜으로 프로그래밍이나 다양한 조작을 가능하도록?
- 'echo $LINES': 터미널의 출력 줄 수를 담고 있는 변수의 값을 출력한다
- 'echo $COLUMNS': 위와 유사
- 'setupterm()': env 와 terminfo 사용하여 terminal type 변수 하나를 생성한다



2021-09-04

- 인터넷의 정제된 페이지를 가져와서 vim 처럼 보고 싶다면, vim 에 인터넷 페이지를 정제하여 읽어오는 기능을 넣으면 되는 것이 아닐까?
  - 하지만 그러려면 vim script 등을 배워야겠지



2021-09-02

- 'man 5 term' 을 보니 지금과 같이 16 진수 체계를 사용하기보다 8 진수를 사용한 기록이 눈에 띄었다. 아마 옛날에 8 진수와 16 진수 체계가 혼용되던 시절, 초기에는 단순히 아라비안 숫자 체계가 0 부터 9 까지 존재하기 때문에 표기가 가능한 8 진수 체계가 사용되었지 않았나 싶다. 지금 와서는 0 부터 f 까지 사용하는 16 진수 체계가 더 자연스럽고 통용되었지만 말이다



2021-09-01

- vimsession 은 폴더 이름이 바뀌는 등, 외부의 수정이 가해졌을 때 이 변화를 인지하지 못하는 문제가 있다
- 왜 보기에 지저분한 html 을 사용해야만 하는가? 시각적으로도 더 읽기 쉽고 가벼운 언어를 사용할 수는 없는가?
- 'man 2 read' 를 보면 '#include <sys/uio.h>' 가 있는데, 이는 readv 의 인자인 iovec 를 정의하고 있기 때문에 추가하는 듯 하다, 만약 read() 만 사용한다면 sys/uio.h 를 include 할 필용는 없을 것이다
- 내가 프로그램 지능이 나보다 낮은 사람에게 알려줄 수 있는 것은 앞길과, 그 시기에는 원래 그렇게 힘들다는 것이다



2021-08-31

- 가령, 모든 데스크 셋업을 커버할 수 있는 책상을 가지고 싶다고 하자
  - 그렇다면 왜 그런 책상을 원하는 것일까?
  - 그것은 지금 내 책상이 어떤 나의 이상적인 셋업을 커버하지 못하기 때문이다
  - 그렇다면 사실 '모든 데스크 셋업을 커버할 수 있는 책상' 은 문제를 해결하는 방법 중 하나이다
  - 따라서 어떤 사람이 원하는 것이 있다면, 그것은 해결 방안 중 하나일 것이기 때문에
  - 문제가 무엇인지를 확실히 하는 작업이 우선적으로 필요할 것이다
  - 하지만 대부분의 사람들은 문제가 무엇인줄 알며, 그에 대한 적절한 해결 방안을 제시한 것일 것이다

- https://osxdaily.com/2006/12/19/command-line-keyboard-shortcuts-for-mac-os-x/
  - <ctrl-a>: go to the beginning of the line
  - <ctrl-e>: go to the end of the line
  - <ctrl-u>: clear the line before the cursor
  - <ctrl-k>: clear the line after the cursor
  - <ctrl-w>: delete the word before the cursor



2021-08-27

- 컨벤션 관리 파일을 만들어서 컨벤션을 기록해두고 버전관리도 하면 어떨까?



2021-08-20

- 'traceroute <ip>': ip 로 가는 경로의 ip 들을 출력한다
- 'arp': local network 를 출력한다



2021-08-15

- OOP 는 기본적으로 다양한 주소를 무리지어서 하나의 그룹을 구성하기 위해 탄생한 것이 아닐까?
  - 모든 작업에서 1차적으로 발전할 때 그룹을 형성하는 것이 중요하다고 생각한다. 파일 시스템처럼 directory 를 만드는 것이다. 이를 위해 어떤 기준으로 그룹을 지을까가 중요해졌고, 여기서 물체 중심으로 관련된 주소들을 그룹지어서 저장하는 OOP 가 발전한 것 같다



2021-08-14

- xxd test.txt
  - '-s <address>'
    - xxd -s 0x10 test.txt
  - '-l <address>'
    - xxd -l 0x10 test.txt



2021-08-05

- 게임의 요소: 시청각의 값과 변화량
  - 시각 축 값: 그래픽
  - 시각 축 변화량: 모션
  - 청각 축 값: 배경 음악
  - 청각 축 변화량: 이펙트 사운드

1) 만약 각 A 가 90 도 이하라면
    각 B 가 45 도 이므로 각 C 는 180 - 각 A - 각 B 이다
2) 만약 각 A 가 90 도 라면
    각 C = 90 - 각 B
3) 만약 각 A 가 90 도 이상이라면
    각 C = 180 - 각 A - 각 B 이고,
    각 A > 180 + 각 B 이면 ABC 는 삼각형이 아니다

이런 식으로, 하나의 서술에는 하나의 가정만을 두는 것이 가독성 측면에서 좋을 것 같다



2021-07-19

```
...

print normal
if (fail)
{
	print additional fail message
}

...
```

- 함수 도중에 이런 식으로 하나의 흐름에 분기를 두는 것은 가독성을 낮춘다
- print 와 if 문을 분리하는 시각적 효과가 있으며, print 가 위의 흐름에 포함될지 아래 if 문의 흐름에 포함될지 중의적이어진다

```
...

if (success)
{
	print normal
}
else
{
	print normal
	print additional fail message
}

...
```

- 이렇게 print normal 이라는 statement 가 두 번 들어가지만, if 문 하나로 모듈화해 놓는 것이 위 아래 흐름이 존재하는 상황에서는 더 좋다

```
...

print_state()
{
	if (success)
	{
		print normal
	}
	else
	{
		print normal
		print additional fail message
	}
}

...

print_state()

...
```

- 이런식으로 구분된 모듈은 하나의 함수로 만들어주는 것이 가독성 측면에서 최고로 좋다

```
...

print_state()
{
	print normal
	if (fail)
		print addtional fail message
}

...

print_state()

...
```

- 이제 하나의 모듈로 묶여 중이적인 부분이 해소되었으므로 print normal 을 두 번 쓰지 않고, 실패 시에면 추가 실패 메세지를 출력하도록 해도 가독성이 떨어지지 않는다



2021-07-17

- 요구사항에 대한 자세한 내용은, 직접 만들어보고 나서야 기준을 세울 수 있는 경우가 존재한다
  - 그런데 막상 만들어보고 나서, 기존의 요구사항을 까먹기도 한다
- 'git reset --hard <commit>': branch 를 옮기고 working directory 의 파일들도 commit 의 것으로 교체한다
- 'git reset --soft <commit>': 현재 branch 를 commit 으로 옮기지만 working directory 의 파일들은 변경하지 않는다
- 일일이 모듈화된 코드를 넣었다 뺐다 하는 것이 아니라 git 으로 해당 코드를 버전 관리 하면서 필요하면 적용된 코드를 넣고, 필요 없으면 해당 버전을 빼는 방식으로 진행하면 좋겠다(완벽히 유기적으로 연결될 수는 없겠지만)
	- 순서와 계층이 생길 수 밖에 없다
	- A > B > C 순서로 코드를 작성했다면 C 는 A 와 B 에 영향을 끼치게 되고 B 는 A 에 영향을 끼칠 수 있다. 이 상태에서 A 를 뺀다고 했을 때 B 와 C 는 A 에 의존적이기 때문에 세부적인 부분의 수정이 불가피할 것이다



2021-07-16

- 이런식으로 한 줄이라도 오늘 생각한 것을 기록하는 것이 작은 성취감을 얻을 수 있는 귀한 행동인 것 같다
- 해야 할 일을 전부 적어놓고, 우선순위를 매기자. 더 급한 것을 먼저 하며 하고 싶더라도 당장 급하지 않은 경우는 반드시 뒤로 미루도록 하자



2021-07-15

- const 는 해당 포인터가 가리키는 변수 내부의 포인터가 가리키는 변수의 값을 변경하는 것도 불가능한가?



2021-07-09

- function prototype 의 argument name 에는 argument name 을, function define 의 parameter name 에는 parameter name 을 기입하도록 해보자
- general Debug commit 과 delicate Debug commit 을 구분해도 좋았을 것다
- commit 에는 무엇이 기록되어 있을까? 다시 한 번 확인을 해 볼 필요가 있다
- string 을 tokenize 할 때 단순히 특정 delimiter 로 쪼개어 word 단위로 저장하는 것이 아니라 앞뒤 문맥을 보고 해당 word 의 type 을 결정하는 것이 필요하다. 또한 word 단위가 아니라 의미있는 word 들의 묶음을 하나의 token 으로 묶어서 처리할 필요가 있다
	- structure 를 재귀적으로 사용했다면 어땠을까?
- process's filedescriptor table 에서 fd index 번재의 file data structure 를 읽고 사용 가능한 system call 함수가 해당 fd 의 file 에 사용 가능한지 판단한다



2021-07-08

- 'launchctl limit': show limit data



2021-07-07

- 요구사항을 분석하는 능력이 부족하다
- n 이 m 개 있는 것을 표현하는 방법
  - (mn | n * m)
- pseudo code 의 경우 시연용으로 작동 가능하도록 만들려면, 시연용 input 에 대한 output 을 출력하도록 만들어 놓는다(내부 구현은 없어도 된다)
- 역시 조금 불필요한 동작이 있더라도 빠르게 구현하는 것이 더 중요한 것 같다. 아무리 잘 만든다고 오랫동안 공들여도 당장 작동하지 않는다면, 차라리 2~3 배의 자원을 사용하더라도 일단 작동하는 것이 더 좋다



2021-07-06

- 'ps -f <pid>': process 의 ppid 를 알 수 있다
- 요구 사항이 있으면 요구사항을 최저 사양으로 설정하고 전체적 추상화를 진행하는 것이 좋을 것 같다
- 상대가 원하는 정보가 따로 존재한다
  - 다량의 정보를 그냥 쏟아내는 것은 좋지 않다
- 피드백을 잘 해라
  - '너무 작아서 잘 안들렸어!'



2021-07-05

- 팀원들간의 사적 일정으로 인해 격차가 발생할 수 있다. 이 경우 일정을 잘 조율하지 않으면 부담이 가해질 수 있다
- 말을 조금 더 조심스럽게 하자
- 너무 말을 억세게 한다
- 상대방도 말을 더 부드럽게 할 수 있도록 내가 유도해서 행동해보자



2021-07-04

- 화를 내지 않도록 조심해라! 화를 내면 내가 생각해보지 못했던 상대의 새로운 의견을 들을 기회가 사라질 수 있다



2021-07-03

- '~/.vimrc' 로부터 적용된 내용은 vimsession 에 저장되고, vimsession 을 open 할 때는 '~/.vimrc' 를 읽지 않는다
- dm 메세지와 다르게 facebook 처럼 나의 line 에 메세지를 남기는 방식이 확실히 전파력도 강하고 가볍게 글을 남길 수 있어서 장점이 있는 것 같다



2021-07-02

- 잘 모르는 것에 대한 부분에서는 목소리를 높이지 말자. 잘 알지도 못하면서..



2021-06-30

- 나는 왜 타인을 무시하고 들어가는가?
  - 가치관이 다른 사람을 인정할 수 있는가?
- 내가 의견이 너무 강하다
- 물어보자 왜 왜 왜인지 물어보자
- 상대의 말을 더 잘 들으려고 노력하자



2021-06-29

- 팀원 각각의 특성을 잘 파악하는 것이 중요하다
- 대화는 한 명이 다른 한 명에게 생각을 전달하는 것이다. 혼자 말하는 것이 아니다. 전달하고자 하는 생각이 무엇인지 확실히 해둬라



2021-06-28

- 시간이 넉넉하지 않을 때 대화를 하지 않는 것은 좋지 않다
  - 시간이 넉넉하지 않다는 것을 대화를 해서 알리도록 하여라!
- 규칙이 없다면 둘이 섞일 수 없다
  - 각자가 맡은 부분만을 담당해야 한다
- 규칙이 있다면 둘이 섞일 수 있다
  - 각자가 하고 싶은 부분을 건들일 수 있다
- detach 하면 thread 가 종료될 때 내부 할당이 free 될까?



2021-06-27

- 끝내기 전에 나의 성장을 위한 감사를 표현하자
- "너무 무리하지는 말어"
  - 이렇게만 말하면 상대가 여러 의미로 해석이 가능하다
  - 명시적으로 의미 전달을 해야 한다
    - 우리의 목표는 단거리 달리기가 아니다! 라는 등!
- 상대 말에 대한 묵언
  -> 상대 말에 대한 부정적 의견 표출로 해석
- 말의 높낮이를 비정상적으로 꼼
  - 말이 진정성을 낮추고 장난칠 때 하는 행동
    - 상황에 따라 상대를 조롱하는 것이 될 수 있다
- 상대는 하고 싶은 것이 있는데, 내가 다른 것이 눈에 보인다고 그 것을 얘기하면, 상대의 입장에서는 자신의 문제를 해결하지 못한 채 추가적인 문제가 생기는 것이다!



2021-06-26

- ls 에 파일 내용을 출력하는 기능이 있더라
- 설명을 할 때 평가를 받는 것처럼 중간 단계를 건너 뛰고 결과 및 큰 그림을 설명하는 문제
  - 상대에게 맞춰줘야한다!
  - 상대가 나의 설명을 이해하지 못하는 것은, 내가 상대가 얼마나 알고 있는지를 이해하지 못하고 있기 때문이다
- 단 usleep(1) 만 해도 31019 usec 만큼이 걸릴 수 있다 (다른 thread 가 열심히 돌아가고 있다면)
  - 모든 작동이 한 번에 오래 걸리지 않도록 적당히 suspend 를 해주도록 하자 (그래야 thread 가 골고루 돌아갈 것 같다)



2021-06-25

- signal 에 대해 물어보셨을 때 'man signal' 을 보여드리면 더 좋았을 것 같다!!
- 상대가 자신은 뭘 쓴다고 하면 그에 대한 반응을 해주자!! 가볍게!!
  - 기술 1. 오,, 어때요?
    - 단순 의견 질문
  - 기술 2. 오,, 이거랑 비교해보면 어때요?
    - 비교 대상 존재 시 비교 질문
  - 기술 3. 오,, 노트북에서도 편했었는데, 편할 것 같아요
    - 경험을 토대로 의견 제시
- 문제에 대한 질문
  - 기술 1, 대답 연기
    - 생각 좀만 해봐도 될까요?
- 한 번 대화를 할 때 제대로 의미를 전달하도록 하자!
  - 한 번에 잘 전달하지 못했다면 여러 번 말을 번복해야하는 수고가 발생한다
- 다른 사람이 내 코드를 볼 때 어떤 식으로 볼지를 생각해보는 것도 좋겠다
  - 만약 보조 자료가 있다면 학습 속도가 비약적으로 빨라질 것이다 (전체적인 데이터의 흐름 등)
  - 만약 코드만으로 분석을 해야 한다면 'main()' 부터 시작하여 직접 코드의 흐름을 분석해야 할 것이다
    - 이 경우는 내가 직접 지원해 줄 필요는 없지만, 당사자는 함수의 이름을 보고 접두사, 접미사를 통해 대략적인 역할을 파악할 수도 있다

- 긍정적이냐 부정적이냐는 나의 관점에서 판단하는 것이 아니라 타인의 어제와 오늘을 비교하여 결정하는 것이다
  - 이것을 못하면 다양성의 긍정적인 면을 인정하기 힘들어질 것 같다



2021-06-24

- 함수가 pointer 를 인자로 받을 때는 그 인자가 const type 인지 아닌지가 중요해진다!! 변경되서는 안되는 인자라면 const 를 명시해주는 것이 좋다
- 멘토 특강(오디오 신호 이해 및 딥러닝 음성인식 (Speech Recognition) (주) 보이스프린트 대표 김광호
{
	feedback 바라는 점까지
	소리 인식, 음성 인식, 자연어 인식 (언어 모델)
	오디오 신호 -> 시계열 데이터
	언어모델
	트랜스포머 버트 쥐피티
	강 인공지능: 사람 같은
	약 인공지능: 특정 영역에서 성능을 발휘함
	최적경로 알고리즘?
	옛날에는 SVM 이라는 것도 있었다고 한다
	ANN 이 발전되어 Deep Learning 이 되었다
	deep learning < machine learning < ai
	google tensorflow https:// 'a neural network playground'
	regression, classification: 숫자 조정, 분류
	hidden layer 의 neuron 은 선 하나 하나를 의미한다
	여러 neuron 으로 형태로 구분해낸다
	가중치와 bias 로 선이 그려진다
	voice, non_voice(music)
	화자 인식, 음성 인식, 음성 합성
	소리를 여러 파형으로 분할
	푸리에, 스펙트로그램 (소리를 분할)
	자연어 처리는 앞 뒤, 등 주변 단어를 고려한다
		주변 벡터와 비슷한 벡터로 인식한다
	transformer papef
	sound -> encode (number) -> decode (human word)
	local optimal
	학회
}
- 이런.. 오늘은 terminal 이 평가 프로그램 실행 중 튕기는 현상으로 인해 디펜스를 원활히 하지 못했다.. 확인해보니 하드디스크의 용량이 다 차서 그랬던 것 같다.. 다음부터는 이런 상황에 하드디스크 용량을 잘 확인해보도록 하자..
- 나는 exit_code 도 잘 관리를 해뒀으니 문제가 발생하면 exit_code 를 확인해봤어도 굉장히 훌륭한 방법이었을 것 같다!!
- 디펜스 등록 이후에 문제를 발견했다면 빠른 취소보다는 디펜스를 한 번 해보는 게 도움이 될 것 같다



2021-06-23

- 감정을 잘 모르는 것이 아니라 이해하는데 시간이 좀 걸리는 것 아닐까?
- 나는 처음에는 다 괜찮은 것처럼 말해놓고 나중에 가서는 딴 소리를 하는 것 같다?
  - 나는 내 생각보다 그렇게 다른 사람의 의견을 다 수용할 수 있는 사람이 아닌 것 같다
- SIGUSR1 의 handler 를 호출하고 SIGUSR2 로 interrupt 를 하고 다시 SIGUSR1 signal 을 줬더니 반응이 없었다
  - handler 내부에서 empty mask 를 가진 sigaction 으로 새로운 sigaction 을 설정해주었지만 그럼에도 SIGUSR1 signal 에 interrupt 되지 않았다



2021-06-22

- minilibx
  - https://github.com/qst0/ft_libgfx#minilibx
  - https://harm-smits.github.io/42docs/libs/minilibx
- semaphore 는 thread 에서도 사용할 수 있었던 것으로 기억하는데, process 간에서도 사용할 수 있는 건가? 애초에 process 간에도 같은 메모리 공간의 변수를 사용할 수 있나? 그럼 반대로 mutex 는 process 간에 사용될 수 있나?
- 주석을 곳곳에 넣어서 언제나 완성된 코드를 유지하도록 하자! (pseudo 코드지만)



2021-06-21

- 생각을 못했던 부분을 지적당한다면 순간 당황을 할 수 밖에 없다. 나는 생각을 해본 부분이지만, 상대는 생각을 못 한 부분이기 때문이다. 이 경우 상대방에게 생각 할 시간을 넉넉하게 주는 것이 좋을 것 같다



2021-06-20

- 통신 장애
  - 1. 잘못된 값이 전달: checksum 으로 확인
  - 2. NAC 를 사용하는 경우 오작동으로, 정상적인 상황에서 데이터 수신 중에 NAC 전송
    - NAC 는 전송 실패 확률이 낮은 경우 사용하는 acknowledge flag 인 것 같다. 매번 ACK 를 사용하지 않아도 되어 속도를 조금이나마 높일 수 있을 것 같다. 나의 경우 signal 이 사라지는 경우도 존재하는 등 전송 실패 확률이 높기 때문에 NAC 를 사용하지 않는 것이 좋겠다
- 내가 도와준다고 하는 것이, 상대는 항상 좋게 생각하는 것은 아니다
  - 도와주고 싶다면, 상대가 도움이 필요한지를 먼저 물어보는 것이 예의이다
- leaks 가 정상적인 상황이 아닌 것 같다. leaks 는 대상 프로그램의 실행을 잠시 block 해두고 검사를 진행하는 것은 아닐까?
  - 말일 그렇다면 signal 로 인해 발생한 SIGUSR1 handler 가 leaks 로 인해 block 상태에 놓이고, 이 상태에서 client 로부터 SIGUSR1 이나 SIGUSR2 가 입력되었을 때 이 signal 을 무시하게 되면서 신호가 씹힐 수 있다
- 일반적으로 interrupt 가 되어 실행되는 함수는 끊기지 않고 실행되거나, 그 함수가 반환되어야 원래 하던 일이 실행되기 때문에 가능하면 가볍게 구성하라고 한다. unix signal 의 경우는 우선 실행될까? 아니면 system 에 의해 여타 thread 와 마찬가지로 처리될까?
- signal handler 가 실행중인데 block set 에 지정한 signal 이 들어올 경우 이를 1 회에 한하여 들어왔음을 체크해두었다가, 낮은 순서대로 handler 를 호출한다
- signal handler 내부의 system call 은 signal 로 fail 하지 않는다
- mask 로 block 되지 않은 signal 이 들어오면 signal handler 를 실행중이더라도 system call 이 fail 한다
- BIT_WAIT_INTERVAL 은 bit 가 손실된 것을 막아야 한다. 이것이 bit 의 늦은 전송을 막는다면 정상적인 상황도 error 로 간주되며 속도가 저하될 것이다. 따라서 일반적으로는 정상적으로 손실 없이 전송될 것이기 때문에 (손실률이 낮기 때문에) 이 수치는 높게 설정하여 실수로 bit 가 늦게 들어 오는 경우에 발동되지 않도록 해야 한다 (비트 손실 발생 패킷 빈도가 1% 라면 bit 전송 간격 / 1% 정도?)
- sample 을 통해 bit 손실률과 packet 전송 실패율을 계산하여 각 interval 에 적용하는 것도 좋겠지만, 이 프로젝트에서 요구하는 사항은 아니니, 이정도로 하고 마치자
- 나는 말을 하는 사람이 말을 구체적으로 해야 한다고 생각했고, 상대는 말을 듣는 사람이 부족한 부분을 질문을 해야 한다고 생각했다
  - 둘 다 맞는 건데, 나는 질문을 하지 않았고, 상대는 말을 정교하게 하지 못했다



2021-06-19

- 상대가 무시 당한다는 느낌을 받지 않게 하기 위해서는 내가 계속 말을 해야 한다
  - 1. 목적 잊지 않기
  - 2. 상대가 물었으면 그에 대한 답을 하자 (상대가 그 말을 한 표면적인 의미부터 제대로 이해하자)
  - 3. 실수는 빠르게 정정하자 (이것도 가능하면 말로 정보를 많이 주는 것에 속한다)
  - 4. 머릿 속으로 생각만 하지 말고 말로 전달을 해야한다 (무슨 생각을 하고 있는지 상대방에게 공유해야한다)
  - 5. 그럼에도 불구하고 불필요한 말은 하지 않는다
  - 6. 말은 항상 쉽게 해야한다 (괜히 꼬거나, 나쁜 것 처럼 말하고 좋은 말을 하거나, 반대로 좋은 것 처럼 말하고 나쁜 말을 하거나 하지 말자, 이해할 수 없으면 재밌지도 않다, 상대는 불안하기만 할 것이다)
- 나와 비슷하게 생각하는 사람은 대화가 잘 통할 것이다. 반대로 사고의 흐름이 다른 사람과는 말이 잘 통하지 않을 것이다
  - 대화가 잘 통한다는 것은 바로 전에 나눈 대화 다음 대화서 서로 어느 정도 예측 가능한 방향으로 진행되는 것이다
  - 또한 서로 전달하는 말에 들어 있는 정보의 양이 서로 불편하지 않고 납득할만한 양일 것이다
- 다른 프로그램이 같이 동작하면 기본으로 설정한 BIT_SEND_INTERVAL 을 넘어가는 interval 이 발생할 수 있다
- SIGUSR 의 특징인 것일까?
- infinity_leaks 를 실행하니 signal 을 그냥 출력만 해도 씹히는 현상이 있다
  - 00100000000000000000000000000000100000000000000000000000000000001010101001101100100000000000000001100101100100110111111111111111 (앞에 한 번 001 만 출력되고 다음 전송은 제대로 출력됨)
- 실패할 때 NAC 를 전송하여 재전송을 요청하는데, 그냥 가만히 있고, client 가 ACK 를 받지 못할 때 데이터를 재전송하도록 하면 어떨까?



2021-06-18

- 'echo "obase=2; $var" | bc': 숫자를 2 진수로 출력하기
- 'echo "$((2#<binary number>))"': Binary 를 decimal 로 출력하기
- 'echo "obase=10; ibase=2; 10" | bc': obase 가 ibase 보다 먼저 나와야 한다
- bfs 와 lss 의 구조와 방식을 설명하는데 조금 더디다는 것을 깨닳았다
- 스스로 생각하고 대답하도록 물어보고 난 후의 대답에는 상대가 더 그것을 자신의 생각이라고 여기고 인정하게 된다
- 주어진 질문을 주체적으로 해석하여 답을 내는 것은 중요한 기술이다. 하지만 사람과 대화할 때 이 기술만 사용할 필요는 없다



2021-06-17

- 1. 사용 사례, 어떻게 사용할지를 조사하여 데이터 확보하기
  - 주의: 사용 가능한 모든 케이스가 아니라, 소요 시간이 가장 짧은 최고의 사례를 모아라
- 2. 구현 및 테스트
- client 가 pid 를 전달할 때 checksum 오류가 발생하면 서버의 NAK 신호도 오지 않고 client 가 pause 에 빠져버리는 문제
  - receive signal 도 출력해보면서 pause() 가 왜 안 풀리는지, 어떻게 둘 다 puase() 가 될 수 있는지 알아보기
    - client 가 pid 를 전송한 후 pause 에 빠져서 server 가 client 에게 packet 을 보내지 못했다
- sigaction 의 3 번째 인자: 기존 처리 방법을 저장할 struct sigaction 의 주소



2021-06-16

기존에 정의해 놓은 structure 의 구조를 변경할 경우 할 작업이 많아진다. 이를 자동화해도 재밌을 것 같긴 한데, 지금 상태에서 다른 사람들은 이를 어떻게 해결하고 있을까?



2021-06-15

- 종종 대화 중에 서로 다르게 이해하는 '같은' 단어를 사용하여 혼동이 생기곤 한다
  - 전문 지식을 전달하는 글도 어떤 단어에 보다 많은 의미를 부여하여 사용하기도 한다
    - 가령 'block' 이라는 단어를 사용할 때, 단어 그대로 의미의 '막다' 라는 의미 이외에도 'block' 이라는 것을 통한 추가적은 내부 구현을 내포하기도 한다 (어떤 변수가 어떤 값을 갖는다던가)
- pdf 를 작성할 때 제일 앞에 index 페이지를 만들고, 각 페이지마다 쪽 수를 표기하자
- 'kill -SIGUSR1 <pid>' 와 같이 검증된 read/write 도구 하나만 주어져도 새로운 개념에 적응하기가 훨씬 쉬워진다!!
- apple 에서는 unsafe 한 경우 함수 정의에 포함되는 것 같던데 그런 방식도 좋은 것 같다
- 'usleep(13)' 정도까지 전송 에러가 발생했다 (아마 signal handler 함수의 처리 시간과 관련이 있을 것 같다
- 개념 접근 단계
  - 1. 모든 값을 확인해보기 (어떤 변수에 어떤 값이 들어있고, 상수는 실제 어떤 숫자 값인지)
  - 2. 값 변화에 따른 결과 관찰하기
  - 3. 입맛대로 코딩하기
- structure 는 생각보다 순서에 의해 내부 구조가와 크기가 달라질 수 있다



2021-06-14

- level design: 처음에는 버튼을 누르는 수준으로 매우 쉽게 만들더라도 그 버튼에 쓰여있는 글씨 등에는 사실 다 의미가 있다. 이것을 이해하는데에는 하나의 level 을 거치는 것이 필요하다
  - 즉, 하나의 level 에는 단순히 그 목표를 달성하는 것 이외에도, 주변 환경과 정보들의 의미를 이해하는 숨은 목표도 있다
    - 이런 식의 널리 퍼지지 않은 개념을 계속 이해하고 적용하는 것이 중요하다. 이것이 미묘한 차이를 만들고, 이것이 품질의 차이가 된다
	  - 더 나아가 이런 개념을 도입하려는 팀원들을 잘 격력하는 것도 중요하다
  - 시간을 느끼게 해주어야 한다
    - 개념을 설명할 때 그 개념이 실제 사용되는 것을 간접 체험시켜주는 것도 중요한데, 이 때 그 개념에 소요되는 시간이 어느정도일지 전달하는 것이 중요하다
	  - 하루에 한 번 발생하는 개념을 자주 사용하는 것으로 이해할 수도 있다
	    - 이런 괴리가 발생했을 때 어리둥절함 및 무언가 잘못된 느낌을 겪을 수 있다
		  - 만약 개념을 기초부터 이해했다면 스스로 소요 시간을 계산해볼 수는 있다. 이 경우 외부로부터 소요 시간을 입력받지 않아도 괴리감이 발생하지 않으며, 따라서 부작용도 없다
- git 은 변경 내용을 다양한 방법으로 수정할 수 있다
  - 이를 응용해서 적절한 delimeter 로 git commit 을 구분짓고, 필요한 commit 을 골라 적용할 수도 있다!!!!
    - 가령 debug 를 위한 코드를 commit 하고, bugFix 를 commit 하면, debug 를 위한 코드 변경사항을 제하고 bugFix 를 위한 변경 사항만 적용시킬 수 있다
- remote tracking branch 로 branch 를 만들면 해당 branch 의 remote 가 remote tracking branch 가 track 하는 remote branch 로 설정된다
- 'git branch -u <remote tracking branch> <branch>': branch 의 remote branch 를 remote branch 로 설정한다
- c 에서 함수 포인터 타입을 정의할 때, 내부에 인자가 있으면 내부 인자가 진짜 인자고, 외부에만 인자가 있으면 외부 인자가 인자다
  - 'void (*(int))(int)': 'void (*)(int)' 를 반환하고 'int' 를 인자로 하는 함수
  - 'void (*)(int)': 'void' 를 반환하고 'int' 를 인자로 하는 함수
- 프로토콜이 필요한 이유는 두 기기가 정보를 주고받을 때 사용하는 시간과 계산하는 시간 간격이 하드웨어에 따라 서로 다를 수 있기 때문에, 이런 문제를 극복하고 원활한 소통을 하기 위해 서로 약속된 프로토콜을 따른다
  - 서로 안정적으로 통신이 가능하도록 구성된 '프로토콜' 을 따르면 안정적인 통신이 가능하다



2021-06-13

- ':args `find -L . -iname \*.\[hc\]`' in vim
- 저번에 멤버변수의 type 으로 다른 structure 를 사용할 경우 그 structure 의 header file 을 include 해야 했던 것으로 기억하는데, 이를 한 번 더 검증했으면 좋겠다
  - 만약 그래야 한다면 하던데로 header file 에서 다른  structure 를 include 할 때 type.h 파일을 따로 만들어서 타입에 대한 정보를 먼저 주고 실제 header file 을 include 해야 할 것이고, 아니라면 그냥 type.h 파일만 include 해줘도 괜찮을 것이다
- core data 를 다루는 structure 는 의존성을 끊고 잘 캡슐화하자
  - 그래야 여기서도 쓰고 저기서도 쓸 수 있다!



2021-06-12

- ':vimgrep /<word>/g <paths>' in vim
  - ex> ':vimgrep /ft_atoi_push_swap/g **/*.[hc]'
  - ex> ':vimgrep /ft_atoi_push_swap/g %': '%' means filepath of active buffer
  - ex> ':vimgrep /ft_atoi_push_swap/g ##': '##' expanded to represent each of the files from the arglist
- ':cnext', ':cprevious' in vim
- ':cfirst', ':clast' in vim
- ':copen', '<cr>', ':cclose' in vim
- By default, the driver converts a Control-D character at the start of a line into an end-of-file indicator
- In windows, actual EOF character exists
- test 'cat' to figure out the behave of <c-d>
- '<c-v><c-@>' in vim: write NULL character
- 다음 프로젝트를 진행할 때는 요구사항을 우선 빠삭하게 분석하고 시작해볼까?
- 오늘은 또 이상한 메모리 관련 문제가 있었다. 원래 존재하던 메모리의 주소가 계속 지워지는가 값이 0 으로 초기화가 되는 것이다. 그래서 lldb 로 위치를 찾아내고 (그런데 이 과정에서 lldb 는 처음에는 segmentatino fault 가 뜨다가 몇 번 브레이크 걸고 시도하다보면 다음 run 부터는 계속 성공하는 이상한 일도 있었다, 다시 껐다 키면 또 segmentation fault!?), lldb 로는 이해할 수 없는 일이 일어나서 printf 로 값을 출력해보니 확실히 특정 함수 호출을 기점으로 이상한 값이 적용되고 있었다 (특히 더 이상한 것은 그 함수는 문제의 구조체를 받지조차 않는다는 것이다). 문제의 원인은 할당하지 않은 변수를 free 해서 벌어진 일이었다. 그 변수에는 임의의 (어쩌다가 무조건적으로 특정 구조체의) 값이 들어있었고, 그 주소를 free 하자 필요한 구조체가 초기화된 것 같다. 그래서 해당 변수를 특정 구조체 안에 넣어서 구조체가 할당, 해제 될 때 직접 관리하도록 하여 불안전한 값이 들어가는 것을 방지하였다
- settings set target.input-path <path>



2021-06-11

- alias 는 read-only 인 constant 고, variable 은 read-write 인 variable 이다
- local repository 는 'git branch -m <old_branch> <new_branch>' 로 이름을 쉽게 변경할 수 있지만, remote branch 에서는 이가 허용되지 않는다
- 'du -sh <path>': Print disk usage of 'path' directory or file with human-readable
  - 기본적으로 파일을 위한 디스크 공간은 (클러스터 맥에서는)  4.0K 를 한 단위로 제공된다
    - 1 byte 만 사용해도 4.0K 를 할당 받는 것
  - 'du -c': Display a grand total
- 'sort -n': Sort fields numerically
- 'seq 1 10 | sort -nr': Display 10 ~ 1
- 'sort -t <character>": Use character as seperator
- 'bluprint' branch 를 작성할 때는 제대로 된 기능을 수행하는 것이 아니라 default 로 정의된 constant 값을 직접 적용하는 정도로 구현해둔다
  - 그리고 실제 구현해야할 목록에 넣어둬서, 현재 작업이 필요한 목록을 항상 최신으로 유지한다
- 'main' branch 의 '/.project/' 에는 merge 해야할 사항을 기록해둔다
- '!=' 이나 '==' 은 처음 이후 else 보다 판단문 자체로 인한 분기를 강조한다
- 함수의 이름은 그 함수가 어디에 초점을 맞췄는가로 정한다.
  - 함수의 기능이 중요한 것인지, 함수가 반환하는 값이 중요한 것인지
  - 또, 가독성을 높이기 위해 함수의 이름은 거시적 관점으로 결정하는 것이 좋다
- 모든 null 입력에 대한 guard 를 하는 것보다, 필요에 따라서는 error 를 발생하도록 하는 것이 문제 지점을 탐색하는 데 유리할 수도 있으르 것 같다
- ':args `find . -iname \*.\[hc\]`' in vim



2021-06-10

- shell parameter expansion
  - 'repositories=(${repositories/#/$git\/})'
- 'set -- $vimsession; vimsession=$1': Get first word from string
- '`.' in vim: Takes cursor to the position where you made the last change
- '+' 와 '-' 로 증감이 가능한 변수 'var' 가 있다, 이는 생물인가?
- ':cd %:h' in vim: See ':help expand'
- 'seq' in cli



2021-06-09

- 어떤 프로그램 실행 전에 항상 어떤 코드를 실행시키도록 하는 방법
  - 1. precmd_function 목록에 추가하여, 모든 command 에 대해 선행 작업을 하도록 한다
    - 'precmd_function+=( precmd_vcs_info )'
  - 2. alias 로 shadowing 하여 reculsive 를 막으면서 특정 작업을 선행하도록 작성한다
    - ex> 'alias ls="ls -Alp"'
  - 3. 목표 프로그램이 실행될 때 선행적으로 하는 작업이 있다면 원하는 코드를 수행하도록 작성한다
    - ex> '.zshrc', '.vimrc'
- 'git config --edit --global': Open global git config file
- 'git config --get --global core.excludesFile': Show the value of variable
- set, type, typeset, alias, env, declare
- function 을 propagate 하여 사용해보려고 했으나 FPATH 가 기본적으로 subshell 에 전달되지 않고 이를 '.zshrc' 없이 구현하는 방법을 찾아보았으나 정보가 없어서 포기하기로 한다
- function 을 일절 사용하지 않고, subshell 에도 특정 기능을 할 수 있도록 하기 위해서는 '.sh' 파일을 작성하기로 했다.
- shell script 에는 c 에서 exit 과 같이, 실행 중이 프로그램 자체를 나가는 역할을 구현하기가 어렵다. 그래서 언제나 프로그램을 종료할 수 있는 c 와 다르게 깊이를 주지 않고 source 를 이용하여 서로가 서로를 호출하도록 작성한 뒤, exit 으로 현재 shell 을 종료하는 방향으로 진행해보자 (return 은 실행중인 sh script 를 닫는다)
- shell script 의 if 문은 마치 하나의 script 처럼 판별식의 인자를 $1 에 넣는다
- aux 에서, 필요한 파일을 alias 하고는 싶으나 zsh 을 호출해서 사용하고 싶다 (exit 하고 싶어서)
  - '.zshrc' 와 'aux' 에서 공통적으로 사용할만한 것들을 따로 빼서 두 파일이 모두 호출 가능하도록 구성해보자
    - 그런대 'aux' alias 는 둘이 서로 다르긴 하다..
- 'a=(${(s/:/)string})'



2021-06-08

- 'c rename t_sort t_sort_type'
- 'basename 'git rev-parse --show-toplevel''
- ':h <option>' in vim: Search help page for vim
- 'env': List exported environment variable
- 'set': List local environment variable
- '>' 나 '<' 는 파일을 input 으로 읽는다
- '|' 는 앞 command 의 stdout 을 뒤 command 의 stdin 으로 준다
- 'xargs <utility>' 는 stdin 을 utility 의 인자로 하여 실행한다
- 파일로부터 직접 읽고 쓸 때는 꺽쇠를, 다른 처리를 한 결과를 입력으로 할 때는 파이프를 사용한다
- alias 정의 안에 $() 로 다른 프로그램을 실행하면 실행 시 처음 한 번만 프로그램을 호출하여 값을 저장한다
- alias 로 특정 파일을 호출할 때, 정확한 위치를 적어주는 것이 아니라 대상을 search 할 directory 를 적어주면 편할 것 같다
- zsh 뒤에 인자가 여러개이면 가장 처음 인자만 실행된다
- 'vimsession' 이 현재는 새로운 zsh 을 만들고 그 안에서 session 을 여는 것 같은데 굳이 그럴 필요가 없을 것 같다
- dirname basename absoulte relative path realpath
  - 'dirname <path>': Return directory name of path.
  - 'basename <path>': Return base name of path. (<path> = <dirname>/<basename>)
- shell script
  - '$0' first word of command string
- 'find' command 의 option 중 '-name' 은 case sensitive 하고 '-iname' 은 case insensitive 하다
- basename 의 버그: 인자가 2 개 일 때 첫 번째 인자만 처리한다
- 'for word in hello world; do echo $word; done'
- '<C-k>' in cli: Delete to the end of the line
- '<C-w>' in cli: Delete backward to the beginning of the word
- '<C-t>' in cli: Transpose two characters
- '<S-Command-double_click>' in terminal: Select path or URL
- '<Command-e>' in terminal: Find selected word
- '<Command-double_click>' in terminal: Open URL
- 'drag-and-drop file from finder' in terminal: Add the complete path to a file
- '<O-click>' in cli: Reposition the insertion point
- 셸 스크립트를 실행할 때는 새로운 셸에서 실행하는 것을 원칙으로 하자(모듈화)
  - 단, alias 설정등 셸 윈도우를 처음 띄울 때 필요한 설정은 source 로 실행한다
  - 간단한 함수 수준도 모듈화해서 사용하는 것이 좋겠다. 정말 빈번히 사용하는 것만 
- set, typeset, alias, env
- function 은 실행중인 shell 상에서 호출되면, 블럭 안에서 바꾼 변수의 값이 밖에서도 유지된다
- all 을 .PHONY 에 적어두지 않았을 때 all 이라는 이름을 가진 파일이 존재하는 지는 의존성이 없고, 의존성에 명시된 파일이 존재하는지 확인하여 없으면 rule 을 실행한다
- rule 의 dependency 와 상관 없이, .PHONY 에 명시했는지 상관 없이, 파일이 없는데 실행하고 나서 파일이 생성되지 않고, 실행 가능한 recipe 이 존재하면 rule 이 실행된다
- 통찰력있는 분석을 제시했는가, 그러지 못했는가, 이는 한끝 차이지만 중요한 차이이다



2021-06-07

- [stackoverflow/How can I delete a newline if it is the last character in a file?]
- how to implement hash function?
- 'git ls-remote <remote>': 로 romote repository 를 list 할 수 있다
- 'bash' 에서는 'POSIX sh' 과 달리 '[[' 를 사용할 수 있는데, 이를 사용하면 내부에서 변수를 사용할 때 double quote 를 사용하지 않아야 한다
- '$?' 는 이전 판단문의 결과를 출력한다
- 'git tag -d <tag>'
- 'git push -d <remote> <tag>'
- 'git ls-remote --tags'
- 'git show <branch>:<file>'
- 'git checkout <branch> -- <file>': also do stage
- ssh 관리는 env 가 해주나?
  - 지금은 따로 관리 안해주고 직접 ssh 구축 후 git clone 하게 되어 있는데 이후에는 봐서 없으면 해달라고 요청 메세지 보내고 다시 시도해주세요 > 이런 식으로
  - 그리고 환경 구축하는 script 를 모듈화할 수 있는지 생각 해보자
- [nvie/A successful Git branching model](https://nvie.com/posts/a-successful-git-branching-model/)
  - 여기에서 말하는 git model 은 dev 에 feature 들을 merge 할 것을 목표로 한다
  - 만약 나의 seoul42_project repository 처럼 각 프로젝트(== feture branch) 를 굳이 하나의 main branch 로 통합할 필요가 없다면 발산형으로, 브랜치 끝을 tag 로 장식해두면 좋을 것 같다
    - 작성한 feature branch 들을 통합해서 하나의 실행파일을 생성하는 것을 목적으로 하는 경우 main branch 로 merge 하는 것이 맞을 것이다
- 작업 수행 흐름
  - 1. 예측한다
  - 2. 시도한다
  - 에측하지 못한 일이 발생했을 때 행동 방침
    - 모든 사람이 해당 사안에 대한 의견을 제시한다
    - 최종적으로 실현 가능한 유용한 방안을 추려낸다 (갯수는 상관 없다, 납득 가능하면 상관 없다)
    - 기록으로 남겨두고 한가지를 선택해서 시행 (다수결을 하든 랜덤을 하든, 어차피 다 경험이 된다)
    - 이후 좋았는지 나빴는지 회고 (및 기록을 통해 경험 축적)
- 도시를 건설한다고 생각해보자
  - 우선 조악하더라도 기능적으로 '도시' 라고 부를 수 있을 만한 것, 혹은 도시를 '흉내'내는 것을 만든다
  - A 건물과 B 건물을 각각 짓고 있는데
  - B 건물이 A 건물의 상하수도관을 연장해서 사용하려고 할 때
  - A 건물이 상하수도관을 수정하려고 하면 B 건물에도 영향이 간다
  - 그럼 이를 미연에 방지하기 위해 전체 상하수도관 관리를 분리해두고
  - A 건물과 B 건물은 상하수도관 infra 위에서 생성한다고 할 때
  - 만약 B 건물이 상하수도관을 바꾸고 싶다면 상하수도관을 바꾼 후 이를 rebase 해서 사용하고
  - 상하수도관을 사용하는 모든 대상은 바뀐 상하수도관을 rebase 해서 사용하면 될 것이다
    - 근대 그러면 B 건물 담당자가 바꾼 상하수도관 변경 사항이 A 건물에 영향을 주면 어떻게 하지?
    - 거기다가 상하수도관 뿐만 아니라 건물을 위한 전기, 도로, 등 많은 infra 들은 어떻게 의존성을 두지?
  - 즉 모든 infra 위에 건물을 짓는 것이 아니라
  - infra 와 건물이 같은 계층급의 feature branch 에 속하게 되는 것이다
  - sudo function 만 작성해두고 이 sudo function 을 implement 하는 feature branch 를 만드는 것이다
  - release branch 는 외부 공개를 위한 
  - dev 는 모든 feature branch 의 base 이다
  - feature branch 들의 기능을 사용하는 app logic 을 작성하는 코드 또한 따로 feture branch 를 만들어서 작성 후 merge 해야 할 것이다
    - 이 때 이 branch 는 우선 sudo function 을 사용한다
  - 만약 새로운 feature branch 의 요구가 필요하고, 이를 기반으로 하는 sudo code 가 dev 에 추가되어야 할 경우에는 dev 자체를 update 한다
  - 그러면 다른 feature branch 들은 새로운 sudo code 를 사용할 수 있게 되고, 동시에 sudo code 를 위한 feature branch 를 만들 수 있게 된다
  - feature branch 가 완성되면 dev 는 그 branch 를 merge 하고 임무를 마친 feature branch 는 delete 한다
  - release tag 는 외부 공개용으로 완성된 commit 에 tag 한다
  - hot fix 가 있을 경우 hot fix 를 적용하고 hot fix version 으로 tag 한다
  - prerelease branch 는 차세대 공개할 release version 을 완성시키기 위해 버그를 수정하고 작동을 테스트해서 마무리하는 branch 이다
  - prerelease branch 의 목표를 달성하면 release tag 를 붙이고 hot fix 와 유사하게 dev 와 merge 한 후 계속 dev branch 를 rebase 추적한다
  - dev branch 는 차세대 release version 을 위한 feature 들을 수합하고 대기한다
    - 차세대 prerelease branch 도 항상 존재한다
  - 만약 건물 A 와 건물 B 를 위한 feature branch 를 만들어서 사용하다가 상하수관을 분리해야하는 일이 발생한다면
    - 1. dev 에 sudo code update
	- 2. sudo code 를 implement 하는 feature branch 생성 및 기존의 open branch 들을 최신 dev branch 로 rebase
- git 을 연습하는 용도의 도시 건설 project 가 있으면 재밌겠다
- apple 의 통합 기능은 연결이 가능한 환경에서는 훌륭한 사용 경험을 선사하지만 조금이라도 문제가 생기면 고질적은 치유 불가능한 문제가 되어 버린다
  - ex> 클러스터 컴퓨터의 apple id 적용 시 나타나는 버그
    - 이런 경우 직접 관리 가능한 방법이 있으면 유용하다
- 시간을 신경쓰지 않고 집중하기 위해 시야에 들어오던 시계를 제거했더니 효과가 좋았다. 무심결에 시계를 보았는데 없어서 시간을 알 수가 없어서 좋았다
- 꼼꼼해지는 과정은 마감을 여러 번 거치면서 학습하는 것이다. 매 번 꼼꼼하기 위해 노력하는 것은 그다지 효율적이지 않을 수 있다
  - 기준 자체는 높게 제시하되, 제출물을 제출할 때에는 제한이 없게 해서, 여러 번 시도하도록 유도하자
- 내가 평가를 한 시간 씩 진행하면 한 숨을 내쉬기 시작하는 분이 한 분 있는데, 어떻게 하는 것이 옳바른 해결책일까?
- 에어컨을 켜 놓은 후 창문이 열려있는 상황에 대한 해결책
  - 누군가 에어컨을 켰다, 누군가 창문을 열었다
  - 어어컨을 끄는 사람은 없다, 창문을 닫는 사람도 없다
- hard link 는 같은 inode 를 사용하는 파일을 생성하는 것이다
  - 그런데 이것은 file system 의 구체적인 특징이기 때문에 OS 공통의 file system 을 추상화한 git 의 경우 hard link 를 file 로서 기록하고, symbolic link 는 구체적인 inode 연결 이외의 공통적인 file system 특징이므로 일반 파일과 구분하여 기록한다



2021-06-06

- 삭제된 'remote branch' 를 track 하는 'remote-tracking branch' 가 local 에 남아 있을 때 없애는 방법: 'git branch -dr origin/<branch>'
  - '-r' option 은 'https://git-scm.com/docs/git-branch' 에서 확인할 수 있으며 'remote-tracking branch' 를 의미한다
- 확실히 void * 를 사용해서 generic 한 값을 담을 수 있도록 구성하는 것이 코드 재사용에 굉장히 큰 역할을 하는 것 같다. C++ 이나 swift 처럼 generic type 을 위한 코드를 생성해주는 기능이 없다면(추측) 컴파일 단계에서 처리 불가능한 부분을 가능한 run time 에서 적용이라도 하기 위해 'void *' type 으로 content 를 정의하여 generic 한 structure 를 구성해보도록 하자
- 에어컨을 틀고 싶다면 창문을 다 닫았으면 좋겠다! (환경을 소중히!)
- 비교문을 작성할 때는 대소 관계에 따라 작은 것이 왼쪽, 큰 것이 오른쪽에 작성하는 것이 '아니라' 주어 역할을 하는 것이 왼쪽, 비교 값이 오른쪽에 두도록 하자 -> 문장처럼
- big o 계산 -> 수열의 합, 시그마 계산, 수열을 함수로 만들고 적분
- 다음에는 에러 전용 구조를 만들도록 하자



2021-06-05

- 프로그램 함수 작성 시 함수의 종류는 크게 2 가지로 나눌 수 있다
  - 첫 번째는 기능을 구현하는 함수이다
    - 추상적인 동작이 중요한 것이 아니라, 하나의 구체적인 기능을 구현하기 위해 작성하는 함수이다
	- 이런 함수는 자신이 수행하는 기능을 중심적으로 서술해야 가독성이 좋다
  - 두 번째는 추상적인 동작을 구현하는 함수이다
    - 구체적인 동작이 작성되어 있지는 않지만 다른 함수들을 호출하면서 추상적인 동작을 수행한다
	- 이런 함수는 전체적인 흐름을 중심으로 서술하면 가독성이 좋다
- 빡센 최적화를 할 때는 내가 함수의 입력값과 출력값을 제한하면서 특별한 case 의 guard 를 넣지 않을 수도 있지만, 프로그램의 크기가 조금씩 커지고, 모든 것을 control 할 수 없는 경우, 다 기억하지 말고 적절히 guard 를 하도록 하자
- 최적화 전용 기능은 주 작업과 상관이 없는 내용이므로 분리하여 껐다 켰다 할 수 있도록 구성하면 좋은 것 같다
- 프로그램을 확장하는 방법 1. 원래는 상수, 변수를 사용하던 부분을 변수, 함수를 사용하도록 바꾼다
- '=' 는 강조하는 기능이 있다
  - 만약 '=' 를 사용하면 해당 부분이 강조되는 것이고, 사용하지 않으면 이후 부분이 강조된다
- create, edit, delete
- 실제 파일을 삭제하는 'git clean' command 가 실행되기 위해서는 '-f' 옵션을 줘야 하도록 만든 것이 마음에 든다. 마치 '정말 실행하시겠습니까?' 라고 묻는 것 같이 보인다
- 저 지랄맞은 현충일 캘린더 알림은 왜 계속 뜨는거지?



2021-06-04

- 전에 한 번 빼먹고 특별한 값에 대한 basis_vector 적용을 그냥 넘긴적이 있는데, 이로 인해 오늘 원기둥을 출력할 때 0,1,0 을 normal 로 하는 원기둥의 위, 아래 면을 그릴 때 제대로 출력되지 않는 문제가 있었다. 새로운 기능을 구현할 때는 그 기능을 구현하기 위한 sudo code 를 작성하고, 더 필요하다고 생각이 나면 그 즉시 코드에 sudo code 를 바로 바로 추가하여, 구현하려고 생각만 하고 잊고 마는 일은 없도록 하는 것이 좋겠다
- 지금 bfs 와 lss 를 위한 데이터 및 인스트럭션을 각각 작성했는데, 이것 외에도, 마치 서버와 클라이언트처럼, 서버역할을 하는 데이터는 공통으로 두고 이를 통해 bfs 및 lss 전용 structure 를 다뤘으면 어땠을까?
- 제발 키보드 좀 가져오자!! 클러스터 키보드 고장난거 걸리면 너무 불편하다!!
- push_swap 의 경우 instruction 과, 가장 알맞은 구조를 작성하고, 이 구조를 가져와 사용하는 형식으로 진행했으면 더 좋았을 것 같다
- 자동으로 .c-.h pair 생성하는 프로그램
- typedef 보다 structure 를 사용하면 확장성 측면에서 유리하다
  - typedef 는 구조체와 달리 새로운 맴버 변수를 추가할 수 없어서, 이런 변경을 해야할 때는 큰 노동력이 요구된다
  - 반면 structure 는 쉽게 새로운 맴버 변수를 추가할 수 있다
- 항상 처음에는 확장하기 쉬운 유연한 구조로 프로그램 작성을 시작하자
  - 프로그램이 배포되기 전까지는 계속 계속 계속하여 프로그램이 유기적으로 변할 가능성이 있다
  - 후에 배포 전후로 성능을 개선해주도록 하자
- buffer 가 자신 만의 특수한 수정 기능을 가지고 있다면, 이름을 단순히 buffer 로 할 것이 아니라 접두사나 접미사를 붙이는 것이 좋을 것 같다
- instruction 을 화면에 출력하는 print 함수 파일도 따로 있었으면 좋았을 것 같다
- 맴버 변수의 데이터 타입은 선언만 되어서는 정의하는 것을 컴파일러가 에러를 발생시킨다. 꼭 구현을 include 해야 한다
- 텍스트를 생성하는 작업장이 있었으면 좋겠다



2021-06-03

- 'git show <commit hash>:<path/of/file>': Display content of the file to stdout.
- 'git checkout <branch or commit> -- <path/of/file>': Get file from another branch or commit.



2021-05-31

docker 를 run (또는 start) 할 때 실행한 명령이 종료되면 다른 실행중이던 명령도 다 종료되면서 container 가 exit 상태가 된다



2021-05-30

- 어떤 대상과 비교를 할 때는 그 대상과 설명하는 내용하고의 공통점과 차이점을 가능한 한 구체적으로 해야 좋다
  - 예시> 신분증 제시와 ssl
    - 공통점: 제 3 자로부터 공인 받은 것으로 자신의 신분을 객관적으로 알린다
	- 차이점: 신분증은 고객이 서비스 제공자에게 자신의 신분을 알리고, ssl 은 서비스 제공자가 고객에게 자신의 신분을 알린다



2021-05-27

- 어느 정도까지 최적화를 진행해야 하는가?
  - 사용하는 프로그램에 따라 정도가 다르다고 생각한다
  - 각 프로그램마다 가독성을 최우선으로 여기고, 그 다음에 최적화를 고려하도록 하자
  - 가독성이 떨어지는 최적화는 해당 언어를 사용하여 프로그램을 작성하는 프로그래머의 역할이 아니라 언어를 컴파일하는 컴파일러를 제작하는 프로그래머의 역할이다
0. 원형 양방향 모델, front 만 존재
1. 정렬한다
2. 거꾸로 돌면서 한바퀴를 순차적으로 돌 때 가장 큰 수부터 차례로 체크하여 숫자를 얼마까지 만나는가?
3. 그 수보다 하나 작은 수가 나올 때까지 더 작은 수는  b 로 이동시킨다, 이 때 ra 로 돌린다
4. 그 수는 b 의 하단에 보관하고 분류가 끝나면 a 로 옮긴다
5. 점차 작은 수를 가져온다, 이 때는 rb 또는 rrb 중 빠른 것을 선택한다
6. 만약 어떤 수를 탐색하던 중 그 수보다 바로 하나 작은 수를 먼저 마주치면 a 의 하단에 저장해놓으면 좋지 않을까?



2021-05-26

- 탐색의 제한을 하는 부분은 어디에 둘까?
  - instruction 과 별개로 작동했으면 좋겠다
  - 'check_should_instruction_pa() -> pa()' 처럼 instruction 을 실행할지 건너뛸지를 체크하는 함수를 instruction 전에 실행하는 것이 좋겠으나, 성능상 우선 통합하도록 하자
- 어떤 구조체를 생성할 때, 만약 값이 밖에서 자유로운 값을 설정해주려면 인자로 받도록 하고, 주변 환경에 구애받지 않는다면 내부에서 생성해주도록 하자
- 구조체도 이름이 여러개면 좋을 때가 있는 것 같다
  - branch-node 개념을 list-element 로 구현함
    - 외부에서는 branch-node 가 좋고 내부적으로는 list-element 가 좋다
- array 만 heap 에 할당하고 그 외에 정적 크기를 갖는 list, queue 등은 stack 에 할당할까 생각해 보았는데, 매번 새로운 스택에서 list 와 queue 와 array 의 주소 값을 연결해줘야하는 overhead 가 존재해서, 그냥 heap 에 다 할당하는 것이 좋을 것 같다 (한 번 만들면 프로그램이 끝날 때까지 해제 없이 사용하기 때문에)
- 다음 프로젝트는 generic 한 구조로 진행해보자. 우선 성능을 신경쓰지 않고 작성한 후, 문제가 된다면 시간 복잡도가 가장 복잡한 곳부터 수정하는 방식이다
- 아무 값도 넣지 않아도 기본적으로 작동하도록 만들자
  - 직접 값을 설정하도록 만들고, 딱 한 번만 값을 쓰도록 여러 함수에 나눠놓았더니, 어떤 값이 설정됐는지 안됐는지 확인하기가 무척 어려웠다
- count 의 증가는 앞에서, 혹은 뒤에서?
  - while 에서 자연스럽게 1 씩 증가하는 경우 convention 적으로 뒤에 배치하도록 하자
  - 그 외에는 우선 loop 안에 count 의 증감식을 작성하고, 다른 내부 표현식들의 위치를 결정하자



2021-05-21

- 값을 읽어서 model 을 만드는 정도의, 성능에 critical 하지 않은 경우는 하드 코딩하여 성능 향상을 추구하기 보다는 유연하고 확장적인 추상화 모델을 만들도록 하자
- name convention 을 통일하기 위해 vector3 를 p_vector3 로 하는 것이 더 좋았을 것이다
- [stackexchange/Vim search replace all files in current (project) folder](https://vi.stackexchange.com/questions/2776/vim-search-replace-all-files-in-current-project-folder)
  - ':args <file or directory>': similar 'vim <file or directory>' on cli
  - ':argdo <vim command>': do command to all open file



2021-05-20

[wiki/regular expression](https://en.wikipedia.org/wiki/Regular_expression)
- '.' 은 '\n' 을 제외한 모든 문자와 matching 된다는데 regex 는 '\n' 와 matching 은 안되는 걸까?
  - 여러 주변 환경에 따라 추가할지 말지는 취향이다
[wiki/glob](https://en.wikipedia.org/wiki/Glob_(programming))
- '*': matches any number of any characters including none
- '?': matches any single character
- '[abc]': matches one character given in the bracket
- '[a-z]': matches one character from the (locale-dependent) range given in the bracket
- '[!abc]': matches one character that is not given in the bracket
- '[!a-z]': matches one character that is not from the range given in the bracket



2021-05-18

```zsh
Undefined symbols for architecture x86_64:
  "_bmp_write_image_to_file", referenced from:
      _generate_image in t_application.o
ld: symbol(s) not found for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
make: *** [miniRT_debug.out] Error 1
```
  - 위와 같은 메세지를 띄우며 컴파일이 한참 진행중이다가 완료되지 못하고 끝에 link error 가 발생하는 경우가 있다
    - 이 경우 컴파일러가 해당 함수가 존재함을 function prototype 을 통해 인지했기 때문에 컴파일 에러가 발생하지는 않았지만 프로그램의 binary code 를 생성하기 위해 찾아보니 실제 해당 함수의 binary code 가 존재하지 않는 경우 출력되는 에러 메세지이다
- [linuxconfig/Understanding of ls command with a long listing format output and permission bits](https://linuxconfig.org/understanding-of-ls-command-with-a-long-listing-format-output-with-permission-bits)
  - permission / number of linked hard-links / owner of the file / to which group this file belongs to / size / modification or creation date and time / file or directory name
- directory 를 hard link 로 만드는 것은 간단하지 않다, 그러므로 libft directory 를 hard link 로 만들어서 사용하는 것은 norm 을 벗어나고 나서 생각하자



2021-05-17

-[superuser/How to sort first directories then files etc… when using “ls” in Unix](https://superuser.com/questions/109537/how-to-sort-first-directories-then-files-etc-when-using-ls-in-unix)
  - ls | sort -k1,1 -k9,9 -r
- 화면에 vim 을 10 개 이상씩 가득 띄워놓고 보는 것은 솔직히 썩 바람직한 방식은 아닌 것 같다. 오늘 keynote 로 struct 간의 reference 그래프를 그려보았는데, 이렇게 하고 보니 전체적인 프름이 한 눈에 보였고, 어떻게 추상화할지를 판단하기 훨씬 수월했다 (전에는 거의 불가능하거나 오랜 시간을 들여야만 했다)



2021-05-13

- search keyword
  - architecture
  - underneath
  - underlying mental model and architectur
- line 을 읽는 기능과 split 을 구현할 때, 이미 많은 것을 구현한 miniRT 폴더에서 진행하는 것이 아니라 새로운 모듈을 만드는 장소를 따로 만들어서 진행하고, 기능이 충분히 구현되었다고 생각하면 그 때 합치는 것이 좋을 것 같다



2021-05-07

0x00 ~ 0x01:  2 "BM" as ascii
0x02 ~ 0x05:  4 total size of bmp file in byte (file header size (14) + dib header size (124 in v5) + color array size (width * height * bpp / 8)
0x06 ~ 0x09:  0 reserved, set 0
0x0a ~ 0x0d:  4 offset of color array (138 in v5)

0x0e ~ 0x11:  4 bV5Size: dib header byte size
0x12 ~ 0x15:  4 bV5Width: 가로 픽셀 수
0x16 ~ 0x19:  4 bV5Height: 세로 픽셀 수
0x1a ~ 0x1b:  2 bV5Planes: 1 고정
0x1c ~ 0x1d:  2 bV5BitCount: bit per pixel
0x1e ~ 0x21:  4 bV5Compression: 압축 없으면 0
0x22 ~ 0x25:  4 bV5SizeImage: 온전한 이미지 크기
0x26 ~ 0x29:  4 bV5XPelsPerMeter: 잘 모르면 0
0x2a ~ 0x2d:  4 bV5YPelsPerMeter: 위와 동일
0x2e ~ 0x31:  4 bV5ClrUsed: 위와 동일
0x32 ~ 0x35:  4 bV5ClrImportant: 위와 동일
0x36 ~ 0x39:  4 bV5RedMask: big endian 형식의 argb mask
0x3a ~ 0x3d:  4 bV5GreenMask: 위와 동일한 형식
0x3e ~ 0x41:  4 bV5BlueMask: 위와 동일한 형식
0x42 ~ 0x45:  4 bV5AlphaMask: 위와 동일한 형식
0x46 ~ 0x49:  4 bV5CSType: 42 47 52 73
0x4a ~ 0x6d: 36 bV5Endpoints: 잘 모르면 따라하기, 아마 색상의 한계를 결정
	0000040                               80 c2 f5 28 60 b8
	0000050 1e 15 20 85 eb 01 40 33 33 13 80 66 66 26 40 66
	0000060 66 06 a0 99 99 09 3c 0a d7 03 24 5c 8f 32
0x6e ~ 0x71:  4 bV5GammaRed
0x72 ~ 0x75:  4 bV5GammaGreen
0x76 ~ 0x79:  4 bV5GammaBlue
0x7a ~ 0x7d:  4 bV5Intent: 이 이미지의 의도에 대한 데이터를 담는다. 04 00 00 00
0x7e ~ 0x81:  4 bV5ProfileData: 0
0x82 ~ 0x85:  4 bV5ProfileSize: 0
0x86 ~ 0x89:  4 bV5Reserved: 0

- 코드에 압도되는 것은 좋지 않은 상황이다. 앞길이 막막해지고, 어딜 건들여야할지 바로 보이지 않을 때가 있다
- 코드의 많은 부분에 영향을 줄 경우 2 가지 경우의 수가 있다
  - 오류가 나지 않는 경우: 이 경우는 빠르게 굴러가는 프로그램을 작성할 수 있어 좋다
  - 오류가 발생하는 경우: 이 경우는 끔찍하다. 코드의 너무 많은 부분을 바꾸었기 때문에 어디에서 문제가 발생했는지 알 수 없게 되기 싶상이다
- lldb 로 특정 변수 값이 변경되는 지점을 break 하는 것이 가능 'watchpost'
- lldb 로 특정 frame 으로 이동하는 것이 가능 up, down, frame set
- 나는 위치와 방향에 따른 모든 경우를 출력 가능하도록 구현햇는데, 다른 방법으로 default 상태를 구현하고 이를 평행 이동, 회전 이동 하여 도형의 최종 상태를 출력하는 방법도 있는 것 같다



2021-05-06

- 최적화를 위한 다양한 기법은 멀리서 보면 서로 다 다르고 각각을 공부해야 한다고 생각할 수도 있다. 하지만 하고자 하는 진정한 마음이 있고, 본질을 공부한다면 그것들은 공부하지 않아도 만들어낼 수 있는 것들이다, 라고 생각한다
- t_bmp 가 엔디안을 신경 쓸 필요는 없다. 이미지를 생성하여 서버에 전송할 때 빅 엔디안이면 스몰 엔디안 형식으로 바꾼다던가, 등 작업을 하기 때문에 bmp 는 이렇게 생성된 이미지를 저장하기만 하면 된다
  - 아니다. 이미지의 주소를 받아오면서 얻는 endian 값은 서버의 endian 이기 때문에 이것이 적용된 상태로 이미지를 저장하면 안된다. 현재 프로그램이 작동하는 시스템의 endian 을 토대로 small endian 방식으로 저장하면 된다
  - endian 은 메모리와 관련된 것이라고 한다. 따라서 현 endian 을 자연스럽게 저장하면 제대로 된 bmp 파일이 되지.. 는 않을 것 같다
- 왜 해야하는가, 왜 추가해야하는가
  - 지금까지 만든 것은 어떤 기능을 가지고 있는가
  - 지금까지 만든 것은 무엇인가
    - 새로운 기능을 추가하면 기존과는 무엇이 다른가
	- 꼭 추가해야만 하는가
- 꿈을 꿔라, 그리고 끊임없이 꿈을 위한 목표를 만들어라
0x00 ~ 0x0d: bitmap file header
0x0e ~ 0x11: bV5Size
0x12 ~ 0x15: bV5Width
0x16 ~ 0x19: bV5Height
0x1a ~ 0x1b: bV5Planes
0x1c ~ 0x1d: bV5BitCount
0x1e ~ 0x21: bV5Compression
0x22 ~ 0x25: bV5SizeImage
0x26 ~ 0x29: bV5XPelsPerMeter
0x2a ~ 0x2d: bV5YPelsPerMeter
0x2e ~ 0x31: bV5ClrUsed
0x32 ~ 0x35: bV5ClrImportant
0x36 ~ 0x39: bV5RedMask
0x3a ~ 0x3d: bV5GreenMask
0x3e ~ 0x41: bV5BlueMask
0x42 ~ 0x45: bV5AlphaMask
0x46 ~ 0x49: bV5CSType
0x4a ~ 0x6d: bV5Endpoints
0x6e ~ 0x71: bV5GammaRed
0x72 ~ 0x75: bV5GammaGreen
0x76 ~ 0x79: bV5GammaBlue
0x7a ~ 0x7d: bV5Intent
0x7e ~ 0x81: bV5ProfileData
0x82 ~ 0x85: bV5ProfileSize
0x86 ~ 0x89: bV5Reserved
- BMP format 으로 이미지를 저장하기 위해 file_header[], dib_header[] 등을 만들었는데, 각 데이터의 index 를 define 하여 데이터를 쓰고, 만들어진 배열을 파일에 write 하려고 했다. 그런데 index 로 입력한 값을 그냥 배열 통채로 사용해버릴 때는 문제가 없었지만, 결국 이미지의 width, height 등은 다른 곳에서도 쓰일 수 있기 때문인데 일단은 다른 곳에 있는 데이터를 가져다가 사용하기로 했다 (width 와 height 는 p_image 로부터 등)



2021-05-05

- 테스트 환경 구성하여 테스트 진행
  - 이점: 원하는 값을 넣고 결과 값이 잘 나오는지 확인할 수 있다
  - 디버깅 툴과의 차이점
    - 디버깅 툴은 에러를 잡아내는 것: 실제 프로그램을 실행해볼 수 있지만 테스트에 비해 부담스럽고 값을 원하는데로 마구 넣어보기 번거롭다
- 프로그래머가 하는 일은 글을 쓰는 것이다. 문체도 물론 중요하지만 가장 중요한 것은 얼마나 방대한 세상을 가지고 있느냐 하는 것이다. 그리고 그것을 글로 잘 풀어냈는가이다
- 프로그램을 만드는 과정에는 재밌는 과정도 있고 재미 없는 과정도 있다. 다소 재미 없는 과정이라면 그 과정에 당신의 꿈을 담아라
  - 가령 특정 파일을 파싱하는 기능을 추가하거나, 출력된 이미지를 파일로 저장하는 기능을 추가하는 작업은 지루할 수 있다. 하지만 그것이 불가능한 경우와 가능한 경우를 생각하면서 있으면 정말 좋겠다고 생각을 하는 것이다
- 평면 도형의 normal 과 ray 의 direction_vector 과 수직인 경우 intersects, blocks 는 어떻게 처리해야 할까?
  - 평면 도형의 두께는 0 으로 생각하자
- antialising 말고 테두리 픽셀의 절확한 밀도를 계산해서 출력하면 어떨까?
- rgb 소자들이 뭉쳐 하나의 픽셀 을 보는 것처럼, 여러 픽셀들이 뭉쳐 하나의 점을 볼 수도 있다. 이로 인해 픽셀 단위의 단절된 이미지를 자연스럽게 만들 수 있다
- 기울기가 정확히 축과 평한한 경우 등 double 의 오차로 인해 충돌 여부가 판가름 나는 수도 있다. 이런 경우는 따로 처리하지 않겠다. 처리를 하는 것도 야매로 가능하지 정확한 계산은 불가능해 보인다 (이미 정확히 계산한 결과가 저런 것이다)
  - 마찬가지로, 오차로 인한 그림자 여부도 추가로 잡아주지는 않겠다
- [BMP file format](https://en.wikipedia.org/wiki/BMP_file_format)
  - bitmap 은 더 포괄적인 의미이고 BMP 는 bitmap 중 특정 포멧이다
  - 아마 최적화를 위해 프로그램 내부적으로 사용되는 이미지는 자신만의 bitmap 데이터 타입을 정의하는 모양이다



2021-05-04

- 빛이 평면 위의 점일 경우를 잘 처리해주자
- 일단 돌아가는 프로그램을 작성하라, 그리고 계속 보다보면, 그리고 반복해서 작성하다 보면, 최적화를 할만한 부분이 보인다!
  - 물론 최소한의 계획은 가지고 프로그램을 작성해야 한다
    - (최소한의 계획이라는 녀석은 주관적이다)
- 제대로 표현하지 않으면 어차피 나중에 계속 후회한다
  - 일단 내 잘못이면 나중에 후회할 확률이 높다 문젝 없더라도 사과하는 것이 맞다 그게 맞다
- x 와 z 가 모두 0 인 카메라 orientation 을 받을 때 xz_magnitude 가 0 이 되어 0 으로 나누게 되는 문제



2021-05-03

- 공유의 목적이 아닌 기록 및 보관 용도로는 잘 꾸미는 데에 시간을 투자할 필요가 없으므로 (최소한의 가독성 확보가 목표이다) md 포멧보다는 txt 포멧을 사용하는 것이 유리하다
- 우연히 발견한 것이지만 double 의 오차로 랜덤하게 0 또는 1 을 생성할 수 있을 것 같다
- pow 의 남발을 지양하고 sqrt 와 * 를 사용하자

- geometry 위의 어떤 점 P 가 line 과 geometry 가 만나는 가장 가까운 점인지를 확인하기 위해 intersects 만으로는 부족하다. intersects 는 가장 가까운 k 값을 반환하지만, 가장 가까운 점이 P 일 때 P 를 위한 k 값과 가장 가까운 k 값을 비교하면 double 타입이기 때문에 오차로 인해 같은지 판단하는건 부정확하다. 따라서 도형마다 어떤 점이 도형 위에 있는 점이라고 가정하고, 그 점이 빛을 받는 점인지 확인할 수 있도록 추가적인 함수를 둬야 좋겠다
- reference type 은 instance method 의 첫 인자로 instance 를 받고,  value type 은 instance method 의 마지막 인자로 instance 를 받도록 하면 좋을 것 같다
- vector3_init() 추가
- vector3_cos_theta() 추가
- 빛의 세기는 거리의 제곱에 반비례한다
  - 이 경우 특정 부위는 과하게 밝게 표현단다
    - 이를 해결하기 위해서는 2 차 3 차 반사를 적용해야 한다
- 삼각형은 각도록 점의 위치가 안에 있는지 밖에 있는지를 구분했다



2021-04-11

- 다음 두 함수의 차이가 있을까?

int strlen(char s[])
{
	int i = 0;
	while (s[i] != '\0')
		++i;
	return i;
}

int	strlen(char *s)
{
	char *ptr = s;
	while (*ptr)
		++ptr;
	return (ptr - s);
}

- -1L vs 1UL: unsigned long 타입으로 변환되고 비교한다면 -1L 이 더 크게 된다. 실제는 어떨까?



2021-01-28

클러스터는 예약시스템 지금은 코로나가 심해져서 예약조차 안되는 듯 하다
2.5 단계 밑으로 내려가야 클러스터 사용이 가능하다



2021-01-15

```zsh
% cat display_line.sh
$1 | wc -l
% ./display_line.sh set
      41
% sh display_line.sh set
      41
% zsh display_line.sh set
     145
% set | wc -l
     167
% source display_line.sh set
     167
% bash

The default interactive shell is now zsh.
To update your account to use zsh, please run `chsh -s /bin/zsh`.
For more details, please visit https://support.apple.com/kb/HT208050.
bash-3.2$ set | wc -l
      47
```

- 왜 set 의 결과 값이 달라지는 것일까?



2021-01-14

- 전선이 모든 주파수를 다 통과시키지 못하고 제한된 영역의 주파수만 전달이 가능한 이유가 무엇일까? [youtube](https://youtu.be/1pfTxp25MA8?t=368)
- 디지털 신호도 원하는 주파수를 만들어서 전송할 수 있을 것 같은데 굳이 아날로그 신호로 바꾸어서 전송해야 하는 이유가 무엇일까? [youtube](https://youtu.be/1pfTxp25MA8?t=386)
ttps://opentutorials.org/module/3747



2020-12-25

(T: Think, D: Do)
- T: Ratio of my study and others study
  - Just help others study, and if i get some thought of 'It's not right', then reject it
  - Never present a fish, teach how to get that
- D: More practice the way to use `find` command



2020-12-24

(Q: Question, I: Idea)
- Q: When i set the argument type of main, even making it pointer is common, making it array also possible, will there some difference?
- Q: Will it possible executing according to the extension of file in vim?
  - :set autoindent for .md
  - :set cindent for .c
- I: What about a program which show real memory state on one side and what happenning at code at the other side?
  - Simulate very little computer, so i can see the memory at one display
- Q: Can i access NULL pointer?
- Idea: mobile golf game
  - Scroll the mobile display, if your display stop at to goal, you are hole in one :D



2020-12-23

- Q: I can set the data type of function as array or pointer, if I set the type as array, will it take all feature of array? (or it's actually just pointer)
    char    str[] = "lol";
- Q: imo, `"lol"` might be stored in data block and copy it to str array, correct?



2020-12-08

1.3. x: delete a character
1.4. i: enter `insert mode`
1.5. a: enter `insert mode` with appending

2.1. dw: delete a word
2.2. d$: delete to the end of line
2.3. `command target`: dw, de, d$
	enable target example: w, e, $, 0, b, h, j, k, l, H, L, {, }
2.4. `count command`: 2w, 3e
	0: move cusor  the start of the line
2.5. `command count target`: d2w
2.6. dd: delete a line
	`count command target`: 2dd, 2dw
2.7. u: undo last command
	ctrl-r: redo last undo

3.1. p: put vim's buffer content behind the cursor
	if vim's buffer has a line, put it under line of the cursor
3.2. r: replace a character without mode change
3.3. c target: delete target and enther `insert mode`(change): ce, c$, c2w, 2cw

4.1. ctrl-g: display the path of the file and state
	G: move to the last line of the file
	gg: move to the first line of the file
	count G: move to the count line
4.2. / 'what to search': search downward
	? 'what to search': search upward
	n: search next
	N: search previous
	ctrl-o: move previous cursor position
	ctrl-i: move next cursor position
4.3. %: move to the matching bracket
4.4. :s/old/new/g: subtitute 'old' to 'new'
	:s/thee/the: subtitute only first encountered 'thee'
	:s/thee/the/g: subtitute all(globally) 'thee' to 'the' in this line
	:#,#s/old/new/g: #,# mean the line number of two line
	:%s/old/new/g: search target from whole the file
	:%s/old/new/gc: you can command by prompt whether subtitute or not

5.1. :! 'extern command' <ENTER>: excute extern command
5.2. :w FILENAME: write current file as FILENAME
5.3. :'<,'>w FILENAME: save selected range as FILENAME
5.4. :r FILENAME: read and put FILENAME file under the cursor line
	:r !ls: read and put the result of 'ls' extern command under the cursor line

how to show pressed command state?
default output resolution: 853x480



2020-11-27

which vimmemo
(in vim normal mode): ":echo $MYVIMRC"
	# You can easily find the location and name of the file on any operating system.
how to move cursor to top or bottom of screen in vim?
	# H: move cursor to top of screen.
	# L: move cursor to bottom of screen.
	# {: move cursor to previous paragraph.
	# }: move cursor to next paragraph.
why use link?
	# For to call same function as different names
what is the difference between soft link and hard link?



2020-11-05
c7r9s4% ./a.out test.dat 10
fd: 3 
[ 1]read character: ''(104) 
ret_read           : [1] 
[ 2]read character: ''(105) 
ret_read           : [1] 
[ 3]read character: ''(32) 
ret_read           : [1] 
[ 4]read character: ''(112) 
ret_read           : [1] 
[ 5]read character: '.'(10) 
ret_read           : [1] 
[ 6]read character: '.'(106) 
ret_read           : [1] 
[ 7]read character: '.'(104) 
ret_read           : [1] 
[ 8]read character: '.'(10) 
ret_read           : [1] 
[ 9]read character: '.'(10) 
ret_read           : [0] 

analyze:
test.dat has 8 bytes size.
8th byte(last character of file) is newline character.
after read last character, if you try to read more character, the return value will be 0.
if `read()` try to read impossible, it will return 0.
`read()` function return read byte size.



2020-11-4
"abcd"[2]: has something to think!
strcmp return 2 case (1. -1, 0, 1), (2. ch1 - ch2)



2020-11-1
test git when init pull would delete another file?



2020-10-21

ctrl + u: clear current terminal line befor cursor
ctrl + k: clear current terminal line after cursor
[vim] d: cut selected text
[vim] y: copy selected text
[vim] p: paste selected text before cursor
[vim] P: paste selected text after cursor



2020-??-??

echo "*"    # *
echo '*'    # *
echo /*    # *
echo *    # display all files
echo ~    # display home path
echo ?    # display all 1 character

echo "$truc"    # isACar
echo '$truc'    # truc

cat [-e]
more    # work like man page
head
tail

grep [-iv]

ls bonjour 2> error.log
ls bonjour test* > res.txt 2> error.log
ls bonjour test* 2> error.log | grep test00

cat batman.txt | grep Joker | wc -l
grep Joker < batman.txt | wc -l

echo coucou > res.txt    # write file
echo coucou >> res.txt    # append file

cat << FIN    # read until FIN
ls bonjour *.txt > resultat.txt 2>&1
cat resultat.txt

ctrl d
ctrl c
ctrl \



2020-10-14

gzip -d <file>
tar -zxvf <file>
man cut
man diff
man patch
tar -cf exo2.tar *



2020-10-13

ctrl a
ctrl e

opt <-
opt ->

ctrl u
ctrl k

hexdump

Put some unfamiliar shortcut image aside. 
