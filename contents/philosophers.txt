#philosophers

#pc
playground 에서 작성한 예제를 통해 실제 sleep 이 thread 의 갯수에 따라 어떻게 달라지는지 확인해보자
- fork_array 를 먼저 만들고 philosopher 를 채워넣는 과정에서 fork1 과 fork2 를 설정해주자
- philosopher 가 1 명일 때는 포크가 2 개 조차 없으므로, 완전한 예외로 처리하기
- 시간 순서대로 출력하기 위해 gettimeofday() 바로 전에 mutex 로 하나씩 실행되도록 하는 것은 어떨까?
- 작동에 치명적인 것이 먼저 선행돼야 하고 비슷한 것들끼리 지역적으로 묶여야 한다
- philosophers pdf subject 읽으면서 요구 사항을 분석하고 구체적인 구현을 생각해보기
- process 를 종료하면서 thread 의 종료를 os 에게 맡기는 것은 좋은 연습이 아닌 것 같다.
- pthread_mutex_destroy() 를 하려면 다른 thread 들이 종료되기를 join 했다가 후에 호출해야할 것 같다.
- thread 의 종료에 대해 알아보기
	- 일반적인 종료 방법
	- main thread 가 종료될 때 종료되는지
	- detach 는 무엇인지
- timeval_init() 은 제대로 된 숫자를 인자로 받는다
	- 이미 전에 인자가 적절한지를 판단하는 추가적인 로직을 두도록 하자
- 왜 pen 이 philosopher 를 알아야 하지?
	- simulator 의 구조를 그래프로 작성해보자
- philosopher 가 1 명일 때는 완전 예외로 빼서 처리하자
- 대화와 관련해서 이전에는 어떻게 죽을 시 종료를 구현했는지 보고 싶은데, 너무 가독성이 구리다. 좀 다듬고 보도록 하자

#test case
- 0 -1 0 0
- 0 0 0 0
- 1 0 0 0
- 1 410 200 200
- 2 410 200 200
- 3 610 200 200
- 100 410 200 200

#last confirm
- lmt_c_library soft link 를 hard link 로 교체

#finish
- man pthread_exit()
- man pthread_create()
- lmt_exit 을 사용할 수 없으니 이전 방식대로 return 값을 확인하도록 하자 (특히 util.c 등)
- string_append 의 return type 을 int 로 바꾸기
	- t_lmt_string_method.c
	- t_lmt_string.h
	- caller

split 't_philos_method.c/philos_run()' several functions
usage: ./philo number_of_philosophers time_to_die time_to_eat time_to_sleep [number_of_times_each_philosopher_must_eat]
	number_of_philosophers: number of philosophers and also the number of forks
		[1, i) or [0, i)
	time_to_die: |----------|
				 ^			V
			last meal	if elapsed 'time_to_die' milliseconds, and not eating, it dies
		[0, i) in msec
	time_to_eat: time it takes for a philosopher to eat
		[0, i) in msec
	time_to_sleep: time the philosophers will spend sleeping
		[0, i) in msec
	number_of_times_each_philosophers_must_eat:
		- If all philosophers eat at least 'number_of_times_each_philosopher_must_eat', the simulation will stop
		- If not specified, the simulation will stop only at the death of a philosopher.
		[0, i)

기록
	philosopher 에게 number 를 멤버 변수로 넣어주자

홀수 철학자 문제 해결하기
포크 수는 철학자의 수와 같으니 철학자가 한 명만 있을 때도 포크가 존재할 것이다. 하지만 포크는 철학자 사이에만 존자하는 것 아니었나?
나는 마이크로 세크 단위로 측정을 하는데 출력될 때 밀리세크라 차이가 눈에 보이지 않고 철학자가 죽으면 이상하지 않을까?
마지막 식사 시간을 복사해올 때 에러 발생 가능
	뮤택스로 막아두고 복사해올 것?
	이 경우 문제가 발생하지는 않는지 생각해보자
Makefile 에 Stdheader 넣기!!
headeer file 의존 관계 오류 없는지 체크하기
프로그램의 thread 수에 따른 usleep(1000) 에 걸리는 평균 시간 (외부 환경 미포함)
usleep(1000) 과 usleep(100000) 과 usleep(1) 이 모두 sleep 이 끝나는 시간 차이가 다르다. 단순 배수만 해준다고 해결되는 부분이 아니다 (usleep 이 어떻게 구현되어 있는가를 잘 아는 것이 필요할 수도 있다)
p_pen 의 buffer 별로 수정을 위한 mutex 를 만들고, 출력을 위한 mutex 를 따로 두면 성능이 향상된다
if there is only one philosopher, it must die
eat 카운트는 먹기 전에 올릴까 먹은 후 올릴까?
가능한 많은 case 를 실행 가능하도록 지원하자
10ms 안에 dead 를 출력해야 하는데, 한 바퀴 돌고 main thread 가 다시 실행되는 데 까지 걸리는 시간이 얼마일까?
last
{
	실행 흐름을 쭉 훑어보기
	에러가 깊숙한 곳부터 끊이지 않고 잘 전달되는지 확인하기
}
philosopher가 1 명인 경우 포크가 없어 죽도록 하자
basic rules
{
	no norm error
	no leak
	no crash
	no undefined behavior
	philosopher must eat with two forks
	philosophers don't speak with each other
		'필로소퍼끼리 포크를 집는 순서를 결정하지 않는다' 라고 생각하자
	each time a philosopher has finished eating, he willl drop his forks and start sleeping
	when a philosopher is done sleeping, he will start thinking
	program options
	{
		number_of_philosophers
			== number of philosophers == number of forks
		time_to_die (milliseconds)
			if a philosopher doesn't eat during, dies
		time_to_eat (milliseconds)
			time it takes for a philosopher to eat, will occupy 2 forks
		time_to_sleep (milliseconds)
			time the philosopher will spend sleeping
		[number_of_times_each_philosopher_must_eat]
			if not specified, the simulation will stop only at the death of a philosopher
	}
	any change of status of philosopher must be written as follows
		timestamp_in_ms X has taken a fork
		timestamp_in_ms X is eating
		timestamp_in_ms X is sleeping
		timestamp_in_ms X is thinking
		timestamp_in_ms X died
	must print death before to elapse 10 ms
}
external functions
{
	void	*memset(void *b, int c, size_t len);		<string.h>
	int		printf(const char * restrict format, ...);	<stdio.h>
	int		usleep(useconds_t microseconds);			<unistd.h>
		typedef unsigned int useconds_t:
	int		gettimeofday(struct timeval *restrict tp, void *restrict tzp);	<sys/time.h>
	{
		struct timeval
		{
			time_t		tv_sec;
				// typedef long time_t;
			suseconds_t	tv_usec;
				// typedef int suseconds_t
		};
	}
	int		pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);	<pthread.h>
	{
		typedef struct	_opaque_pthread_t
		{
			long		__sig;
			struct __darwin_pthread_handler_rec	*__cleanup_stack;
			char		__opaque[__PTHREAD_SIZE__];
		}				*pthread_t;
		struct		__darwin_pthread_handler_rec
		{
			void	(*__routine)(void *);
			void	*__arg;
			struct __darwin_pthread_handelr_rec	*__next;
		};
		typedef struct	_opaque_pthread_attr_t
		{
			long		__sig;
			char		__opaque[__PTHREAD_ATTR_SIZE__];
		}				pthread_attr_t;
	}
	int		pthread_detach(pthread_t thread);	<pthread.h>
	int		pthread_join(pthread_t thread, void **value_ptr);	<pthread.h>
	int		pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);	<pthread.h>
	{
		typedef struct	_opaque_pthread_mutex_t
		{
			long		__sig;
			char		__opaque[__PTHREAD_MUTEX_SIZE__];
		}				pthread_mutex_t;
		typedef struct	_opaque_pthread_mutexattr_t
		{
			long		__sig;
			char		__opaque[__PTHREAD_MUTEXATTR_SIZE__];
		}				pthread_mutexattr_t;
	}
	int		pthread_mutex_destroy(pthread_mutex_t *mutex);	<pthread.h>
	int		pthread_mutex_lock(pthread_mutex_t *mutex);	<pthread.h>
	int		pthread_mutex_unlock(pthread_mutex_t *mutex);	<pthread.h>
}
summary
{
	You can’t have more than 10 ms between the death of a philosopher and when it will print its death
}
need guard
{
	int pthread_create(&thread, NULL, handler, arg);  // 0 : error
	int pthread_mutex_init(&mutex, NULL);  // 0 : error
}
don't need guard
{
	usleep(int);  // signal 을 받을 때의 작동은 신경쓰지 않는다
	gettimeofday(struct timeval *, NULL);  // 인자가 NULL 이 아니도록 신경쓴다
	pthread_detach(thread);  // 정상적인 thread 인지 신경써준다 (벌써 detach 됐거나 없는 thread 이면 안된다!)
	pthread_mutex_lock(&mutex);  // valid mutex
	pthread_mutex_unlock(&mutex);  // valid mutex, thread hold a lock on mutex
}
