#philosophers

#pc
- mutex 에 대해 잘 알지 못하고 있는 것 같다. mutual exclusive 와 lock(mutex) 에 대해 wiki 를 더 읽어보도록 하자
- 죽었을 때 프로그램이 끝난다고 되어 있는데, 굳이 그 이후에 출력을 막을 필요는 없을 것 같다. 만약 막는다면 마찬가지로 철학자가 최소 먹어야 하는 양만큼 먹었을 때도 다른 메세지가 더이상 출력되지 않도록 mutex 로 막고 is_end 를 true 로 바꿔야 하는데, 그렇게 할까? 아니 말도 안된다. 요구되는 것에 비해 성능을 너무 많이 뺐긴다. pen_write() 는 가장 많이 호출되는 core 한 함수이므로 가능한 한 가볍게 만들어야 한다. 희생하더라도 다른 것이 희생되야지. 이런 core 함을 수치화할 수 있을까?
- 철학자가 죽었을 때 10ms 안에 출력해야 하므로 main_loop 가 5ms 정도마다 한 번식 돌아가면 어떨까?
- 초반에 thread 를 순간적으로 늘리면 생기는 sleep() 지연현상을 완화함과 동시에 홀수 짝수 철학자가 교대로 먹도록 한 쪽에 지연시간을 두도록, pthread_create 시에 한 쪽을 생성한 후, 다른 쪽을 생성하기 전에 sleep 을 두는 것은 어떨까?
- multi thread 구조에서 뭔가 한다는 것은 복잡해지기 때문에 가능하다면 오류가 조금 있어도 간결한 구조를 작성하고 넘어가도록 하자
	- take fork 와 eat 사이에 다른 철학자의 log 가 올 수 있지만 신경쓰지 않겠다.
- mutex 는 FIFO 가 아닌데, 이를 해결할 방법이 있나?
- 홀수라면 끝에서부터 홀수 철학자들을 생성하고, 끝에서부터 짝수 철학자를 생성하는 방식으로 간단하게 홀수 철학자 문제를 해결할 수 있다.
	- 그러나 생성과 실행이 항상 같은 순서는 아니기 때문에, 만약 철학자 수를 3 으로 설정하면, 1,2,1,3 순서로 밥을 먹을 수도 있기 때문에 철학자가 죽는 경우가 발생할 수 있다고 생각한다.
		- 먼저 만들어보고 실제 죽는지 테스트해보자. 그래도 만들 때 애초에 저런 가능성을 없엔 상태로 만들고 싶다. 하지만 다른 사람을 평가할 때, 클러스터 mac 기준으로 실제 저렇게 구현하면 죽을 가능성이 얼마나 되는지 데이터를 얻는 것도 의미 있는 작업으로 보인다.
- 아래의 작업을 하고 있는데, mutex 를 어떻게 설정해야 가능할지 생각해보자
- 일단 take_fork log 와 eat log 를 pen_write() 두 번을 써서 한 번에 출력할 때 전체적으로 write mutex 로 크게 묶어서 성능이 얼마나 떨어지는지를 확인해보자
	- 만약 크게 떨어지면 사이에 다른 log 가 들어와도 되도록 만들던가 mutex 범위를 더 깐깐하게 수정하기
- 모든 sleep() 을 spin-lock 으로 처리하면 200 philosopher 가 돌아갈까?
- 두 번째 fork 를 집자 마자 eat 을 하는 상태로 바뀔텐데, 그럼 fork 를 잡았다는 log 와 eat 을 시작한다는 log 사이에 다른 philosopher 의 log 가 들어오지 않도록 막아야 할까?
- fork 를 각각 log 출력하도록 수정하기
- 실제 sleep() 값을 측정하기 위해 sleep() 의 오차를 무시한 채 philosopher 프로그램 기초적으로 실행 가능하도록 작성하기
- sleep() 이라는 함수가 스스로 실제 sleep 한 양을 토대로 다음 sleep 실행 시 어느정도 절절한 값 만큼 sleep 하도록 조절하는 것으로 보인다. 따라서 내가 원하는 타이밍에 원하는 시간 만큼 sleep 을 시키려고 해도, 자원 소모량이 달라지는 상황에서는 불가능하다. 따라서 특정 자원 소모량에 어느 정도 길이로 sleep 하는지 데이터를 확보하고, 이를 토대로 특정 자원 소모 시 원하는 만큼 sleep 하도록 유도하는 정도로 구현이 가능할 것 같다.
	- 그런데 내가 다른 thread 함수를 가지고 얻은 데이터로는 실제 프로그램에 적용하기에 적절하지 않다. 내가 임의로 작성한 thread 함수는 ++count; 를 무한히 반복하는데, 실제 프로그램에서 실행될 thread 함수와는 확연히 성능에 차이가 있을 것이다. 따라서 실제 만드는 프로그램 내에서 데이터를 확보해서 그 데이터를 토대로 sleep 을 조절하는 것이 좋을 것 같다.
- playground 에서 작성한 예제를 통해 실제 sleep 이 thread 의 갯수에 따라 어떻게 달라지는지 확인해보자
- fork_array 를 먼저 만들고 philosopher 를 채워넣는 과정에서 fork1 과 fork2 를 설정해주자
- philosopher 가 1 명일 때는 포크가 2 개 조차 없으므로, 완전한 예외로 처리하기
- 시간 순서대로 출력하기 위해 gettimeofday() 바로 전에 mutex 로 하나씩 실행되도록 하는 것은 어떨까?
- 작동에 치명적인 것이 먼저 선행돼야 하고 비슷한 것들끼리 지역적으로 묶여야 한다
- philosophers pdf subject 읽으면서 요구 사항을 분석하고 구체적인 구현을 생각해보기
- process 를 종료하면서 thread 의 종료를 os 에게 맡기는 것은 좋은 연습이 아닌 것 같다.
- pthread_mutex_destroy() 를 하려면 다른 thread 들이 종료되기를 join 했다가 후에 호출해야할 것 같다.
- thread 의 종료에 대해 알아보기
	- 일반적인 종료 방법
	- main thread 가 종료될 때 종료되는지
	- detach 는 무엇인지
- timeval_init() 은 제대로 된 숫자를 인자로 받는다
	- 이미 전에 인자가 적절한지를 판단하는 추가적인 로직을 두도록 하자
- 왜 pen 이 philosopher 를 알아야 하지?
	- simulator 의 구조를 그래프로 작성해보자
- philosopher 가 1 명일 때는 완전 예외로 빼서 처리하자
- 대화와 관련해서 이전에는 어떻게 죽을 시 종료를 구현했는지 보고 싶은데, 너무 가독성이 구리다. 좀 다듬고 보도록 하자

#last confirm
- lmt_c_library soft link 를 hard link 로 교체
- note/contents/evaluation/philosophers.txt 확인
- submit protocol 확인

#finish
- const.h 의 pen format 을 정의해서 documentation 을 하고 있다
- pen_write 점검
	- 각 수치를 버퍼에 잘 복사해넣도록 수정
- pen 에서 상수의 이름을 수정하고 있었다. (messages -> log_bufs)
- helper_ltoa() 작성하기
	- 상수 정의해야한다 long 길이
- man pthread_exit()
- man pthread_create()
- lmt_exit 을 사용할 수 없으니 이전 방식대로 return 값을 확인하도록 하자 (특히 util.c 등)
- string_append 의 return type 을 int 로 바꾸기
	- t_lmt_string_method.c
	- t_lmt_string.h
	- caller

split 't_philos_method.c/philos_run()' several functions
usage: ./philo number_of_philosophers time_to_die time_to_eat time_to_sleep [number_of_times_each_philosopher_must_eat]
	number_of_philosophers: number of philosophers and also the number of forks
		[1, i) or [0, i)
	time_to_die: |----------|
				 ^			V
			last meal	if elapsed 'time_to_die' milliseconds, and not eating, it dies
		[0, i) in msec
	time_to_eat: time it takes for a philosopher to eat
		[0, i) in msec
	time_to_sleep: time the philosophers will spend sleeping
		[0, i) in msec
	number_of_times_each_philosophers_must_eat:
		- If all philosophers eat at least 'number_of_times_each_philosopher_must_eat', the simulation will stop
		- If not specified, the simulation will stop only at the death of a philosopher.
		[0, i)

기록
	philosopher 에게 number 를 멤버 변수로 넣어주자

홀수 철학자 문제 해결하기
포크 수는 철학자의 수와 같으니 철학자가 한 명만 있을 때도 포크가 존재할 것이다. 하지만 포크는 철학자 사이에만 존자하는 것 아니었나?
나는 마이크로 세크 단위로 측정을 하는데 출력될 때 밀리세크라 차이가 눈에 보이지 않고 철학자가 죽으면 이상하지 않을까?
마지막 식사 시간을 복사해올 때 에러 발생 가능
	뮤택스로 막아두고 복사해올 것?
	이 경우 문제가 발생하지는 않는지 생각해보자
Makefile 에 Stdheader 넣기!!
headeer file 의존 관계 오류 없는지 체크하기
프로그램의 thread 수에 따른 usleep(1000) 에 걸리는 평균 시간 (외부 환경 미포함)
usleep(1000) 과 usleep(100000) 과 usleep(1) 이 모두 sleep 이 끝나는 시간 차이가 다르다. 단순 배수만 해준다고 해결되는 부분이 아니다 (usleep 이 어떻게 구현되어 있는가를 잘 아는 것이 필요할 수도 있다)
p_pen 의 buffer 별로 수정을 위한 mutex 를 만들고, 출력을 위한 mutex 를 따로 두면 성능이 향상된다
if there is only one philosopher, it must die
eat 카운트는 먹기 전에 올릴까 먹은 후 올릴까?
가능한 많은 case 를 실행 가능하도록 지원하자
10ms 안에 dead 를 출력해야 하는데, 한 바퀴 돌고 main thread 가 다시 실행되는 데 까지 걸리는 시간이 얼마일까?
last
{
	실행 흐름을 쭉 훑어보기
	에러가 깊숙한 곳부터 끊이지 않고 잘 전달되는지 확인하기
}
philosopher가 1 명인 경우 포크가 없어 죽도록 하자
basic rules
{
	no norm error
	no leak
	no crash
	no undefined behavior
	philosopher must eat with two forks
	philosophers don't speak with each other
		'필로소퍼끼리 포크를 집는 순서를 결정하지 않는다' 라고 생각하자
	each time a philosopher has finished eating, he willl drop his forks and start sleeping
	when a philosopher is done sleeping, he will start thinking
	program options
	{
		number_of_philosophers
			== number of philosophers == number of forks
		time_to_die (milliseconds)
			if a philosopher doesn't eat during, dies
		time_to_eat (milliseconds)
			time it takes for a philosopher to eat, will occupy 2 forks
		time_to_sleep (milliseconds)
			time the philosopher will spend sleeping
		[number_of_times_each_philosopher_must_eat]
			if not specified, the simulation will stop only at the death of a philosopher
	}
	any change of status of philosopher must be written as follows
		timestamp_in_ms X has taken a fork
		timestamp_in_ms X is eating
		timestamp_in_ms X is sleeping
		timestamp_in_ms X is thinking
		timestamp_in_ms X died
	must print death before to elapse 10 ms
}
external functions
{
	void	*memset(void *b, int c, size_t len);		<string.h>
	int		printf(const char * restrict format, ...);	<stdio.h>
	int		usleep(useconds_t microseconds);			<unistd.h>
		typedef unsigned int useconds_t:
	int		gettimeofday(struct timeval *restrict tp, void *restrict tzp);	<sys/time.h>
	{
		struct timeval
		{
			time_t		tv_sec;
				// typedef long time_t;
			suseconds_t	tv_usec;
				// typedef int suseconds_t
		};
	}
	int		pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);	<pthread.h>
	{
		typedef struct	_opaque_pthread_t
		{
			long		__sig;
			struct __darwin_pthread_handler_rec	*__cleanup_stack;
			char		__opaque[__PTHREAD_SIZE__];
		}				*pthread_t;
		struct		__darwin_pthread_handler_rec
		{
			void	(*__routine)(void *);
			void	*__arg;
			struct __darwin_pthread_handelr_rec	*__next;
		};
		typedef struct	_opaque_pthread_attr_t
		{
			long		__sig;
			char		__opaque[__PTHREAD_ATTR_SIZE__];
		}				pthread_attr_t;
	}
	int		pthread_detach(pthread_t thread);	<pthread.h>
	int		pthread_join(pthread_t thread, void **value_ptr);	<pthread.h>
	int		pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);	<pthread.h>
	{
		typedef struct	_opaque_pthread_mutex_t
		{
			long		__sig;
			char		__opaque[__PTHREAD_MUTEX_SIZE__];
		}				pthread_mutex_t;
		typedef struct	_opaque_pthread_mutexattr_t
		{
			long		__sig;
			char		__opaque[__PTHREAD_MUTEXATTR_SIZE__];
		}				pthread_mutexattr_t;
	}
	int		pthread_mutex_destroy(pthread_mutex_t *mutex);	<pthread.h>
	int		pthread_mutex_lock(pthread_mutex_t *mutex);	<pthread.h>
	int		pthread_mutex_unlock(pthread_mutex_t *mutex);	<pthread.h>
}
summary
{
	You can’t have more than 10 ms between the death of a philosopher and when it will print its death
}
need guard
{
	int pthread_create(&thread, NULL, handler, arg);  // 0 : error
	int pthread_mutex_init(&mutex, NULL);  // 0 : error
}
don't need guard
{
	usleep(int);  // signal 을 받을 때의 작동은 신경쓰지 않는다
	gettimeofday(struct timeval *, NULL);  // 인자가 NULL 이 아니도록 신경쓴다
	pthread_detach(thread);  // 정상적인 thread 인지 신경써준다 (벌써 detach 됐거나 없는 thread 이면 안된다!)
	pthread_mutex_lock(&mutex);  // valid mutex
	pthread_mutex_unlock(&mutex);  // valid mutex, thread hold a lock on mutex
}
