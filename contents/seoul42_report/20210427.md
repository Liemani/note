### 1. 학습 날짜

- 2021-04-27(화)

### 2. 학습시간

- 13:30 ~ 18:00 (이노베이션 아카데미 클러스터)

### 3. 학습 범위 및 주제

- miniRT

### 4. 동료 학습 방법

- 해당 사항 없음

### 5. 학습 목표

- miniRT
  - 작성한 코드의 컴파일 에러 수정하기

### 6. 상세 학습 내용

#### 파일간의 의존성

프로그램의 작동과 별개로, 파일간의 의존성에 따른 코드 구조화와, 그에 따른 컴파일 시간 변화도 코드를 작성할 때 신경써야하는 부분이다. 나는 아직 프로그램의 바람직한 의존성 구조를 잘 모르겠다. 프로그램을 작성하다보면 A 파일이 B 파일을 필요로 하는 동시에 B 파일이 A 파일을 필요로 하는 경우가 있다. 이런 경우 단순히 서로 파일을 #include 하는 것 만으로는 제대로 컴파일이 진행되지 않는다. 일반적으로 #include 해서 사용하는 파일은 헤더 파일이다. 헤더 파일은 중복 include 를 방지하도록 작성하기 때문에, 컴파일러가 A 파일을 읽으려다 #include "B.h" 를 보고 B.h 파일을 읽으려 시도하면 B.h 파일에 있는 #include "A.h" 를 시도할테고, 이 동작은 이미 #define A\_H 로 A\_H 가 정의되어 있기 때문에, 중복 include 되지 않고 다음 동작을 수행한다. 따라서 아직 A.h 파일을 읽지 않은 상태로 B.h 파일을 읽게 되고, B.h 에서 사용한 A.h 의 내용은 컴파일러가 알지 못한다는 오류를 발생시키는 것이다. 일단 이런 상호 참조 같은 형태의 경우, 일일이 직접 A 파일에는 B 의 내용을, B 파일에는 A 의 내용을 다시 써넣어줘서 A.h 파일을 읽지 않은 상태라도 컴파일러가 경고를 발생시키지 않도록 하고 있는데, 이게 옳바른 방법인지는 더 생각해봐야 할 것 같다

#### miniRT 진행

오늘은 모든 컴파일 에러를 잡고 miniRT 를 실행해 보았다. 그러나 miniRT 에는 원이 하나도 그려지지 않았다. 6 방면 모두 큼직한 구를 배치시켜 보았으나, 카메라의 방향 등이 잘못 계산된게 아니라 무언가 직선과 sphere 의 intersection point 를 계산하는 함수가 잘못 되었나 싶다

#### 연산 함수의 종류

오늘은 에러 잡는데 많은 시간을 사용했고, 딱히 새로운 이렇다한 코드를 작성하지도 않아서, 연산 함수의 종류를 고찰해 본다. 연산 함수는 항의 갯수가 2 개인 연산을 생각해보자. 연산 함수를 분류하는 기준은 여러개 존재할 것이다:

1. 두 항의 data type 이 일치하는가? 결과 값은 인자들의 data type 과 일치하는가?
2. 계산 결과가 lhs 에 저장되는가 아니면 새로운 값으로 return 하는가, 혹은 3 번째 인자로 결과값을 저장할 공간을 입력받는가?

- `V       *function(T *lhs, U *rhs)`: 두 항의 연산 결과를 return 한다
- `void    function(T *lhs, U *rhs)`: 두 항의 연산 결과를 lhs 에 저장한다
- `void    function(T *lhs, U *rhs, V *result)`: 두 항의 연산 결과를 result 에 저장한다

가장 자연스러운 것은 두 항의 연산 결과를 return 하는 것이다. 하지만 c 에서 그런식으로 처리했다가는 매번 반환 값 등을 free 해줘야해서 프로그램의 흐름을 파악하기 힘든 코드가 될 것이다. 게다가 성능적으로도 매번 새로운 메모리 공간을 할당하는 것은 매우 비효율적이다. 함수를 작성할 때 인자와 반환 값을 저장하는 공간이 예측 가능하다면 stack 을 사용하는 것이 좋을 것 같다


### 7. 학습 내용에 대한 개인적인 총평

오늘은 컴파일 에러를 잡았습니다. 요즘 부쩍 놀고 싶은 생각이 많아져서 공부를 열심히 하지 못하고 있는 것 같습니다

### 8. 다음 학습 계획

- miniRT
  - 검증되지 않은 함수들 테스트하기 
  - 배경 색을 바꿔보기
  - line 에 대한 sphere 의 intersection 함수 작동 테스트하기
  - 거리를 구할 때 등 오버플로우가 날 수 있는 부분 고려하기
  - t\_\<geometry\> 만들기
    - 각 geometry 마다 intersection\_point(t\_line \*p\_line) 만들기
  - mandatory
    - 5 geometric objects: plane, sphere, cylinder, square, triangle
    - 겹치는 경우와 오브젝트 내부도 올바르게 처리되야 한다
    - 오브젝트의 속성을 resize 할 수 있어야 한다
    - 평행 변환과 회전 변환이 가능해야 한다
      - 구, 삼각형, 빛 은 회전 불가
    - 빛
      - 지점 밝기, 그림자, 자연광, (물체들은 절대 완전한 어둠 속에 있지 않는다)
      - 색, 여러 지점 빛들도 잘 처리되야 한다
    - 두 번째 인자로 '--save' 를 받을 경우 이미지를 bmp 형식으로 저장하기
      - 이 경우 창을 띄우지 않는다 
    - 만약 두 번째 인자가 주어지지 않았다면 아래와 같은 기능 수행하기 
      - 요구된 scene 크기가 화면보다 크다면 창 크기를 화면 해상도에 맞게 설정하기 
      - 만약 카메라가 여러개 존재한다면 원하는 키를 눌러서 화면 전환이 가능하도록 하기
    - 첫 인자는 .rt 확장자를 갖는 scene description 파일을 입력받는다
      - 해상도 == 창의 크기, width 와 height 는 항상 양수
      - 원소의 정보들은 하나 이상의 space 로 구분
      - 원소들의 순서는 중요하지 않음
      - 대문자 원소들은 오직 한 번만 정의되야 한다 
      - 각 원소의 첫 정보는 종류 식별 문자이다 (한 두 문자로 되어 있다)
        - 그 다음 나열되는 문자들은 구체적인 순서를 따른다 
      - .rt 파일이 잘못 구성되어 있다면 "Error\n" 를 출력하며 프로그램 종료하기
        - 뒤에 원하는 에러 메세지 출력 허용
  - rasterization 검색
  - 이미지 출력 전에 client 의 endianess 를 확인한 후 server 의 endianess 에 따라 이미지 처리하기
- ft\_server
  - Nginx 알아보기
  - 슬랙, 디코, 42wiki 에서 정보 얻기
  - vnc 로 돌려보기
  - Wordpress
  - phpMyAdmin
  - SQL databse
- 블로그를 어느정도 자동화 시켜주는 툴 만들기
  - siteTool
