# 제출 전 확인

- subject pdf
- 42seoul-translation
- 42seoul wiki
- 평가지표
- slack
- norm
- leak
- symbolic link 를 실제 파일로 교체하기

# 일단 적어

{
	pipex
	{
		access
		unlink
		waitpid
		pipe
		dup
		dup2
		execve
		fork
	}
	minishell
	{
		fork
		wait
		waitpid
		wait3
		wait4
		getcwd
		chdir
		stat
		lstat
		fstat
		execve
		dup
		dup2
		pipe
		opendir
		readdir
		closedir
		isatty
		ttyname
		ttyslot
		ioctl
		getenv
		tcsetattr
		tcgetattr
		tgetent
		tgetflag
		tgetnum
		tgetstr
		tgoto
		tputs
	}
}

방송으로 막 송출을 하다가 클립을 따서 위키 페이지에 정리하는 방식으로 프로젝트를 진행한다면 새로 들어오는 시청자도 클립으로 주요 부분을 이해하고 쉽게 참여가 가능하지 않을까?

테스트 환경을 잘 만들어도 좋겠다
문자열, 숫자, 문자 등을 생성하여 인자로 넣어주는 프로그램
(각 인자는 범위 등을 지정 할 수도 있다!)
여러 명이 협업을 진행하게 되면 코드의 온전성이 중요해질 것 같다
	- 테스트를 하여 온전하게 작동하는 코드인지를 확실하게 하고 추가하는 것이다

나의 코드 작성 방법
  - 1. 일단 pseudo code 로 마구 작성한다 (일부러 norm 에 걸리도록)
  - 2. 구현한다

git
{
	test program 등 유용한 shell script 를 위키처럼 관리할 수 있도록 운영하는 깃 레포를 하나 만들고 싶다
}

minishell
{
	누구 주도로 진행할지 정하기
	git 을 사용할 때 merge 등을 하기 싫다면 아예 분리된 directory 에서 작업하는 방법이 있다
	libft 어떻게 사용해왔는지
	conform norm
	no error quit
}

minishell 팀원과 첫 만남 'seonkim'
{
	의견 교환 이전에
	{
		no ebelin! 의사 합의를 하지 않도록 해보자
		가볍게 대화 가능한 주제
			subject pdf 의 의미 해석
		가볍게 대화가 불가능한 주제
			stack or heap
			data type
			data structure
			이 경우 가볍게 토론하기보다 깊게 생각해보고, 둘 다 충분히 준비가 되면 이야기를 나누는 방식을 선호한다. 둘 다 잘 모르는 상태에서는 얘기해봤자 가벼운 이야기만 오갈 뿐이라고 생각한다

		어떻게 생각하시는지?
	}
}

env
{
	util 에 가변 배열도 하나 만들어두면 잘 사용하겠다
	'aux where <aux command>': Print the path of aux command shell script
	$git 이 ~/git 이었으면 좋겠다 (programming 은 너무 길었다)
	git back 관련 command 가 불필요한 git 에 대해서는 짧게 출력하여 가독성을 높여보자
	structure 의 image 를 upload 하기
}

project/main
{
	modify function's name convention of 'alloc, init, new, free' from prefix to suffix
	exit 이 없더라도 lmt_error.h 에 exit_code 를 적어두는 것은 좋다
		- 언제든 함수의 반환 값을 다시 반환할 때, 다른 에러 발생으로 함수를 종료할 때 이 exit_code 를 사용하면 된다
	unsafe 함수들은 unsafe prefix 를 붙이자
	main/util/lmt_atoi 가 "-" 를 0 으로 반환하는 문제 -> 반환 순서를 조금 뒤로 (philo1 참고)
	util.h 를 lmt_util.h 로 바꾸자
	directory name 도 util 에서 lmt_util 로
	util.c 는 lmt_write.c 등으로 함수 하나만 사용하도록
	add 'unsafe/lmt_strcpy.c'
}

minitalk
{
	평가 받기
}

philosophers
{
	split 't_philos_method.c/philos_run()' several functions
	headeer file 의존 관계 오류 없는지 체크하기
	프로그램의 thread 수에 따른 usleep(1000) 에 걸리는 평균 시간 (외부 환경 미포함)
	usleep(1000) 과 usleep(100000) 과 usleep(1) 이 모두 sleep 이 끝나는 시간 차이가 다르다. 단순 배수만 해준다고 해결되는 부분이 아니다 (usleep 이 어떻게 구현되어 있는가를 잘 아는 것이 필요할 수도 있다)
	p_pen 의 buffer 별로 수정을 위한 mutex 를 만들고, 출력을 위한 mutex 를 따로 두면 성능이 향상된다
	if there is only one philosopher, it must die
	eat 카운트는 먹기 전에 올릴까 먹은 후 올릴까?
	가능한 많은 case 를 실행 가능하도록 지원하자
	10ms 안에 dead 를 출력해야 하는데, 한 바퀴 돌고 main thread 가 다시 실행되는 데 까지 걸리는 시간이 얼마일까?
	last
	{
		실행 흐름을 쭉 훑어보기
		에러가 깊숙한 곳부터 끊이지 않고 잘 전달되는지 확인하기
	}
	philosopher가 1 명인 경우 포크가 없어 죽도록 하자
	lmt_exit 을 사용할 수 없으니 이전 방식대로 return 값을 확인하도록 하자 (특히 util.c 등)
	basic rules
	{
		no norm error
		no leak
		no crash
		no undefined behavior
		philosopher must eat with two forks
		philosophers don't speak with each other
			'필로소퍼끼리 포크를 집는 순서를 결정하지 않는다' 라고 생각하자
		each time a philosopher has finished eating, he willl drop his forks and start sleeping
		when a philosopher is done sleeping, he will start thinking
		program options
		{
			number_of_philosophers
				== number of philosophers == number of forks
			time_to_die (milliseconds)
				if a philosopher doesn't eat during, dies
			time_to_eat (milliseconds)
				time it takes for a philosopher to eat, will occupy 2 forks
			time_to_sleep (milliseconds)
				time the philosopher will spend sleeping
			[number_of_times_each_philosopher_must_eat]
				if not specified, the simulation will stop only at the death of a philosopher
		}
		any change of status of philosopher must be written as follows
			timestamp_in_ms X has taken a fork
			timestamp_in_ms X is eating
			timestamp_in_ms X is sleeping
			timestamp_in_ms X is thinking
			timestamp_in_ms X died
		must print death before to elapse 10 ms
	}
	external functions
	{
		void	*memset(void *b, int c, size_t len);		<string.h>
		int		printf(const char * restrict format, ...);	<stdio.h>
		int		usleep(useconds_t microseconds);			<unistd.h>
			typedef unsigned int useconds_t:
		int		gettimeofday(struct timeval *restrict tp, void *restrict tzp);	<sys/time.h>
		{
			struct timeval
			{
				time_t		tv_sec;
					// typedef long time_t;
				suseconds_t	tv_usec;
					// typedef int suseconds_t
			};
		}
		int		pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);	<pthread.h>
		{
			typedef struct	_opaque_pthread_t
			{
				long		__sig;
				struct __darwin_pthread_handler_rec	*__cleanup_stack;
				char		__opaque[__PTHREAD_SIZE__];
			}				*pthread_t;
			struct		__darwin_pthread_handler_rec
			{
				void	(*__routine)(void *);
				void	*__arg;
				struct __darwin_pthread_handelr_rec	*__next;
			};
			typedef struct	_opaque_pthread_attr_t
			{
				long		__sig;
				char		__opaque[__PTHREAD_ATTR_SIZE__];
			}				pthread_attr_t;
		}
		int		pthread_detach(pthread_t thread);	<pthread.h>
		int		pthread_join(pthread_t thread, void **value_ptr);	<pthread.h>
		int		pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);	<pthread.h>
		{
			typedef struct	_opaque_pthread_mutex_t
			{
				long		__sig;
				char		__opaque[__PTHREAD_MUTEX_SIZE__];
			}				pthread_mutex_t;
			typedef struct	_opaque_pthread_mutexattr_t
			{
				long		__sig;
				char		__opaque[__PTHREAD_MUTEXATTR_SIZE__];
			}				pthread_mutexattr_t;
		}
		int		pthread_mutex_destroy(pthread_mutex_t *mutex);	<pthread.h>
		int		pthread_mutex_lock(pthread_mutex_t *mutex);	<pthread.h>
		int		pthread_mutex_unlock(pthread_mutex_t *mutex);	<pthread.h>
	}
	summary
	{
		You can’t have more than 10 ms between the death of a philosopher and when it will print its death
	}
	need guard
	{
		int pthread_create(&thread, NULL, handler, arg);  // 0 : error
		int pthread_mutex_init(&mutex, NULL);  // 0 : error
	}
	don't need guard
	{
		usleep(int);  // signal 을 받을 때의 작동은 신경쓰지 않는다
		gettimeofday(struct timeval *, NULL);  // 인자가 NULL 이 아니도록 신경쓴다
		pthread_detach(thread);  // 정상적인 thread 인지 신경써준다 (벌써 detach 됐거나 없는 thread 이면 안된다!)
		pthread_mutex_lock(&mutex);  // valid mutex
		pthread_mutex_unlock(&mutex);  // valid mutex, thread hold a lock on mutex
	}
}

- siteTool
  - 블로그 만들고 작성하기!!!
- variabledText
  - cli 에서 변수 값을 인자로 넣어줄 수 있으면 좋겠다
    - 'variabledText <path> -v <identifier>=<value>
  - '-o' 로 결과 파일을 직접 입력하는 것이 아니라 파일 내에 meta data 를 text 로 기록해두고 읽어서 사용하도록 하면 어떻까?
  - 변수의 값에 '\n' 를 넣을 수 있게 하려면 변수 간의 delimiter 를 '\n' 로 하면 안되는 걸까?
  - 변수 식별자를 일괄적으로 바꾸는 추가 기능
  - 다양한 경고 (위치와 해당 라인 출력)
    - 정의하지 않은 식별자 사용 경고
    - 사용하지 않은 식별자 정의 경고
    - 중복 정의된 식별자 경고
- env
  - setenv 가 basecamp 를 입력받아서 패키지를 구성하도록 변경하기
  - 전반적인 초기 과정을 추적해보자, ssh key 를 적용하기 위해서 필요한 것들 -> 어디에 적용할지 사이트 주소
- 기록이 먼저
  - 아마존 무료 클라우드 호스팅 서비스 알아보기
  - 내가 프로그램 지능이 나보다 낮은 사람에게 알려줄 수 있는 것은 앞길과, 그 시기에는 원래 그렇게 힘들다는 것이다
  - 프로그래밍 단어 정규화
  - 자동으로 웹에 백업되는 것도 좋지만, 시간이 오래 걸리는 작업이기 때문에 캐쉬를 기본으로 하고 필요에 따라 사용자에게 백업 및 풀 권한을 주는 것도 좋을 것 같다
  - 생각
    - 프로그램의 구조를 다 보여주는 프로그램은 어떨까?
	  - lldb 처럼 디버깅용 프로그램인데 어떤 함수에 어떤 변수가 존재하는지 다 보여주고 어떤 변수가 어떤 변화과정을 겪었는지 연대기를 다 보여주는거지
    - 생각을 적게 해야할 부분
	  - 여러 이름들, 최선의 이름은 있겠지만 최고의 이름은 없다
  - how to multi line quote in md
  - 인자가 특정 값이면 0 을 반환하는 함수?
  - env 가 setenv.sh 를 실행할 때 설정해줘야하는 파일을 vim 으로 열어도 좋을 것 같다
  - va_list 인자는 기존 인자와는 다른 방식으로 작동하는 모습을 보이는 것 같다. 더 큰 크기의 인자로 받아들일 때도 입력받은 인자의 크기만큼을 가져온다. 내부적으로 어떻게 되어있는 것일까?
  - 기록 관리 프로그램 in cli!!!!
    - git 처럼 vcs 이 아니라 기록 control system 을 만들자!
	- git 에 자료를 보관하면서 보관되어 있는 자료를 쉽게 control 하는거지!
  - 블로그에 날짜 표시하기
  - 함수 이름을 여러개로 쓸 수 있도록 필요할 때마다 추가할 수 있도록 하면 결국 지저분해질 뿐이다, 따라서 문서 편집기에서 특정 이름들을 특정 상수로 바꾸도록 처리하여 서로 다른 이름을 쓰더라도 결국 같은 상수가 되도록 처리하는 것이 좋다. 일괄적으로 변수 이름을 바꾸는 기능을 상위단에서 제공하는 것이다
  - 모든 local repo 의 branch 를 출력하는 프로그램은 어떨까?
  - 문서편집기인데 모든 문자들이 저마다의 태그를 가지고 있고 특정 태그의 특정 문자나 단어를 replace 할 수 있는 프로그램
  - ':set all': display all set
  - 데이터를 마구마구 던지면 알아서 구조화하고 정리해주는 프로그램
  - 일단 명령을 입력하기가 무조건 쉬워야 한다 (혹은 alias 를 사용할 수도 있겠지), 그러고 나서 보기 좋게 출력하는 것은 추가적인 출력 프로그램이 담당하는 것!
- 항시 정리하기
  - 북마크
  - 읽기 목록
  - 하드
  - 메모
  - 슬랙 saved
  - back command 가 인자를 받아서 해당 git repo 만 처리하도록 하자
- git
  - how to get the content of hash?
- lldb
  - 특정 시그널 보내기
  - 'memory read': 메모리를 출력함
  - 변수 값 읽기 쓰기에 따른 breakpoint 설정
- 책
  - 50/288 : The C Programming Language
  - 늑향: 10 권 114p
