### 1. 학습 날짜

- 2021-03-07(일)

### 2. 학습시간

- 10:00 ~ 12:00 (자가)
- 13:00 ~ 18:00 (자가)
- 19:50 ~ 21:10 (자가)

### 3. 학습 범위 및 주제

- ft\_printf

### 4. 동료 학습 방법

- 해당 사항 없음

### 5. 학습 목표

- ft\_printf
  - '#' 옵션

### 6. 상세 학습 내용

#### 함수 포인터를 사용할까 말까?

- 요약: 원래 하던데로 함수 포인터를 사용하지 않도록 작성해보자
- 함수 포인터를 list 로 저장하고 저장된 함수를 실행시키도록 한다면 specifier 를 위한 다양한 옵션 처리 함수를 한 번 정의하고 가져다가 사용하면 좋지 않을까?
- 나는 diouxX 와 같이 묶여서 field width 나 precision 을 똑같이 처리하도록 printf 가 의도되었다고 생각했다
- 그래서 의도된 틀이 존재하고 그에 따라 특정 함수를 실행하도록 만들면 된다고 생각했다
- 그런데 # 을 처리할 때 o 만 특별히 동작하는 부분이 있었다
- diouxX 가 묶여서 option 을 통일된 방식으로 처리하는 것이 아니었나보다
- 그래서 # 를 처리하기 전까지는 함수 포인터가 어울리지 않는다고 생각했으나 printf 라는 함수는 모든 각각의 specifier 가 자신만의 옵션 처리를 가질 수 있도록 의도된 것 같다
- 함수 포인터를 사용하여 specifier 마다의 option 처리 함수를 구성하는 것이 좋겠다고 생각한다
- 특정 specifier 를 위한 option 처리 함수들을 array 로 만들어두고 순차적으로 호출하며 문자열을 option 에 맞게 처리해주는 것은 마치 사진에 여러 필터를 이용하여 결과물을 얻어내는 것과 같다
- 이 경우 다양한 필터를 준비해두고 원하는 필터를 순차적으로 배치하여 세트로 묶어두면 적은 양의 기초 기능으로 다양한 복잡한 기능을 생성할 수 있다
- 그리고 어떤 복잡한 기능을 수정할 때 기초 기능을 순차적으로 실행하는 것이기에 복잡한 기능 하나를 이해하는 것보다 이해하기 편해진다
- 기초 기능을 추가하는 작업과 복잡한 기능을 생성하는 작업을 분업할 수 있다는 장점도 있다
- 함수 포인터를 사용할지 말지를 판단할 때
  - 해당 영역이 특정 틀 안에서만 동작하도록 의도할것인가
  - 아니면 모든 개별적인 것들이 자신만의 동작을 구성할 수 있도록 의도할것인가

```c
data = {
    { 'd', { a, b, d } },
    { 'i', { a, b, d } },
    { 'o', { b, c, d, e } }
    { 'o', { e } }
};
```

- 이런식으로 일렬로 늘어놓을 경우 문자 키에 대응하는 값의 크기가 가변적이기 때문에 각 키가 있는 위치가 몇 번째 바이트인지 파악하기가 어렵다 

```c
array_d = { a, b, d };
array_i = { a, b, d };
array_o = { b, c, d, e };
array_u = { e };

data = {
	{ 'd', array_d },
	{ 'i', array_i },
	{ 'o', array_o },
	{ 'u', array_u }
};
```

- 이런식으로 key 와 value 의 크기를 통일시켜준다면 key 와 value 의 위치를 알기 쉬워진다
- 그런데 각 array 의 크기를 알 수 없기 때문에 추가적인 장치를 할 필요가 있다
- 저번에 3 가지 정도를 들었었다
  - 크기를 표현하는 인자를 같이 전달, 배열 끝에 null 추가, 인자의 크기를 알 수 있는 문자열을 같이 전달
- 이 경우에는 배열의 끝에 'NULL' 을 넣어주면 좋을 것 같다
  - 나중에 option 을 적용하는 부분에서 array 안의 함수를 순차적으로 호출하면서 NULL 이면 멈추도록 직관적인 코드를 만들 수 있을 것이다
- 그리고 이 함수들의 목록을 위한 자료 구조로는 list 보다 array 가 어울린다
  - 프로그램이 실행되면서 바뀌지 않는 상수값이기 때문이다
- 그럼 이 상수 데이터를 메모리의 어떤 영역에 저장하는 것이 좋을까?
- 만약 스택이나 힙 영역에 이 상수를 저장한다면 매번 ft\_pirintf() 를 호출할 때마다 메모리에 값을 할당해야하는 단점이 있다
- data 영역에 저장하는 것이 좋아보인다
  - 한 번 저장해 놓으면 프로그램이 종료되지 않는 한 데이터가 계속 남기 때문이다
  - 그런데 그러면 ft\_printf() 프로그램을 몇 번 호출하지 않는 경우에 불필요한 메모리 공간을 차지하는 단점이 있다
- 역시 메모리 효율을 위해서는 매 호출마다 값을 새로 저장하더라도 stack 에 저장하는 것이 좋겠다
- 그런데 적용하려고 시도하다보니 printf 의 경우 사진의 필터처럼 기초 기능이 뚜렷하게 구분되지 않았다
- filed width 를 사용하여 padding 을 하려 할 때도 어떤 경우엔 '0' 을 넣고 어떤 경우엔 ' ' 를 넣는 등 하나의 기초 기능을 구현하더라도 세부적으로 여러 요인에 의해 처리 방식이 달라졌다
- 그래서 기초 필터끼리 간섭이 심하여 구분된 기초 필터를 만들기 어려운 경우에는 함수 포인터를 활용하는 것이 적합하지 않다고 생각한다

```zsh
* (HEAD -> dev) Modify pad_c() to pad_char() in apply_option_dioux.c
* Modify convert_dioux() in convert_dioux.c
* Modify set_spec_buf() in ft_printf.c
* Create real_ft_printf() in ft_printf.c
* Modify guard expression uniformly of form 'if(!(normal state))'
* Update %ls manage null value. And fix a memory leak.
```

- 코딩에 사용한 시간: 약 3 시간 30 분
- '%ls' 가 null 값을 처리하는 기능을 추가했다
- guard 라는 이름과 목적에 맞게 `if (!(정상 상황))` 의 형식으로 통일되도록 변경했다
- 프로그램 실행 중 에러가 발생 시 최상위 함수인 ft\_printf() 에서 처리하도록 하고 실질적인 작동은 real\_ft\_printf() 가 하도록 했다 (이름은 추후 바꿨으면 좋겠다)

### 7. 학습 내용에 대한 개인적인 총평

- 보고서를 작성할 때 주중에 4 개를 쓰고 일요일에 1개를 쓰는 생활이 반복되고 있는데 앞으로는 주중에 5개를 제대로 작성하도록 노력해야겠습니다. 하나만 미뤄두고 놀다가 나중에 작성하는 습관은 그다지 좋아보이지 않습니다.
- ft\_printf 의 보너스가 생각보다 만만치 않았습니다. 가능하면 내일 오는 평가 이벤트 중에 평가를 받고 싶었는데 지금 진행으로 보아 이번 평가 이벤트 중에는 평가를 받지 못할 것 같습니다.

### 8. 다음 학습 계획

- ft\_printf
  - Makefile 에 bonus rule 만들기
  - bonus 플래그 구현하기
  - 테스터 프로그램 돌려보기
    - 42PRINTF-TEST
    - pft
    - pft 2019
    - lover
  - 끝내기 전에
    - 코드 한 번 쭉 읽어보기
    - memory leak 검사
    - flow chart 작성하기
      - flow chart 에 메모리 할당, 해제 내용을 추가하면 어떨까?
