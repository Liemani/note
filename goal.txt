################################################################################
#check befor submit
{
	subject pdf
	42seoul-translation
	42seoul wiki
	평가지표
	slack
	norm
	leak
	symbolic link 를 실제 파일로 교체하기
}

#write first
{
	safari 읽기 목록 정리하기
	kernel panic
	iterator 구조체를 만들면 이 함수 저 함수로 보내며 반복 상태를 저장할 수 있어서 유용할 것 같다
	vimsession 은 정확히 특정 위치에 있는 파일을 여는 단점이 있다
		유동적으로 session 을 실행할 directory 를 설정할 수는 없을까?
	각종 intro 읽어보기
	구조체를 반환하면 어떻게 작동할까?
		구조체 전체를 복사하기 때문에 포인터로 하는 거에 비해 오래 걸린다는 것은 아는데, 그것이 구체적으로 어떻게 작동하는지는 모른다
	readline 을 보면서 cli short cut 을 익혀보도록 하자
}

#team
{
	어느정도로 구현할지 (서브젝트 제한 or 구현하고 싶은 만큼)
	상대의 코딩 관심사가 무엇인지 확인해두자
		나는 abstract class 등을 만드는 것을 좋아한다
	선택의 기로에 있을 때 모든 팀원이 의견을 제시하도록 한다
	같은 fd 에 부모 쓰고 자식 쓰고 하면 다 써지나?
	지금 당장 훌륭하지는 않지만 꾸준히 어제보다 나은 자신이 되도록 노력할 수 있는 분
	문제가 있을 때 주변을 탓하기 전에 자신의 변화로 다음에 문제가 발생하지 않을 방법을 생각해볼 수 있는 분
	의사소통 문제가 발생하더라도 다음에 같은 문제가 발생하지 않을 해결 방안을 탐구하고 적용할 수 있는 분
	프로토콜은 여러 사람이 같이 작업하기 위해 꼭 필요하다
		구조체를 프로토콜화하여 내부 데이터를 약속해서 저장하면 다른 사람이 코드를 볼 때 내부 구현을 보면서 구조체 내부에 어떤 값이 들어가는지 확인 할 필요가 없어진다
	서로 대화하면서 상처를 받을 수도 있을텐데, 그런 경우에도 서로를 포기하지 않고 서로를 이해하려 노력하며 더 상처를 덜 주는 방법을 배우면서 같이 성장할 수 있는 분
	시작한다 -> 하고 싶은 부분을 한다 -> 필요한 부분을 요청한다 -> 완료 or 인수
	개인적으로 쓰던 라이브러리 함수를 가져와서 사용하는 경우..?
	같이 공통으로 필요한 함수가 있는지 체크하고 정의하기
		한 명이 util 라이브러리를 관리해도 좋을 것 같다
	constant file 만들어서 공통된 상수를 사용하도록 하기
}

#minishell
{
	exit_code 를 lmt_process 에 저장해서 결과 값을 계산하는 것을 더 이해하기 쉽도록 만들기
	backup redirection 이 어떻게 작동하고 있는거지?
	todo
	{
		zsh 의 특징을 적용했던 부분을 bash 의 특성으로 교체하기
		{
			t_lmt_process_list_method.c/lmt_process_execute()
			'cd .. && pwd': parent process 에서 실행된다
			'pwd | cd ..': child process 에서 실행된다
			builtin, non-builtin 따지지 않고 자식 프로세스를 생성하여 실행
				이에 따라 builtin 의 경우 redirection 을 backup 했던 부분을 수행하지 않도록 수정
					하지만, || 나 && 에서는 parent process 에서 작동하므로 redirection 을 backup 해야 하는지 확실히 하기
					앞의 process 의 op 가 파이프라면 child 를 만들어서 실행하고 아니라면 그냥 실행한다
						이를 위해 lmt_process 에 previous 맴버 변수를 추가하자
		}
		backdown 이 어떻게 작동하는지 구체적으로 작성하기 (지금은 뭔가 이상하다, 왜 apply 후 free 를 하고 있지?)
		backup -> new_undo_list, backdown -> undo 로 이름 수정하기
		TYPE_PROCESS_NORMAL 을 TYPE_PROCESS_COMMON 으로 변경하기
		lmt_exit() 을 하지 않도록 수정하기
	}
	무조건 자식 프로세스를 생성해서 호출하기
	init.c/process_init() 의 중간에 process_line() 을 대신하여 lmt_process_manager_execute() 를 삽입하였다. 이를 간단하게 작동 가능하도록 수정하라
	t_lmt_process_method.c/lmt_process_set() 에서 t_lmt_token 을 사용하지 않도록 수정하기
	t_lmt_process_list_method.c/lmt_process_list_set_by_token_sublist() 에서 t_lmt_token 을 사용하지 않도록 수정하기
	seonkim 의 function 을 호출할 때 p_handler 를 인자로 건내주기
	tokenization directory 를 Makefile 에 등록하기
	<< 와 >> 추가하기
		t_lmt_redirection_method.c/lmt_redirection_new_by_token()
	parsing 을 입맛에 맞게 수정하기
	dup2 같은거 에러 처리 할지?
	test
	{
		echo hi 2>.temp1 there | (ls) && <.temp2 (pwd && echo hi) | cat > .temp3
		'<.temp cd >.temp2': 이후 fd 가 원상 복구되는지
	}
	token_list 의 last 를 어떻게 설정하며, token_sublist 의 last 는 무엇이어야 하는가?
		TYPE_NONE 이 last 가 되도록 하자(process_list_execute 를 위해)
	jeonpark 안에 중심 헤더 파일 만들기
	lmt_process_new_by_lmt_token_sublist();
	lmt_process_list_set_by_lmt_token_sublist();
	lmt_string_array
	shell 상에서 new line 을 추가하는 것 처럼 tab 을 삽입하는 방법도 있다
	fd 의 값을 dup 하되, 이후 쓰기 및 읽기 에러가 발생 시, 에러 메세지를 출력하도록 하자
	'n>file'
		- if 0 <= n <= max: normal operation
		- if n < 0: use as part of command
		- if n < max: occur error
	wait problem
	t_lmt_token 으로 argv 만들기
	testcase
	{
		redirection, |, ||, &&, () 혼용
		존재하지 않는 command 가 도중에 존재
	}
	0, 1, 2 외의 값에 대한 redirection
	pipe 의 fd 와 pipe 이전 command 의 redirection 이 어떻게 처리되는지
	#define _W_INT(w)	(*(int *)&w)
	#define WEXITSTATUS	((_W_INT(x) >> 8) & 0x000000ff)
	redirection 으로 큰 숫자가 들어와도 처리가 가능하도록 수정하기
	ls | exit
	set, env
	>> 와 << 알아보기
	later team talk
	{
		시간 날 때 괄호도 잘라달라고 하자
	}
	argv 를 입력받아서 excve 등을 실행하는 프로그램
	이모지를 바이트 데이터로 수정하기
	word splitting (read IFS referencing docs)
	파이프로 연결된 process 중 하나라도 존재하지 않는 명령이 들어오면 아무것도 실행되지 않는다
	파이프가 올 때 cd 가 안되는 것은 자식 프로세스에서 실행되서 그런가?
	리다이렉션도 파싱 가능하도록 수정하기
	single quote, double quote, variable expansion
	fd 작동 원리 파악하고 max 이하의 (기본 255) fd 도 받도록 하기
	process 들은 부모가 모든 자식 process 를 만든다
	clear child process 가 종료되지 않는 문제
	process 가 여러 개 실행중이면 signal 은 어떻게 작동하지?
	fd 가 큰 값이 들어와도 redirection 을 제대로 수행하도록 하기
	의존성 체크하기
	초기화하지 않은 fd 를 리다이렉션으로 입력한 경우
	파이프 앞의 잘못된 커맨드가 종료되거나 실행되지 않거나 하면, 뒤에 있던 커맨드는 stdin 을 어떻게 대하나? cat 의 경우 아무것도 출력하지 않던데
	code 상에 unicode character 를 넣지 않더라도 환경변수로 입력받아서 사용하는 방법
	readline 을 사용할 때 긴 줄이 들어오면 커서가 carriage return 하는 현상
	'<none command> | <command>' 의 경우 command 만 실행된다
	'<command> | <none command>' 의 경우 command 만 실행되며 결과 값이 출력되지 않는다
		실패 메세지가 먼저 뜨고 실행되는데, 리다이렉션은 어디로 날라가는거지?
		게다가 동시에 실행되니 뒤에 것이 인자를 받을 필요가 없으면 먼저 실행하면서 종료해버리네?
		만약 '<command> | <none command> | <command>' 이면 뒤의 command 는 먼저 실행이 종료 될 수도 있다
		'sleep 10 | cat' 은 cat 이 종료되지 않고 기다린다
		'sleep 10 | sleep 1' 은 뒤의 sleep 이 먼저 종료된다
			(sleep 이 standard input 을 사용하지 않기 때문에?)
	권한이 없는 파일에 redirection 을 시도하면 어떻게 되나?
	PATH 에서 프로그램을 search 할 때는 path 의 인자를 앞에서부터 순차적으로 탐색한다
	PATH 값을 수정하면서 내 프로그램이 실행되는지, 기본 프로그램이 실행되는지 테스트해보자
	leak 검사
	wait 중에 signal 을 받을 때 어떻게 할까?
	argv 의 문자열 포인터를 다른 문자열 포인터로 치환하면 leak 이 발생할까?
	나중에 stat 읽어보고 사용해보기 (inode 등)
	stat 을 사용한 파일 검사
	'process1 | process2' 에서 process2 는 process1 이 output 하는 것을 기다리는가?
		bash 에서는 일단 한꺼번에 process 를 생성해두기는 한다
	close 한 fd 에 write 등을 하면 어떻게 될까?
	'command ls' 는 stdard output 이 '/dev/fd/1' 이냐, 다른 파일이냐에 따라 다른 행동을 하는 것 같다
		minishell 을 완성하면 테스트해보자
	'ls > test' 를 하면 test 자신의 이름도 ls 로 인해 출력된 것이 저장되지만 크기는 0 으로 나온다
	'<<' 는 '<C-D>' 에 어떻게 반응하나?
	execve 사용해보기
	getenv() 와 envp 의 차이
	functions
	{
		isatty
		ttyname
		ttyslot
		ioctl
		tcsetattr
		tcgetattr
		tgetent
		tgetflag
		tgetnum
		tgetstr
		tgoto
		tputs
	}
	chdir() 을 하면 'PWD' 환경 변수가 변하는가?
	여러 줄을 읽게 할 필요가 있는가?
	'<C-t><ESC>' 를 누르면 prompt 가 내용을 가리는 문제(?)
	'nice to meet you!' 를 입력하면 다음 prompt 가 스킵되는 현상
	envp 와 getenv() 의 차이점
	파이프 실제 동작 테스트
	line 으로부터 command 생성
	각 프로세스의 fd table 은 각각 존재하나?
		자식 프로세스의 fd 0 을 close 해도 부모 프로세스의 fd 0 은 살아있겠지?
	'<C-D>': exit 출력하는 함수 만들기
	sigaction 을 signal 을 사용하도록 수정하기
	control-c, control-d 화면에 안찍히도록 수정하기
	read_line free 하기
	type
	{
		0: 잘못된 값 -> 바로 오류
		1: 명령어
		2: symbol
	}
	$PATH parsing
	env from argument vs getenv()
	환경 변수와 지역 변수의 값을 shell program 과 동기화하도록 해야하는가?
		PS1 은 local variable 이다
		command 는 PATH 에서 검색하여 찾는다
	readline
	rl_on_new_line
	ioctl
	Makefile 에 Stdheader 넣기!!
	readline 의 return value 는 free 를 해줘야 한다
	불필요한 경우 add_history 를 하지 않도록 하기
	split 't_philos_method.c/philos_run()' several functions
	any command ending with '&' is run in the background
	export
	{
		local variables can be local or environment
		environment variables are part of UNIX
		turn local variable into environment
	}
	build-in commands are internal to the shell and do not create seperate process
	command search rules
	{
		special built-ins
		functions
			command bypasses search for functions
		built-ins not associated with PATH
		PATH search
		built-ins associated with PATH
	}
	how the shell parses
	{
		read the command
		{
			read one or more lines a needed
			seperate into tokens using space/tabs
			form commands based on token types
		}
		evaluate a command
		{
			expand word tokens(command substitution, parameter expansion)
			split words into fields
			file expansion
			setup redirections, environment
			run command with arguments
		}
	}
	token types
	{
		control operators (||)
		redirection operators (<)
		reserved words (if)
		assignment tokens
		word tokens
	}
	ioctl()
	환경 변수 읽는 법
	환경 변수 쓰는 법
	main 의 3 번째 인자
	tab 을 복사하여 넣어주는 경우 테스트
	git 을 사용할 때 merge 등을 하기 싫다면 아예 분리된 directory 에서 작업하는 방법이 있다
	libft 어떻게 사용해왔는지
	conform norm
	no error quit
	각종 builtin 함수에 대한 공식 설명도 있을까?
}

minishell 팀원과 첫 만남 'seonkim'
{
	pipe 등이 나오기 전까지 cmd flag 를 1 로 유지해서 작동시킨다
	signal control-D
	의견 교환 이전에
	{
		no ebelin! 의사 합의를 하지 않도록 해보자
		가볍게 대화 가능한 주제
			subject pdf 의 의미 해석
		가볍게 대화가 불가능한 주제
			stack or heap
			data type
			data structure
			이 경우 가볍게 토론하기보다 깊게 생각해보고, 둘 다 충분히 준비가 되면 이야기를 나누는 방식을 선호한다. 둘 다 잘 모르는 상태에서는 얘기해봤자 가벼운 이야기만 오갈 뿐이라고 생각한다

		어떻게 생각하시는지?
	}
}

env
{
	util 에 가변 배열도 하나 만들어두면 잘 사용하겠다
	'aux where <aux command>': Print the path of aux command shell script
	$git 이 ~/git 이었으면 좋겠다 (programming 은 너무 길었다)
	git back 관련 command 가 불필요한 git 에 대해서는 짧게 출력하여 가독성을 높여보자
	structure 의 image 를 upload 하기
}

project/main
{
	modify function's name convention of 'alloc, init, new, free' from prefix to suffix
	exit 이 없더라도 lmt_error.h 에 exit_code 를 적어두는 것은 좋다
		- 언제든 함수의 반환 값을 다시 반환할 때, 다른 에러 발생으로 함수를 종료할 때 이 exit_code 를 사용하면 된다
	unsafe 함수들은 unsafe prefix 를 붙이자
	main/util/lmt_atoi 가 "-" 를 0 으로 반환하는 문제 -> 반환 순서를 조금 뒤로 (philo1 참고)
	util.h 를 lmt_util.h 로 바꾸자
	directory name 도 util 에서 lmt_util 로
	util.c 는 lmt_write.c 등으로 함수 하나만 사용하도록
	add 'unsafe/lmt_strcpy.c'
}

#philosophers
{
	홀수 철학자 문제 해결하기
	포크 수는 철학자의 수와 같으니 철학자가 한 명만 있을 때도 포크가 존재할 것이다. 하지만 포크는 철학자 사이에만 존자하는 것 아니었나?
	나는 마이크로 세크 단위로 측정을 하는데 출력될 때 밀리세크라 차이가 눈에 보이지 않고 철학자가 죽으면 이상하지 않을까?
	마지막 식사 시간을 복사해올 때 에러 발생 가능
		뮤택스로 막아두고 복사해올 것?
		이 경우 문제가 발생하지는 않는지 생각해보자
	Makefile 에 Stdheader 넣기!!
	headeer file 의존 관계 오류 없는지 체크하기
	프로그램의 thread 수에 따른 usleep(1000) 에 걸리는 평균 시간 (외부 환경 미포함)
	usleep(1000) 과 usleep(100000) 과 usleep(1) 이 모두 sleep 이 끝나는 시간 차이가 다르다. 단순 배수만 해준다고 해결되는 부분이 아니다 (usleep 이 어떻게 구현되어 있는가를 잘 아는 것이 필요할 수도 있다)
	p_pen 의 buffer 별로 수정을 위한 mutex 를 만들고, 출력을 위한 mutex 를 따로 두면 성능이 향상된다
	if there is only one philosopher, it must die
	eat 카운트는 먹기 전에 올릴까 먹은 후 올릴까?
	가능한 많은 case 를 실행 가능하도록 지원하자
	10ms 안에 dead 를 출력해야 하는데, 한 바퀴 돌고 main thread 가 다시 실행되는 데 까지 걸리는 시간이 얼마일까?
	last
	{
		실행 흐름을 쭉 훑어보기
		에러가 깊숙한 곳부터 끊이지 않고 잘 전달되는지 확인하기
	}
	philosopher가 1 명인 경우 포크가 없어 죽도록 하자
	lmt_exit 을 사용할 수 없으니 이전 방식대로 return 값을 확인하도록 하자 (특히 util.c 등)
	basic rules
	{
		no norm error
		no leak
		no crash
		no undefined behavior
		philosopher must eat with two forks
		philosophers don't speak with each other
			'필로소퍼끼리 포크를 집는 순서를 결정하지 않는다' 라고 생각하자
		each time a philosopher has finished eating, he willl drop his forks and start sleeping
		when a philosopher is done sleeping, he will start thinking
		program options
		{
			number_of_philosophers
				== number of philosophers == number of forks
			time_to_die (milliseconds)
				if a philosopher doesn't eat during, dies
			time_to_eat (milliseconds)
				time it takes for a philosopher to eat, will occupy 2 forks
			time_to_sleep (milliseconds)
				time the philosopher will spend sleeping
			[number_of_times_each_philosopher_must_eat]
				if not specified, the simulation will stop only at the death of a philosopher
		}
		any change of status of philosopher must be written as follows
			timestamp_in_ms X has taken a fork
			timestamp_in_ms X is eating
			timestamp_in_ms X is sleeping
			timestamp_in_ms X is thinking
			timestamp_in_ms X died
		must print death before to elapse 10 ms
	}
	external functions
	{
		void	*memset(void *b, int c, size_t len);		<string.h>
		int		printf(const char * restrict format, ...);	<stdio.h>
		int		usleep(useconds_t microseconds);			<unistd.h>
			typedef unsigned int useconds_t:
		int		gettimeofday(struct timeval *restrict tp, void *restrict tzp);	<sys/time.h>
		{
			struct timeval
			{
				time_t		tv_sec;
					// typedef long time_t;
				suseconds_t	tv_usec;
					// typedef int suseconds_t
			};
		}
		int		pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);	<pthread.h>
		{
			typedef struct	_opaque_pthread_t
			{
				long		__sig;
				struct __darwin_pthread_handler_rec	*__cleanup_stack;
				char		__opaque[__PTHREAD_SIZE__];
			}				*pthread_t;
			struct		__darwin_pthread_handler_rec
			{
				void	(*__routine)(void *);
				void	*__arg;
				struct __darwin_pthread_handelr_rec	*__next;
			};
			typedef struct	_opaque_pthread_attr_t
			{
				long		__sig;
				char		__opaque[__PTHREAD_ATTR_SIZE__];
			}				pthread_attr_t;
		}
		int		pthread_detach(pthread_t thread);	<pthread.h>
		int		pthread_join(pthread_t thread, void **value_ptr);	<pthread.h>
		int		pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);	<pthread.h>
		{
			typedef struct	_opaque_pthread_mutex_t
			{
				long		__sig;
				char		__opaque[__PTHREAD_MUTEX_SIZE__];
			}				pthread_mutex_t;
			typedef struct	_opaque_pthread_mutexattr_t
			{
				long		__sig;
				char		__opaque[__PTHREAD_MUTEXATTR_SIZE__];
			}				pthread_mutexattr_t;
		}
		int		pthread_mutex_destroy(pthread_mutex_t *mutex);	<pthread.h>
		int		pthread_mutex_lock(pthread_mutex_t *mutex);	<pthread.h>
		int		pthread_mutex_unlock(pthread_mutex_t *mutex);	<pthread.h>
	}
	summary
	{
		You can’t have more than 10 ms between the death of a philosopher and when it will print its death
	}
	need guard
	{
		int pthread_create(&thread, NULL, handler, arg);  // 0 : error
		int pthread_mutex_init(&mutex, NULL);  // 0 : error
	}
	don't need guard
	{
		usleep(int);  // signal 을 받을 때의 작동은 신경쓰지 않는다
		gettimeofday(struct timeval *, NULL);  // 인자가 NULL 이 아니도록 신경쓴다
		pthread_detach(thread);  // 정상적인 thread 인지 신경써준다 (벌써 detach 됐거나 없는 thread 이면 안된다!)
		pthread_mutex_lock(&mutex);  // valid mutex
		pthread_mutex_unlock(&mutex);  // valid mutex, thread hold a lock on mutex
	}
}

#idea
{
	만약 대각선 이동이 일반 선형 이동의 sqrt(2) 배 만큼의 속도라면 상단 중앙에 있는 적으로부터 딜레이가 존재하는 일정 두께의 레이저 공격을 피하기 위해 하단 가운데보다는 하단 측면에 위치하는 것이 유리하다. 하지만 레이저가 일정 시간 유지되며 플레이어의 선형 속도만큼의 속도로 추적한다면 측면 벽에 딱 붙을 경우 회피할 공간이 적어진다. 이 수치를 적절히 조절하여 가운데도 아니고 벽도 아닌 최적의 공간이 존재하도록 유도할 수 있다
	방송으로 막 송출을 하다가 클립을 따서 위키 페이지에 정리하는 방식으로 프로젝트를 진행한다면 새로 들어오는 시청자도 클립으로 주요 부분을 이해하고 쉽게 참여가 가능하지 않을까?
	테스트 환경을 잘 만들어도 좋겠다
	문자열, 숫자, 문자 등을 생성하여 인자로 넣어주는 프로그램
	(각 인자는 범위 등을 지정 할 수도 있다!)
	여러 명이 협업을 진행하게 되면 코드의 온전성이 중요해질 것 같다
		- 테스트를 하여 온전하게 작동하는 코드인지를 확실하게 하고 추가하는 것이다
}

#future
{
	다양한 c library 를 구비해두고 필요한 모듈을 가져다가 쓰는 방식으로 프로그램을 작성하면 재밌을 것 같다
	program counter(pc)
	nlp
	{
		tokenization
		stemming
		lemmatization
	}
	lexic
	filedescriptors
	file table
	inode table
	test program 등 유용한 shell script 를 위키처럼 관리할 수 있도록 운영하는 깃 레포를 하나 만들고 싶다
	automata
		regex -> 유한 상태 머시기 -> 유한 상태 머시기
	siteTool
	  블로그 만들고 작성하기!!!
	variabledText
	  cli 에서 변수 값을 인자로 넣어줄 수 있으면 좋겠다
		'variabledText <path> -v <identifier>=<value>
	  '-o' 로 결과 파일을 직접 입력하는 것이 아니라 파일 내에 meta data 를 text 로 기록해두고 읽어서 사용하도록 하면 어떻까?
	  변수의 값에 '\n' 를 넣을 수 있게 하려면 변수 간의 delimiter 를 '\n' 로 하면 안되는 걸까?
	  변수 식별자를 일괄적으로 바꾸는 추가 기능
	  다양한 경고 (위치와 해당 라인 출력)
		정의하지 않은 식별자 사용 경고
		사용하지 않은 식별자 정의 경고
		중복 정의된 식별자 경고
	env
	  setenv 가 basecamp 를 입력받아서 패키지를 구성하도록 변경하기
	  전반적인 초기 과정을 추적해보자, ssh key 를 적용하기 위해서 필요한 것들 -> 어디에 적용할지 사이트 주소
	기록이 먼저
	  아마존 무료 클라우드 호스팅 서비스 알아보기
	  내가 프로그램 지능이 나보다 낮은 사람에게 알려줄 수 있는 것은 앞길과, 그 시기에는 원래 그렇게 힘들다는 것이다
	  프로그래밍 단어 정규화
	  자동으로 웹에 백업되는 것도 좋지만, 시간이 오래 걸리는 작업이기 때문에 캐쉬를 기본으로 하고 필요에 따라 사용자에게 백업 및 풀 권한을 주는 것도 좋을 것 같다
	  생각
		프로그램의 구조를 다 보여주는 프로그램은 어떨까?
		  lldb 처럼 디버깅용 프로그램인데 어떤 함수에 어떤 변수가 존재하는지 다 보여주고 어떤 변수가 어떤 변화과정을 겪었는지 연대기를 다 보여주는거지
		생각을 적게 해야할 부분
		  여러 이름들, 최선의 이름은 있겠지만 최고의 이름은 없다
	  how to multi line quote in md
	  인자가 특정 값이면 0 을 반환하는 함수?
	  env 가 setenv.sh 를 실행할 때 설정해줘야하는 파일을 vim 으로 열어도 좋을 것 같다
	  va_list 인자는 기존 인자와는 다른 방식으로 작동하는 모습을 보이는 것 같다. 더 큰 크기의 인자로 받아들일 때도 입력받은 인자의 크기만큼을 가져온다. 내부적으로 어떻게 되어있는 것일까?
	  기록 관리 프로그램 in cli!!!!
		git 처럼 vcs 이 아니라 기록 control system 을 만들자!
		git 에 자료를 보관하면서 보관되어 있는 자료를 쉽게 control 하는거지!
	  블로그에 날짜 표시하기
	  함수 이름을 여러개로 쓸 수 있도록 필요할 때마다 추가할 수 있도록 하면 결국 지저분해질 뿐이다, 따라서 문서 편집기에서 특정 이름들을 특정 상수로 바꾸도록 처리하여 서로 다른 이름을 쓰더라도 결국 같은 상수가 되도록 처리하는 것이 좋다. 일괄적으로 변수 이름을 바꾸는 기능을 상위단에서 제공하는 것이다
	  모든 local repo 의 branch 를 출력하는 프로그램은 어떨까?
	  문서편집기인데 모든 문자들이 저마다의 태그를 가지고 있고 특정 태그의 특정 문자나 단어를 replace 할 수 있는 프로그램
	  ':set all': display all set
	  데이터를 마구마구 던지면 알아서 구조화하고 정리해주는 프로그램
	  일단 명령을 입력하기가 무조건 쉬워야 한다 (혹은 alias 를 사용할 수도 있겠지), 그러고 나서 보기 좋게 출력하는 것은 추가적인 출력 프로그램이 담당하는 것!
	항시 정리하기
	  북마크
	  읽기 목록
	  하드
	  메모
	  슬랙 saved
	  back command 가 인자를 받아서 해당 git repo 만 처리하도록 하자
	git
	  how to get the content of hash?
	lldb
	  특정 시그널 보내기
	  'memory read': 메모리를 출력함
	  변수 값 읽기 쓰기에 따른 breakpoint 설정
	책
	  50/288 : The C Programming Language
	  늑향: 10 권 114p
}
