philosophers

홀수 철학자 문제 해결하기
포크 수는 철학자의 수와 같으니 철학자가 한 명만 있을 때도 포크가 존재할 것이다. 하지만 포크는 철학자 사이에만 존자하는 것 아니었나?
나는 마이크로 세크 단위로 측정을 하는데 출력될 때 밀리세크라 차이가 눈에 보이지 않고 철학자가 죽으면 이상하지 않을까?
마지막 식사 시간을 복사해올 때 에러 발생 가능
	뮤택스로 막아두고 복사해올 것?
	이 경우 문제가 발생하지는 않는지 생각해보자
Makefile 에 Stdheader 넣기!!
headeer file 의존 관계 오류 없는지 체크하기
프로그램의 thread 수에 따른 usleep(1000) 에 걸리는 평균 시간 (외부 환경 미포함)
usleep(1000) 과 usleep(100000) 과 usleep(1) 이 모두 sleep 이 끝나는 시간 차이가 다르다. 단순 배수만 해준다고 해결되는 부분이 아니다 (usleep 이 어떻게 구현되어 있는가를 잘 아는 것이 필요할 수도 있다)
p_pen 의 buffer 별로 수정을 위한 mutex 를 만들고, 출력을 위한 mutex 를 따로 두면 성능이 향상된다
if there is only one philosopher, it must die
eat 카운트는 먹기 전에 올릴까 먹은 후 올릴까?
가능한 많은 case 를 실행 가능하도록 지원하자
10ms 안에 dead 를 출력해야 하는데, 한 바퀴 돌고 main thread 가 다시 실행되는 데 까지 걸리는 시간이 얼마일까?
last
{
	실행 흐름을 쭉 훑어보기
	에러가 깊숙한 곳부터 끊이지 않고 잘 전달되는지 확인하기
}
philosopher가 1 명인 경우 포크가 없어 죽도록 하자
lmt_exit 을 사용할 수 없으니 이전 방식대로 return 값을 확인하도록 하자 (특히 util.c 등)
basic rules
{
	no norm error
	no leak
	no crash
	no undefined behavior
	philosopher must eat with two forks
	philosophers don't speak with each other
		'필로소퍼끼리 포크를 집는 순서를 결정하지 않는다' 라고 생각하자
	each time a philosopher has finished eating, he willl drop his forks and start sleeping
	when a philosopher is done sleeping, he will start thinking
	program options
	{
		number_of_philosophers
			== number of philosophers == number of forks
		time_to_die (milliseconds)
			if a philosopher doesn't eat during, dies
		time_to_eat (milliseconds)
			time it takes for a philosopher to eat, will occupy 2 forks
		time_to_sleep (milliseconds)
			time the philosopher will spend sleeping
		[number_of_times_each_philosopher_must_eat]
			if not specified, the simulation will stop only at the death of a philosopher
	}
	any change of status of philosopher must be written as follows
		timestamp_in_ms X has taken a fork
		timestamp_in_ms X is eating
		timestamp_in_ms X is sleeping
		timestamp_in_ms X is thinking
		timestamp_in_ms X died
	must print death before to elapse 10 ms
}
external functions
{
	void	*memset(void *b, int c, size_t len);		<string.h>
	int		printf(const char * restrict format, ...);	<stdio.h>
	int		usleep(useconds_t microseconds);			<unistd.h>
		typedef unsigned int useconds_t:
	int		gettimeofday(struct timeval *restrict tp, void *restrict tzp);	<sys/time.h>
	{
		struct timeval
		{
			time_t		tv_sec;
				// typedef long time_t;
			suseconds_t	tv_usec;
				// typedef int suseconds_t
		};
	}
	int		pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);	<pthread.h>
	{
		typedef struct	_opaque_pthread_t
		{
			long		__sig;
			struct __darwin_pthread_handler_rec	*__cleanup_stack;
			char		__opaque[__PTHREAD_SIZE__];
		}				*pthread_t;
		struct		__darwin_pthread_handler_rec
		{
			void	(*__routine)(void *);
			void	*__arg;
			struct __darwin_pthread_handelr_rec	*__next;
		};
		typedef struct	_opaque_pthread_attr_t
		{
			long		__sig;
			char		__opaque[__PTHREAD_ATTR_SIZE__];
		}				pthread_attr_t;
	}
	int		pthread_detach(pthread_t thread);	<pthread.h>
	int		pthread_join(pthread_t thread, void **value_ptr);	<pthread.h>
	int		pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);	<pthread.h>
	{
		typedef struct	_opaque_pthread_mutex_t
		{
			long		__sig;
			char		__opaque[__PTHREAD_MUTEX_SIZE__];
		}				pthread_mutex_t;
		typedef struct	_opaque_pthread_mutexattr_t
		{
			long		__sig;
			char		__opaque[__PTHREAD_MUTEXATTR_SIZE__];
		}				pthread_mutexattr_t;
	}
	int		pthread_mutex_destroy(pthread_mutex_t *mutex);	<pthread.h>
	int		pthread_mutex_lock(pthread_mutex_t *mutex);	<pthread.h>
	int		pthread_mutex_unlock(pthread_mutex_t *mutex);	<pthread.h>
}
summary
{
	You can’t have more than 10 ms between the death of a philosopher and when it will print its death
}
need guard
{
	int pthread_create(&thread, NULL, handler, arg);  // 0 : error
	int pthread_mutex_init(&mutex, NULL);  // 0 : error
}
don't need guard
{
	usleep(int);  // signal 을 받을 때의 작동은 신경쓰지 않는다
	gettimeofday(struct timeval *, NULL);  // 인자가 NULL 이 아니도록 신경쓴다
	pthread_detach(thread);  // 정상적인 thread 인지 신경써준다 (벌써 detach 됐거나 없는 thread 이면 안된다!)
	pthread_mutex_lock(&mutex);  // valid mutex
	pthread_mutex_unlock(&mutex);  // valid mutex, thread hold a lock on mutex
}
