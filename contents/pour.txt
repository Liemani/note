- 생각을 자유롭게 써내려가는 공간
- 단, 여기에 작성한 글은 참고는 하되 정리하지는 않는 것을 원칙으로 한다
- 나의 자유로운 생각보다는 얻은 지식을 base 로 정리하는 방식으로 작성해보자
- 문제가 발생하면 전부 기록하자. 다 성장에 도움이 된다



# 2021-10-07

- 'ctags': aux ctags . .
- 지금 하고 있는 일이 어떤 경로로 지금에 이르렀는지 꾸준히 기록해두자. 뭘 위해 뭘 하고 있었는지 까먹는 경우가 종종 있다.



# 2021-10-06

- 'git branch -d -r origin/jeonpark_new'



# 2021-10-05

- 내가 짠 코드를 직접 읽기 보다는 위에 적힌 설명을 읽고 이해하기가 쉬웠다면, 코드를 예쁘게 작성하고 있지 않다는 뜻 아닐까?
- 실행 흐름에 따라 프로그램을 쌓아나가듯이 제작하면 추가적인 코드 테스트용 코드가 적어질 수 있다.
	- 만약 각자 맡은 모듈을 제작하고 결합하려고 한다면, 각 모듈별로 테스트용 코드가 필요할 것이다.
		- 하지만 각 모듈읠 안정성을 검증하기에는 더 좋을 것이다.



# 2021-10-04

- 한 번 잠을 자기 시작하면 3 시간은 자게 된다. 잠을 자지 않기 위해 노력을 해보도록 하자. 가장 좋은 방법은 생각했던 프로그램을 빠르게 코딩하는 것이다.



# 2021-10-03

- 코드의 원본에 직접 주석으로 설명을 다는 것이 아니라, 마치 숫자로 표시하고 밑에 주석을 달듯이 설명을 추가하면 보다 기존 코드를 방해하지 않는 채로 설명이 가능해질 것 같다
- xxd test.txt | xxd -r
- xxd test.txt | xxd -r -s 100
- echo "00000010:31" | xxd -r - <path>
- echo "100:41" | xxd -r > <path>
- echo "100:41" | xxd -r -s -0x100 > <path>
- 'man -k <keyword>'
- 'apropos <keyword>'
- 'which, type'



#2021-10-02

- 제품을 만든다는 것은 가능한 모든 것을 우겨넣는 것이 아니다. 핵심적인 것을 추가하고, 불필요한 것은 차단하는 것이다. UNIX 도 그런식으로 모델을 디자인하여 구현된 것이다.



#2021-09-27

- 함수가 반환하는 값에 따라 함수가 에러 상태로 반환됐는지 등을 확인하는 것은 필수적인 과정이다. 그리고 내가 그 함수의 에러 여부를 어느정도 입력값 등으로 통제할 수 있는가도 제대로 파악해두는 것이 함수를 제대로 사용하는 것이다
- 'Liemani/cLibrary' 에서 'general class' 를 구현하기 위해 'kernel class' 를 구현했었는데, 따라서 'kernel class' 는 'general class' 의 기능을 사용하는 것이 아니라 그 골격을 구성하는 구조로 만들었다.
	- 마찬가지로 os 의 page 관리 시스템이 메모리 할당을 담당할텐데, 자기 자신의 메모리 할당에 대해서는 generic 한 함수를 사용하지 않을 것 같다	- 이런식으로 우리는 단순히 malloc() 이라는 함수를 사용할 때, 사실 이 함수가 제대로 작동하기 위해서는 시스템이 그 기반을 마련해주기 때문에 가능한 것이다
- 프로그램 곳곳에서 magic number 를 마치 약속된 고정 수 인것처럼 사용하는 것이 아니라 define 등으로 상수를 선언하여 사용하는 것이 좋다
	-  상수 값을 바꾸어도 실제 문서에는 상수의 이름이 기록되어 있기 때문에, 모든 문서의 해당 상수를 변경할 필요 없이 완성된 프로그램의 상수 값을 간단히 수정할 수 있는 장점이 있다.
- 자료를 잘 모아두고 정리하는 것은 현대 사회에서 매우 중요한 작업이다. 그런데 이를 raw 하게 처리해주는 프로그램이 적다는 것이 아쉬울 따름이다. 데이터 자료를 구조화하는 standard model 을 정의하고 이로 encode, decode 하는 프로그램을 만들면 좋을 것 같다
- 'git rebase -i' 는 순서를 변경했을 때 단순히 기록된 차이점을 사용하는 것이 아니라, 각 commit 의 tree 를 그 때 그 때 비교하여 새로 추가된 파일을 탐색하는 것 같다



#2021-09-21
- 'git checkout --ours -- <path>'
- 'git checkout --theirs -- <path>'
- 포인터 타입의 값을 읽고 쓰는 것과, 일반 변수를 읽고 쓰는 것에 속도 차이가 있을까?
	- 어셈블리 코드를 비교해봐야 알 수 있을 것이다
- 'git cherry-pick A^..B'
- 'git cherry-pick A..B'



#2021-09-20

- 'man 2 execve'
- 'man 5 a.out'
- 'man 1 as'
- 'man 1 ld'
- 'man 7 environ'
- 'execve()' 가 성공하면 닫히고, 실패하면 닫히지 않도록 특정 fd 를 설정할 수 있다(fcntl() 로)
- argv 는 항상 null terminate 임이 보장되기 때문에 execve 의 두번째 인자로 사용할 수 있다
- 't_lmt_string *lmt_string_split_first(t_lmt_string *string, size_t count)' 처럼 전 후로 어차피 string->count > count 인지를 판단해야만 한다면, 굳이 이 함수의 구현에서 그 작업을 하지는 말자
	- 이 함수 내부에서 string->count > count 에 따른 처리를 해 준다고 해도, 호출부에서 return value 가 empty 인지를 확인하는 추가 작업을 해야하기 때문에, 처음부터 string->count > count 여부를 호출부에서 처리하도록 디자인하자
- [Apple Thread](https://developer.apple.com/documentation/foundation/thread)
	- When you need to perform a lengthy task, but don't want it to block the executioin of the rest of the application
	- In particular, you can use threads to avoid blocking the main thread of the application, which handles user interface and event-related actions
	- Threads can also be used to divide a large job into several smaller jobs, which can lead to performance increases on multi-core computers
- 프로그램이 종료되면 해당 프로그램에서 생성된 thread 들은 알아서 종료되는 것일까? 어떤 상황에서라도?
- [Thread wiki](https://en.wikipedia.org/wiki/Thread_(computing)
- 다 multi-thread 로 처리하면 되지 multi-process 는 왜 사용하는 거지?
	- minishell 과 philosophers bonus 가 multi-process 를 사용한다
	- thread 처럼 자원을 공유하지 않고 완전 별개의 프로그램처럼 취급하고 싶을 때 유리할 것 같다
	- A process is a unit of resources
	- A thread is a unit of scheduling and execution



#2021-09-19

- predicate: iterate 하게 traverse 하면서 참과 거짓을 따질 때 그 참 거짓을 분별하는 함수를 predicate 라고 한다



#2021-09-18

- 다양한 기능들을 복합적으로 섞지 말고 가능하면 쪼개서 추가/제거가 쉬운 구조로 만들자
- 다양한 타입의 list 를 구현할 때, 한 번 list 를 구현하고 사용하는 방법은 크게 2 가지가 있다
	- 'void *' 타입 의 member variable 을 content 로 갖는 list
		- 이 경우 간단하게 구현하여 사용이 가능하지만 element 의 값에 접근할 때 content 의 주소로 접근해야하는 오버헤드가 존재한다
	- list 로 만들 구조체를 위한 전용 list 형태의 구조체
		- 이 경우 각 list 구조체가 해당 type 의 구조체 데이터를 직접 소유하므로, 주소를 통해 데이터에 접근해야하는 오버헤드는 존재하지 않지만, list 화 할 type 에 대해 각각의 list 형태의 구조체를 정의해야만 하는 번거로움이 따른다, 따라서 실질적으로 이 것을 지원하기 위해서는, 이를 지원하기 위한 추가 작업이 선행되어야 한다
- list 는 append 에 불리하다
- 따라서 append 를 하고자 한다면 list 를 수정해서 사용해야만 한다
- set, array, list, stack, queue, dictionary, sequence, iterator
- sequence 를 구현하면서, append 함수를 만드는데, 만약 dummy node 를 두지 않는다면 append 시에 sequence 의 last 가 NULL 인지를 check 하여 다른 행동을 하도록 만들어야 한다. 이것이 싫어서 메모리를 조금 차지하지만 dummy node 를 두었다
- sequence 와 collection, 이 둘은 배열적 특성인 random access 가 가능한가를 기준으로 구분된다
	- sequence 는 random access 를 지원하지 않는다
	- collection 은 random access 를 지원한다
- traverse 는 방향과 차원에 상관 없이 탐색하는 느낌이고, iterate 는 선형적으로 진행하는 느낌이다



#2021-09-16

- data segment 의 값을 프로그램이 바꾸려고 하면 bus error 가 발생한다
- general command tty: print current ttyname
- man stty
- man 4 termios
- [ieee](https://ieeexplore.ieee.org/document/6880751) 에서 발견한 문서의 doi 를 [sci-hub](https://sci-hub.se) 에서 검색하여 문서를 다운로드 할 수 있다?
- success & failure
- ps xao pid,ppid,pgid,comm
- ps -o tty,pid,ppid,pgid,comm



#2021-09-15

- 생각은 기록보다 빠르다, private 암호와 등으로 속기 기술을 익힌다면 어떨까?
	- 복호화하여 public 이 이해 가능한 형태로 바꾸는 기술이 동반되어야 할 것이다
- minishell tokenize: structure 를 재귀적으로 사용했다면 어땠을까?
- mathmatical expression 을 tokenize 해보기
- <C-f>
- <C-b>

- <M-f>
- <M-b>

- <C-a>
- <C-e>

- <C-_>: undo
- <C-x C-u>: undo

- <C-d>
- <C-h>

- <M-d>
- <M-DEL>
- <C-w>

- <C-y>

- <M-digit><command>
- <M-TAB>: insert a tab character
- <C-t>: swap two characters
- <M-t>: swap two words
- <M-u>: uppercase current word
- <M-l>: lowercase current word
- <M-c>: capitalize current word
- 공부를 할 때 무엇을 참조했는지 기록해두는 것이 좋겠다
- [what is a buffer overflow](https://www.veracode.com/security/buffer-overflow)



#2021-09-06

- 종이처럼 직접 만지고 필기할 수 있는 모니터 -> 아이패드처럼 필기가 가능하도록
- 더 나아가, 펜으로 프로그래밍이나 다양한 조작을 가능하도록?
- 'echo $LINES': 터미널의 출력 줄 수를 담고 있는 변수의 값을 출력한다
- 'echo $COLUMNS': 위와 유사
- 'setupterm()': env 와 terminfo 사용하여 terminal type 변수 하나를 생성한다



#2021-09-04

- 인터넷의 정제된 페이지를 가져와서 vim 처럼 보고 싶다면, vim 에 인터넷 페이지를 정제하여 읽어오는 기능을 넣으면 되는 것이 아닐까?
  - 하지만 그러려면 vim script 등을 배워야겠지



#2021-09-02

- 'man 5 term' 을 보니 지금과 같이 16 진수 체계를 사용하기보다 8 진수를 사용한 기록이 눈에 띄었다. 아마 옛날에 8 진수와 16 진수 체계가 혼용되던 시절, 초기에는 단순히 아라비안 숫자 체계가 0 부터 9 까지 존재하기 때문에 표기가 가능한 8 진수 체계가 사용되었지 않았나 싶다. 지금 와서는 0 부터 f 까지 사용하는 16 진수 체계가 더 자연스럽고 통용되었지만 말이다



#2021-09-01

- vimsession 은 폴더 이름이 바뀌는 등, 외부의 수정이 가해졌을 때 이 변화를 인지하지 못하는 문제가 있다
- 왜 보기에 지저분한 html 을 사용해야만 하는가? 시각적으로도 더 읽기 쉽고 가벼운 언어를 사용할 수는 없는가?
- 'man 2 read' 를 보면 '#include <sys/uio.h>' 가 있는데, 이는 readv 의 인자인 iovec 를 정의하고 있기 때문에 추가하는 듯 하다, 만약 read() 만 사용한다면 sys/uio.h 를 include 할 필용는 없을 것이다
- 내가 프로그램 지능이 나보다 낮은 사람에게 알려줄 수 있는 것은 앞길과, 그 시기에는 원래 그렇게 힘들다는 것이다



#2021-08-31

- 가령, 모든 데스크 셋업을 커버할 수 있는 책상을 가지고 싶다고 하자
  - 그렇다면 왜 그런 책상을 원하는 것일까?
  - 그것은 지금 내 책상이 어떤 나의 이상적인 셋업을 커버하지 못하기 때문이다
  - 그렇다면 사실 '모든 데스크 셋업을 커버할 수 있는 책상' 은 문제를 해결하는 방법 중 하나이다
  - 따라서 어떤 사람이 원하는 것이 있다면, 그것은 해결 방안 중 하나일 것이기 때문에
  - 문제가 무엇인지를 확실히 하는 작업이 우선적으로 필요할 것이다
  - 하지만 대부분의 사람들은 문제가 무엇인줄 알며, 그에 대한 적절한 해결 방안을 제시한 것일 것이다

- https://osxdaily.com/2006/12/19/command-line-keyboard-shortcuts-for-mac-os-x/
  - <ctrl-a>: go to the beginning of the line
  - <ctrl-e>: go to the end of the line
  - <ctrl-u>: clear the line before the cursor
  - <ctrl-k>: clear the line after the cursor
  - <ctrl-w>: delete the word before the cursor



#2021-08-20

- 'traceroute <ip>': ip 로 가는 경로의 ip 들을 출력한다
- 'arp': local network 를 출력한다



#2021-08-15

- OOP 는 기본적으로 다양한 주소를 무리지어서 하나의 그룹을 구성하기 위해 탄생한 것이 아닐까?
  - 모든 작업에서 1차적으로 발전할 때 그룹을 형성하는 것이 중요하다고 생각한다. 파일 시스템처럼 directory 를 만드는 것이다. 이를 위해 어떤 기준으로 그룹을 지을까가 중요해졌고, 여기서 물체 중심으로 관련된 주소들을 그룹지어서 저장하는 OOP 가 발전한 것 같다



#2021-08-14

- xxd test.txt
  - '-s <address>'
    - xxd -s 0x10 test.txt
  - '-l <address>'
    - xxd -l 0x10 test.txt



#2021-08-05

- 게임의 요소: 시청각의 값과 변화량
  - 시각 축 값: 그래픽
  - 시각 축 변화량: 모션
  - 청각 축 값: 배경 음악
  - 청각 축 변화량: 이펙트 사운드

1) 만약 각 A 가 90 도 이하라면
    각 B 가 45 도 이므로 각 C 는 180 - 각 A - 각 B 이다
2) 만약 각 A 가 90 도 라면
    각 C = 90 - 각 B
3) 만약 각 A 가 90 도 이상이라면
    각 C = 180 - 각 A - 각 B 이고,
    각 A > 180 + 각 B 이면 ABC 는 삼각형이 아니다

이런 식으로, 하나의 서술에는 하나의 가정만을 두는 것이 가독성 측면에서 좋을 것 같다



#2021-07-19

```
...

print normal
if (fail)
{
	print additional fail message
}

...
```

- 함수 도중에 이런 식으로 하나의 흐름에 분기를 두는 것은 가독성을 낮춘다
- print 와 if 문을 분리하는 시각적 효과가 있으며, print 가 위의 흐름에 포함될지 아래 if 문의 흐름에 포함될지 중의적이어진다

```
...

if (success)
{
	print normal
}
else
{
	print normal
	print additional fail message
}

...
```

- 이렇게 print normal 이라는 statement 가 두 번 들어가지만, if 문 하나로 모듈화해 놓는 것이 위 아래 흐름이 존재하는 상황에서는 더 좋다

```
...

print_state()
{
	if (success)
	{
		print normal
	}
	else
	{
		print normal
		print additional fail message
	}
}

...

print_state()

...
```

- 이런식으로 구분된 모듈은 하나의 함수로 만들어주는 것이 가독성 측면에서 최고로 좋다

```
...

print_state()
{
	print normal
	if (fail)
		print addtional fail message
}

...

print_state()

...
```

- 이제 하나의 모듈로 묶여 중이적인 부분이 해소되었으므로 print normal 을 두 번 쓰지 않고, 실패 시에면 추가 실패 메세지를 출력하도록 해도 가독성이 떨어지지 않는다



#2021-07-17

- 요구사항에 대한 자세한 내용은, 직접 만들어보고 나서야 기준을 세울 수 있는 경우가 존재한다
  - 그런데 막상 만들어보고 나서, 기존의 요구사항을 까먹기도 한다
- 'git reset --hard <commit>': branch 를 옮기고 working directory 의 파일들도 commit 의 것으로 교체한다
- 'git reset --soft <commit>': 현재 branch 를 commit 으로 옮기지만 working directory 의 파일들은 변경하지 않는다
- 일일이 모듈화된 코드를 넣었다 뺐다 하는 것이 아니라 git 으로 해당 코드를 버전 관리 하면서 필요하면 적용된 코드를 넣고, 필요 없으면 해당 버전을 빼는 방식으로 진행하면 좋겠다(완벽히 유기적으로 연결될 수는 없겠지만)
	- 순서와 계층이 생길 수 밖에 없다
	- A > B > C 순서로 코드를 작성했다면 C 는 A 와 B 에 영향을 끼치게 되고 B 는 A 에 영향을 끼칠 수 있다. 이 상태에서 A 를 뺀다고 했을 때 B 와 C 는 A 에 의존적이기 때문에 세부적인 부분의 수정이 불가피할 것이다



#2021-07-16

- 이런식으로 한 줄이라도 오늘 생각한 것을 기록하는 것이 작은 성취감을 얻을 수 있는 귀한 행동인 것 같다
- 해야 할 일을 전부 적어놓고, 우선순위를 매기자. 더 급한 것을 먼저 하며 하고 싶더라도 당장 급하지 않은 경우는 반드시 뒤로 미루도록 하자



#2021-07-15

- const 는 해당 포인터가 가리키는 변수 내부의 포인터가 가리키는 변수의 값을 변경하는 것도 불가능한가?



#2021-07-09
- function prototype 의 argument name 에는 argument name 을, function define 의 parameter name 에는 parameter name 을 기입하도록 해보자
- general Debug commit 과 delicate Debug commit 을 구분해도 좋았을 것다
- commit 에는 무엇이 기록되어 있을까? 다시 한 번 확인을 해 볼 필요가 있다
- string 을 tokenize 할 때 단순히 특정 delimiter 로 쪼개어 word 단위로 저장하는 것이 아니라 앞뒤 문맥을 보고 해당 word 의 type 을 결정하는 것이 필요하다. 또한 word 단위가 아니라 의미있는 word 들의 묶음을 하나의 token 으로 묶어서 처리할 필요가 있다
	- structure 를 재귀적으로 사용했다면 어땠을까?
- process's filedescriptor table 에서 fd index 번재의 file data structure 를 읽고 사용 가능한 system call 함수가 해당 fd 의 file 에 사용 가능한지 판단한다



#2021-07-08

- 'launchctl limit': show limit data



#2021-07-07

- 요구사항을 분석하는 능력이 부족하다
- n 이 m 개 있는 것을 표현하는 방법
  - (mn | n * m)
- pseudo code 의 경우 시연용으로 작동 가능하도록 만들려면, 시연용 input 에 대한 output 을 출력하도록 만들어 놓는다(내부 구현은 없어도 된다)
- 역시 조금 불필요한 동작이 있더라도 빠르게 구현하는 것이 더 중요한 것 같다. 아무리 잘 만든다고 오랫동안 공들여도 당장 작동하지 않는다면, 차라리 2~3 배의 자원을 사용하더라도 일단 작동하는 것이 더 좋다



#2021-07-06

- 'ps -f <pid>': process 의 ppid 를 알 수 있다
- 요구 사항이 있으면 요구사항을 최저 사양으로 설정하고 전체적 추상화를 진행하는 것이 좋을 것 같다
- 상대가 원하는 정보가 따로 존재한다
  - 다량의 정보를 그냥 쏟아내는 것은 좋지 않다
- 피드백을 잘 해라
  - '너무 작아서 잘 안들렸어!'



#2021-07-05

- 팀원들간의 사적 일정으로 인해 격차가 발생할 수 있다. 이 경우 일정을 잘 조율하지 않으면 부담이 가해질 수 있다
- 말을 조금 더 조심스럽게 하자
- 너무 말을 억세게 한다
- 상대방도 말을 더 부드럽게 할 수 있도록 내가 유도해서 행동해보자



#2021-07-04

- 화를 내지 않도록 조심해라! 화를 내면 내가 생각해보지 못했던 상대의 새로운 의견을 들을 기회가 사라질 수 있다



#2021-07-03

- '~/.vimrc' 로부터 적용된 내용은 vimsession 에 저장되고, vimsession 을 open 할 때는 '~/.vimrc' 를 읽지 않는다
- dm 메세지와 다르게 facebook 처럼 나의 line 에 메세지를 남기는 방식이 확실히 전파력도 강하고 가볍게 글을 남길 수 있어서 장점이 있는 것 같다



#2021-07-02

- 잘 모르는 것에 대한 부분에서는 목소리를 높이지 말자. 잘 알지도 못하면서..



#2021-06-30

- 나는 왜 타인을 무시하고 들어가는가?
  - 가치관이 다른 사람을 인정할 수 있는가?
- 내가 의견이 너무 강하다
- 물어보자 왜 왜 왜인지 물어보자
- 상대의 말을 더 잘 들으려고 노력하자



#2021-06-29

- 팀원 각각의 특성을 잘 파악하는 것이 중요하다
- 대화는 한 명이 다른 한 명에게 생각을 전달하는 것이다. 혼자 말하는 것이 아니다. 전달하고자 하는 생각이 무엇인지 확실히 해둬라



#2021-06-28

- 시간이 넉넉하지 않을 때 대화를 하지 않는 것은 좋지 않다
  - 시간이 넉넉하지 않다는 것을 대화를 해서 알리도록 하여라!
- 규칙이 없다면 둘이 섞일 수 없다
  - 각자가 맡은 부분만을 담당해야 한다
- 규칙이 있다면 둘이 섞일 수 있다
  - 각자가 하고 싶은 부분을 건들일 수 있다
- detach 하면 thread 가 종료될 때 내부 할당이 free 될까?



#2021-06-27

- 끝내기 전에 나의 성장을 위한 감사를 표현하자
- "너무 무리하지는 말어"
  - 이렇게만 말하면 상대가 여러 의미로 해석이 가능하다
  - 명시적으로 의미 전달을 해야 한다
    - 우리의 목표는 단거리 달리기가 아니다! 라는 등!
- 상대 말에 대한 묵언
  -> 상대 말에 대한 부정적 의견 표출로 해석
- 말의 높낮이를 비정상적으로 꼼
  - 말이 진정성을 낮추고 장난칠 때 하는 행동
    - 상황에 따라 상대를 조롱하는 것이 될 수 있다
- 상대는 하고 싶은 것이 있는데, 내가 다른 것이 눈에 보인다고 그 것을 얘기하면, 상대의 입장에서는 자신의 문제를 해결하지 못한 채 추가적인 문제가 생기는 것이다!



#2021-06-26

- ls 에 파일 내용을 출력하는 기능이 있더라
- 설명을 할 때 평가를 받는 것처럼 중간 단계를 건너 뛰고 결과 및 큰 그림을 설명하는 문제
  - 상대에게 맞춰줘야한다!
  - 상대가 나의 설명을 이해하지 못하는 것은, 내가 상대가 얼마나 알고 있는지를 이해하지 못하고 있기 때문이다
- 단 usleep(1) 만 해도 31019 usec 만큼이 걸릴 수 있다 (다른 thread 가 열심히 돌아가고 있다면)
  - 모든 작동이 한 번에 오래 걸리지 않도록 적당히 suspend 를 해주도록 하자 (그래야 thread 가 골고루 돌아갈 것 같다)



#2021-06-25

- signal 에 대해 물어보셨을 때 'man signal' 을 보여드리면 더 좋았을 것 같다!!
- 상대가 자신은 뭘 쓴다고 하면 그에 대한 반응을 해주자!! 가볍게!!
  - 기술 1. 오,, 어때요?
    - 단순 의견 질문
  - 기술 2. 오,, 이거랑 비교해보면 어때요?
    - 비교 대상 존재 시 비교 질문
  - 기술 3. 오,, 노트북에서도 편했었는데, 편할 것 같아요
    - 경험을 토대로 의견 제시
- 문제에 대한 질문
  - 기술 1, 대답 연기
    - 생각 좀만 해봐도 될까요?
- 한 번 대화를 할 때 제대로 의미를 전달하도록 하자!
  - 한 번에 잘 전달하지 못했다면 여러 번 말을 번복해야하는 수고가 발생한다
- 다른 사람이 내 코드를 볼 때 어떤 식으로 볼지를 생각해보는 것도 좋겠다
  - 만약 보조 자료가 있다면 학습 속도가 비약적으로 빨라질 것이다 (전체적인 데이터의 흐름 등)
  - 만약 코드만으로 분석을 해야 한다면 'main()' 부터 시작하여 직접 코드의 흐름을 분석해야 할 것이다
    - 이 경우는 내가 직접 지원해 줄 필요는 없지만, 당사자는 함수의 이름을 보고 접두사, 접미사를 통해 대략적인 역할을 파악할 수도 있다

- 긍정적이냐 부정적이냐는 나의 관점에서 판단하는 것이 아니라 타인의 어제와 오늘을 비교하여 결정하는 것이다
  - 이것을 못하면 다양성의 긍정적인 면을 인정하기 힘들어질 것 같다



#2021-06-24

- 함수가 pointer 를 인자로 받을 때는 그 인자가 const type 인지 아닌지가 중요해진다!! 변경되서는 안되는 인자라면 const 를 명시해주는 것이 좋다
- 멘토 특강(오디오 신호 이해 및 딥러닝 음성인식 (Speech Recognition) (주) 보이스프린트 대표 김광호
{
	feedback 바라는 점까지
	소리 인식, 음성 인식, 자연어 인식 (언어 모델)
	오디오 신호 -> 시계열 데이터
	언어모델
	트랜스포머 버트 쥐피티
	강 인공지능: 사람 같은
	약 인공지능: 특정 영역에서 성능을 발휘함
	최적경로 알고리즘?
	옛날에는 SVM 이라는 것도 있었다고 한다
	ANN 이 발전되어 Deep Learning 이 되었다
	deep learning < machine learning < ai
	google tensorflow https:// 'a neural network playground'
	regression, classification: 숫자 조정, 분류
	hidden layer 의 neuron 은 선 하나 하나를 의미한다
	여러 neuron 으로 형태로 구분해낸다
	가중치와 bias 로 선이 그려진다
	voice, non_voice(music)
	화자 인식, 음성 인식, 음성 합성
	소리를 여러 파형으로 분할
	푸리에, 스펙트로그램 (소리를 분할)
	자연어 처리는 앞 뒤, 등 주변 단어를 고려한다
		주변 벡터와 비슷한 벡터로 인식한다
	transformer papef
	sound -> encode (number) -> decode (human word)
	local optimal
	학회
}
- 이런.. 오늘은 terminal 이 평가 프로그램 실행 중 튕기는 현상으로 인해 디펜스를 원활히 하지 못했다.. 확인해보니 하드디스크의 용량이 다 차서 그랬던 것 같다.. 다음부터는 이런 상황에 하드디스크 용량을 잘 확인해보도록 하자..
- 나는 exit_code 도 잘 관리를 해뒀으니 문제가 발생하면 exit_code 를 확인해봤어도 굉장히 훌륭한 방법이었을 것 같다!!
- 디펜스 등록 이후에 문제를 발견했다면 빠른 취소보다는 디펜스를 한 번 해보는 게 도움이 될 것 같다



#2021-06-23

- 감정을 잘 모르는 것이 아니라 이해하는데 시간이 좀 걸리는 것 아닐까?
- 나는 처음에는 다 괜찮은 것처럼 말해놓고 나중에 가서는 딴 소리를 하는 것 같다?
  - 나는 내 생각보다 그렇게 다른 사람의 의견을 다 수용할 수 있는 사람이 아닌 것 같다
- SIGUSR1 의 handler 를 호출하고 SIGUSR2 로 interrupt 를 하고 다시 SIGUSR1 signal 을 줬더니 반응이 없었다
  - handler 내부에서 empty mask 를 가진 sigaction 으로 새로운 sigaction 을 설정해주었지만 그럼에도 SIGUSR1 signal 에 interrupt 되지 않았다



#2021-06-22

- minilibx
  - https://github.com/qst0/ft_libgfx#minilibx
  - https://harm-smits.github.io/42docs/libs/minilibx
- semaphore 는 thread 에서도 사용할 수 있었던 것으로 기억하는데, process 간에서도 사용할 수 있는 건가? 애초에 process 간에도 같은 메모리 공간의 변수를 사용할 수 있나? 그럼 반대로 mutex 는 process 간에 사용될 수 있나?
- 주석을 곳곳에 넣어서 언제나 완성된 코드를 유지하도록 하자! (pseudo 코드지만)



#2021-06-21

- 생각을 못했던 부분을 지적당한다면 순간 당황을 할 수 밖에 없다. 나는 생각을 해본 부분이지만, 상대는 생각을 못 한 부분이기 때문이다. 이 경우 상대방에게 생각 할 시간을 넉넉하게 주는 것이 좋을 것 같다



#2021-06-20

- 통신 장애
  - 1. 잘못된 값이 전달: checksum 으로 확인
  - 2. NAC 를 사용하는 경우 오작동으로, 정상적인 상황에서 데이터 수신 중에 NAC 전송
    - NAC 는 전송 실패 확률이 낮은 경우 사용하는 acknowledge flag 인 것 같다. 매번 ACK 를 사용하지 않아도 되어 속도를 조금이나마 높일 수 있을 것 같다. 나의 경우 signal 이 사라지는 경우도 존재하는 등 전송 실패 확률이 높기 때문에 NAC 를 사용하지 않는 것이 좋겠다
- 내가 도와준다고 하는 것이, 상대는 항상 좋게 생각하는 것은 아니다
  - 도와주고 싶다면, 상대가 도움이 필요한지를 먼저 물어보는 것이 예의이다
- leaks 가 정상적인 상황이 아닌 것 같다. leaks 는 대상 프로그램의 실행을 잠시 block 해두고 검사를 진행하는 것은 아닐까?
  - 말일 그렇다면 signal 로 인해 발생한 SIGUSR1 handler 가 leaks 로 인해 block 상태에 놓이고, 이 상태에서 client 로부터 SIGUSR1 이나 SIGUSR2 가 입력되었을 때 이 signal 을 무시하게 되면서 신호가 씹힐 수 있다
- 일반적으로 interrupt 가 되어 실행되는 함수는 끊기지 않고 실행되거나, 그 함수가 반환되어야 원래 하던 일이 실행되기 때문에 가능하면 가볍게 구성하라고 한다. unix signal 의 경우는 우선 실행될까? 아니면 system 에 의해 여타 thread 와 마찬가지로 처리될까?
- signal handler 가 실행중인데 block set 에 지정한 signal 이 들어올 경우 이를 1 회에 한하여 들어왔음을 체크해두었다가, 낮은 순서대로 handler 를 호출한다
- signal handler 내부의 system call 은 signal 로 fail 하지 않는다
- mask 로 block 되지 않은 signal 이 들어오면 signal handler 를 실행중이더라도 system call 이 fail 한다
- BIT_WAIT_INTERVAL 은 bit 가 손실된 것을 막아야 한다. 이것이 bit 의 늦은 전송을 막는다면 정상적인 상황도 error 로 간주되며 속도가 저하될 것이다. 따라서 일반적으로는 정상적으로 손실 없이 전송될 것이기 때문에 (손실률이 낮기 때문에) 이 수치는 높게 설정하여 실수로 bit 가 늦게 들어 오는 경우에 발동되지 않도록 해야 한다 (비트 손실 발생 패킷 빈도가 1% 라면 bit 전송 간격 / 1% 정도?)
- sample 을 통해 bit 손실률과 packet 전송 실패율을 계산하여 각 interval 에 적용하는 것도 좋겠지만, 이 프로젝트에서 요구하는 사항은 아니니, 이정도로 하고 마치자
- 나는 말을 하는 사람이 말을 구체적으로 해야 한다고 생각했고, 상대는 말을 듣는 사람이 부족한 부분을 질문을 해야 한다고 생각했다
  - 둘 다 맞는 건데, 나는 질문을 하지 않았고, 상대는 말을 정교하게 하지 못했다



#2021-06-19
- 상대가 무시 당한다는 느낌을 받지 않게 하기 위해서는 내가 계속 말을 해야 한다
  - 1. 목적 잊지 않기
  - 2. 상대가 물었으면 그에 대한 답을 하자 (상대가 그 말을 한 표면적인 의미부터 제대로 이해하자)
  - 3. 실수는 빠르게 정정하자 (이것도 가능하면 말로 정보를 많이 주는 것에 속한다)
  - 4. 머릿 속으로 생각만 하지 말고 말로 전달을 해야한다 (무슨 생각을 하고 있는지 상대방에게 공유해야한다)
  - 5. 그럼에도 불구하고 불필요한 말은 하지 않는다
  - 6. 말은 항상 쉽게 해야한다 (괜히 꼬거나, 나쁜 것 처럼 말하고 좋은 말을 하거나, 반대로 좋은 것 처럼 말하고 나쁜 말을 하거나 하지 말자, 이해할 수 없으면 재밌지도 않다, 상대는 불안하기만 할 것이다)
- 나와 비슷하게 생각하는 사람은 대화가 잘 통할 것이다. 반대로 사고의 흐름이 다른 사람과는 말이 잘 통하지 않을 것이다
  - 대화가 잘 통한다는 것은 바로 전에 나눈 대화 다음 대화서 서로 어느 정도 예측 가능한 방향으로 진행되는 것이다
  - 또한 서로 전달하는 말에 들어 있는 정보의 양이 서로 불편하지 않고 납득할만한 양일 것이다
- 다른 프로그램이 같이 동작하면 기본으로 설정한 BIT_SEND_INTERVAL 을 넘어가는 interval 이 발생할 수 있다
- SIGUSR 의 특징인 것일까?
- infinity_leaks 를 실행하니 signal 을 그냥 출력만 해도 씹히는 현상이 있다
  - 00100000000000000000000000000000100000000000000000000000000000001010101001101100100000000000000001100101100100110111111111111111 (앞에 한 번 001 만 출력되고 다음 전송은 제대로 출력됨)
- 실패할 때 NAC 를 전송하여 재전송을 요청하는데, 그냥 가만히 있고, client 가 ACK 를 받지 못할 때 데이터를 재전송하도록 하면 어떨까?



#2021-06-18

- 'echo "obase=2; $var" | bc': 숫자를 2 진수로 출력하기
- 'echo "$((2#<binary number>))"': Binary 를 decimal 로 출력하기
- 'echo "obase=10; ibase=2; 10" | bc': obase 가 ibase 보다 먼저 나와야 한다
- bfs 와 lss 의 구조와 방식을 설명하는데 조금 더디다는 것을 깨닳았다
- 스스로 생각하고 대답하도록 물어보고 난 후의 대답에는 상대가 더 그것을 자신의 생각이라고 여기고 인정하게 된다
- 주어진 질문을 주체적으로 해석하여 답을 내는 것은 중요한 기술이다. 하지만 사람과 대화할 때 이 기술만 사용할 필요는 없다



#2021-06-17

- 1. 사용 사례, 어떻게 사용할지를 조사하여 데이터 확보하기
  - 주의: 사용 가능한 모든 케이스가 아니라, 소요 시간이 가장 짧은 최고의 사례를 모아라
- 2. 구현 및 테스트
- client 가 pid 를 전달할 때 checksum 오류가 발생하면 서버의 NAK 신호도 오지 않고 client 가 pause 에 빠져버리는 문제
  - receive signal 도 출력해보면서 pause() 가 왜 안 풀리는지, 어떻게 둘 다 puase() 가 될 수 있는지 알아보기
    - client 가 pid 를 전송한 후 pause 에 빠져서 server 가 client 에게 packet 을 보내지 못했다
- sigaction 의 3 번째 인자: 기존 처리 방법을 저장할 struct sigaction 의 주소



#2021-06-16

기존에 정의해 놓은 structure 의 구조를 변경할 경우 할 작업이 많아진다. 이를 자동화해도 재밌을 것 같긴 한데, 지금 상태에서 다른 사람들은 이를 어떻게 해결하고 있을까?



#2021-06-15

- 종종 대화 중에 서로 다르게 이해하는 '같은' 단어를 사용하여 혼동이 생기곤 한다
  - 전문 지식을 전달하는 글도 어떤 단어에 보다 많은 의미를 부여하여 사용하기도 한다
    - 가령 'block' 이라는 단어를 사용할 때, 단어 그대로 의미의 '막다' 라는 의미 이외에도 'block' 이라는 것을 통한 추가적은 내부 구현을 내포하기도 한다 (어떤 변수가 어떤 값을 갖는다던가)
- pdf 를 작성할 때 제일 앞에 index 페이지를 만들고, 각 페이지마다 쪽 수를 표기하자
- 'kill -SIGUSR1 <pid>' 와 같이 검증된 read/write 도구 하나만 주어져도 새로운 개념에 적응하기가 훨씬 쉬워진다!!
- apple 에서는 unsafe 한 경우 함수 정의에 포함되는 것 같던데 그런 방식도 좋은 것 같다
- 'usleep(13)' 정도까지 전송 에러가 발생했다 (아마 signal handler 함수의 처리 시간과 관련이 있을 것 같다
- 개념 접근 단계
  - 1. 모든 값을 확인해보기 (어떤 변수에 어떤 값이 들어있고, 상수는 실제 어떤 숫자 값인지)
  - 2. 값 변화에 따른 결과 관찰하기
  - 3. 입맛대로 코딩하기
- structure 는 생각보다 순서에 의해 내부 구조가와 크기가 달라질 수 있다



#2021-06-14

- level design: 처음에는 버튼을 누르는 수준으로 매우 쉽게 만들더라도 그 버튼에 쓰여있는 글씨 등에는 사실 다 의미가 있다. 이것을 이해하는데에는 하나의 level 을 거치는 것이 필요하다
  - 즉, 하나의 level 에는 단순히 그 목표를 달성하는 것 이외에도, 주변 환경과 정보들의 의미를 이해하는 숨은 목표도 있다
    - 이런 식의 널리 퍼지지 않은 개념을 계속 이해하고 적용하는 것이 중요하다. 이것이 미묘한 차이를 만들고, 이것이 품질의 차이가 된다
	  - 더 나아가 이런 개념을 도입하려는 팀원들을 잘 격력하는 것도 중요하다
  - 시간을 느끼게 해주어야 한다
    - 개념을 설명할 때 그 개념이 실제 사용되는 것을 간접 체험시켜주는 것도 중요한데, 이 때 그 개념에 소요되는 시간이 어느정도일지 전달하는 것이 중요하다
	  - 하루에 한 번 발생하는 개념을 자주 사용하는 것으로 이해할 수도 있다
	    - 이런 괴리가 발생했을 때 어리둥절함 및 무언가 잘못된 느낌을 겪을 수 있다
		  - 만약 개념을 기초부터 이해했다면 스스로 소요 시간을 계산해볼 수는 있다. 이 경우 외부로부터 소요 시간을 입력받지 않아도 괴리감이 발생하지 않으며, 따라서 부작용도 없다
- git 은 변경 내용을 다양한 방법으로 수정할 수 있다
  - 이를 응용해서 적절한 delimeter 로 git commit 을 구분짓고, 필요한 commit 을 골라 적용할 수도 있다!!!!
    - 가령 debug 를 위한 코드를 commit 하고, bugFix 를 commit 하면, debug 를 위한 코드 변경사항을 제하고 bugFix 를 위한 변경 사항만 적용시킬 수 있다
- remote tracking branch 로 branch 를 만들면 해당 branch 의 remote 가 remote tracking branch 가 track 하는 remote branch 로 설정된다
- 'git branch -u <remote tracking branch> <branch>': branch 의 remote branch 를 remote branch 로 설정한다
- c 에서 함수 포인터 타입을 정의할 때, 내부에 인자가 있으면 내부 인자가 진짜 인자고, 외부에만 인자가 있으면 외부 인자가 인자다
  - 'void (*(int))(int)': 'void (*)(int)' 를 반환하고 'int' 를 인자로 하는 함수
  - 'void (*)(int)': 'void' 를 반환하고 'int' 를 인자로 하는 함수
- 프로토콜이 필요한 이유는 두 기기가 정보를 주고받을 때 사용하는 시간과 계산하는 시간 간격이 하드웨어에 따라 서로 다를 수 있기 때문에, 이런 문제를 극복하고 원활한 소통을 하기 위해 서로 약속된 프로토콜을 따른다
  - 서로 안정적으로 통신이 가능하도록 구성된 '프로토콜' 을 따르면 안정적인 통신이 가능하다



#2021-06-13

- ':args `find -L . -iname \*.\[hc\]`' in vim
- 저번에 멤버변수의 type 으로 다른 structure 를 사용할 경우 그 structure 의 header file 을 include 해야 했던 것으로 기억하는데, 이를 한 번 더 검증했으면 좋겠다
  - 만약 그래야 한다면 하던데로 header file 에서 다른  structure 를 include 할 때 type.h 파일을 따로 만들어서 타입에 대한 정보를 먼저 주고 실제 header file 을 include 해야 할 것이고, 아니라면 그냥 type.h 파일만 include 해줘도 괜찮을 것이다
- core data 를 다루는 structure 는 의존성을 끊고 잘 캡슐화하자
  - 그래야 여기서도 쓰고 저기서도 쓸 수 있다!



#2021-06-12

- ':vimgrep /<word>/g <paths>' in vim
  - ex> ':vimgrep /ft_atoi_push_swap/g **/*.[hc]'
  - ex> ':vimgrep /ft_atoi_push_swap/g %': '%' means filepath of active buffer
  - ex> ':vimgrep /ft_atoi_push_swap/g ##': '##' expanded to represent each of the files from the arglist
- ':cnext', ':cprevious' in vim
- ':cfirst', ':clast' in vim
- ':copen', '<cr>', ':cclose' in vim
- By default, the driver converts a Control-D character at the start of a line into an end-of-file indicator
- In windows, actual EOF character exists
- test 'cat' to figure out the behave of <c-d>
- '<c-v><c-@>' in vim: write NULL character
- 다음 프로젝트를 진행할 때는 요구사항을 우선 빠삭하게 분석하고 시작해볼까?
- 오늘은 또 이상한 메모리 관련 문제가 있었다. 원래 존재하던 메모리의 주소가 계속 지워지는가 값이 0 으로 초기화가 되는 것이다. 그래서 lldb 로 위치를 찾아내고 (그런데 이 과정에서 lldb 는 처음에는 segmentatino fault 가 뜨다가 몇 번 브레이크 걸고 시도하다보면 다음 run 부터는 계속 성공하는 이상한 일도 있었다, 다시 껐다 키면 또 segmentation fault!?), lldb 로는 이해할 수 없는 일이 일어나서 printf 로 값을 출력해보니 확실히 특정 함수 호출을 기점으로 이상한 값이 적용되고 있었다 (특히 더 이상한 것은 그 함수는 문제의 구조체를 받지조차 않는다는 것이다). 문제의 원인은 할당하지 않은 변수를 free 해서 벌어진 일이었다. 그 변수에는 임의의 (어쩌다가 무조건적으로 특정 구조체의) 값이 들어있었고, 그 주소를 free 하자 필요한 구조체가 초기화된 것 같다. 그래서 해당 변수를 특정 구조체 안에 넣어서 구조체가 할당, 해제 될 때 직접 관리하도록 하여 불안전한 값이 들어가는 것을 방지하였다
- settings set target.input-path <path>



#2021-06-11

- alias 는 read-only 인 constant 고, variable 은 read-write 인 variable 이다
- local repository 는 'git branch -m <old_branch> <new_branch>' 로 이름을 쉽게 변경할 수 있지만, remote branch 에서는 이가 허용되지 않는다
- 'du -sh <path>': Print disk usage of 'path' directory or file with human-readable
  - 기본적으로 파일을 위한 디스크 공간은 (클러스터 맥에서는)  4.0K 를 한 단위로 제공된다
    - 1 byte 만 사용해도 4.0K 를 할당 받는 것
  - 'du -c': Display a grand total
- 'sort -n': Sort fields numerically
- 'seq 1 10 | sort -nr': Display 10 ~ 1
- 'sort -t <character>": Use character as seperator
- 'bluprint' branch 를 작성할 때는 제대로 된 기능을 수행하는 것이 아니라 default 로 정의된 constant 값을 직접 적용하는 정도로 구현해둔다
  - 그리고 실제 구현해야할 목록에 넣어둬서, 현재 작업이 필요한 목록을 항상 최신으로 유지한다
- 'main' branch 의 '/.project/' 에는 merge 해야할 사항을 기록해둔다
- '!=' 이나 '==' 은 처음 이후 else 보다 판단문 자체로 인한 분기를 강조한다
- 함수의 이름은 그 함수가 어디에 초점을 맞췄는가로 정한다.
  - 함수의 기능이 중요한 것인지, 함수가 반환하는 값이 중요한 것인지
  - 또, 가독성을 높이기 위해 함수의 이름은 거시적 관점으로 결정하는 것이 좋다
- 모든 null 입력에 대한 guard 를 하는 것보다, 필요에 따라서는 error 를 발생하도록 하는 것이 문제 지점을 탐색하는 데 유리할 수도 있으르 것 같다
- ':args `find . -iname \*.\[hc\]`' in vim



#2021-06-10

- shell parameter expansion
  - 'repositories=(${repositories/#/$git\/})'
- 'set -- $vimsession; vimsession=$1': Get first word from string
- '`.' in vim: Takes cursor to the position where you made the last change
- '+' 와 '-' 로 증감이 가능한 변수 'var' 가 있다, 이는 생물인가?
- ':cd %:h' in vim: See ':help expand'
- 'seq' in cli



#2021-06-09

- 어떤 프로그램 실행 전에 항상 어떤 코드를 실행시키도록 하는 방법
  - 1. precmd_function 목록에 추가하여, 모든 command 에 대해 선행 작업을 하도록 한다
    - 'precmd_function+=( precmd_vcs_info )'
  - 2. alias 로 shadowing 하여 reculsive 를 막으면서 특정 작업을 선행하도록 작성한다
    - ex> 'alias ls="ls -Alp"'
  - 3. 목표 프로그램이 실행될 때 선행적으로 하는 작업이 있다면 원하는 코드를 수행하도록 작성한다
    - ex> '.zshrc', '.vimrc'
- 'git config --edit --global': Open global git config file
- 'git config --get --global core.excludesFile': Show the value of variable
- set, type, typeset, alias, env, declare
- function 을 propagate 하여 사용해보려고 했으나 FPATH 가 기본적으로 subshell 에 전달되지 않고 이를 '.zshrc' 없이 구현하는 방법을 찾아보았으나 정보가 없어서 포기하기로 한다
- function 을 일절 사용하지 않고, subshell 에도 특정 기능을 할 수 있도록 하기 위해서는 '.sh' 파일을 작성하기로 했다.
- shell script 에는 c 에서 exit 과 같이, 실행 중이 프로그램 자체를 나가는 역할을 구현하기가 어렵다. 그래서 언제나 프로그램을 종료할 수 있는 c 와 다르게 깊이를 주지 않고 source 를 이용하여 서로가 서로를 호출하도록 작성한 뒤, exit 으로 현재 shell 을 종료하는 방향으로 진행해보자 (return 은 실행중인 sh script 를 닫는다)
- shell script 의 if 문은 마치 하나의 script 처럼 판별식의 인자를 $1 에 넣는다
- aux 에서, 필요한 파일을 alias 하고는 싶으나 zsh 을 호출해서 사용하고 싶다 (exit 하고 싶어서)
  - '.zshrc' 와 'aux' 에서 공통적으로 사용할만한 것들을 따로 빼서 두 파일이 모두 호출 가능하도록 구성해보자
    - 그런대 'aux' alias 는 둘이 서로 다르긴 하다..
- 'a=(${(s/:/)string})'



#2021-06-08

- 'c rename t_sort t_sort_type'
- 'basename 'git rev-parse --show-toplevel''
- ':h <option>' in vim: Search help page for vim
- 'env': List exported environment variable
- 'set': List local environment variable
- '>' 나 '<' 는 파일을 input 으로 읽는다
- '|' 는 앞 command 의 stdout 을 뒤 command 의 stdin 으로 준다
- 'xargs <utility>' 는 stdin 을 utility 의 인자로 하여 실행한다
- 파일로부터 직접 읽고 쓸 때는 꺽쇠를, 다른 처리를 한 결과를 입력으로 할 때는 파이프를 사용한다
- alias 정의 안에 $() 로 다른 프로그램을 실행하면 실행 시 처음 한 번만 프로그램을 호출하여 값을 저장한다
- alias 로 특정 파일을 호출할 때, 정확한 위치를 적어주는 것이 아니라 대상을 search 할 directory 를 적어주면 편할 것 같다
- zsh 뒤에 인자가 여러개이면 가장 처음 인자만 실행된다
- 'vimsession' 이 현재는 새로운 zsh 을 만들고 그 안에서 session 을 여는 것 같은데 굳이 그럴 필요가 없을 것 같다
- dirname basename absoulte relative path realpath
  - 'dirname <path>': Return directory name of path.
  - 'basename <path>': Return base name of path. (<path> = <dirname>/<basename>)
- shell script
  - '$0' first word of command string
- 'find' command 의 option 중 '-name' 은 case sensitive 하고 '-iname' 은 case insensitive 하다
- basename 의 버그: 인자가 2 개 일 때 첫 번째 인자만 처리한다
- 'for word in hello world; do echo $word; done'
- '<C-k>' in cli: Delete to the end of the line
- '<C-w>' in cli: Delete backward to the beginning of the word
- '<C-t>' in cli: Transpose two characters
- '<S-Command-double_click>' in terminal: Select path or URL
- '<Command-e>' in terminal: Find selected word
- '<Command-double_click>' in terminal: Open URL
- 'drag-and-drop file from finder' in terminal: Add the complete path to a file
- '<O-click>' in cli: Reposition the insertion point
- 셸 스크립트를 실행할 때는 새로운 셸에서 실행하는 것을 원칙으로 하자(모듈화)
  - 단, alias 설정등 셸 윈도우를 처음 띄울 때 필요한 설정은 source 로 실행한다
  - 간단한 함수 수준도 모듈화해서 사용하는 것이 좋겠다. 정말 빈번히 사용하는 것만 
- set, typeset, alias, env
- function 은 실행중인 shell 상에서 호출되면, 블럭 안에서 바꾼 변수의 값이 밖에서도 유지된다
- all 을 .PHONY 에 적어두지 않았을 때 all 이라는 이름을 가진 파일이 존재하는 지는 의존성이 없고, 의존성에 명시된 파일이 존재하는지 확인하여 없으면 rule 을 실행한다
- rule 의 dependency 와 상관 없이, .PHONY 에 명시했는지 상관 없이, 파일이 없는데 실행하고 나서 파일이 생성되지 않고, 실행 가능한 recipe 이 존재하면 rule 이 실행된다
- 통찰력있는 분석을 제시했는가, 그러지 못했는가, 이는 한끝 차이지만 중요한 차이이다



#2021-06-07

- [stackoverflow/How can I delete a newline if it is the last character in a file?]
- how to implement hash function?
- 'git ls-remote <remote>': 로 romote repository 를 list 할 수 있다
- 'bash' 에서는 'POSIX sh' 과 달리 '[[' 를 사용할 수 있는데, 이를 사용하면 내부에서 변수를 사용할 때 double quote 를 사용하지 않아야 한다
- '$?' 는 이전 판단문의 결과를 출력한다
- 'git tag -d <tag>'
- 'git push -d <remote> <tag>'
- 'git ls-remote --tags'
- 'git show <branch>:<file>'
- 'git checkout <branch> -- <file>': also do stage
- ssh 관리는 env 가 해주나?
  - 지금은 따로 관리 안해주고 직접 ssh 구축 후 git clone 하게 되어 있는데 이후에는 봐서 없으면 해달라고 요청 메세지 보내고 다시 시도해주세요 > 이런 식으로
  - 그리고 환경 구축하는 script 를 모듈화할 수 있는지 생각 해보자
- [nvie/A successful Git branching model](https://nvie.com/posts/a-successful-git-branching-model/)
  - 여기에서 말하는 git model 은 dev 에 feature 들을 merge 할 것을 목표로 한다
  - 만약 나의 seoul42_project repository 처럼 각 프로젝트(== feture branch) 를 굳이 하나의 main branch 로 통합할 필요가 없다면 발산형으로, 브랜치 끝을 tag 로 장식해두면 좋을 것 같다
    - 작성한 feature branch 들을 통합해서 하나의 실행파일을 생성하는 것을 목적으로 하는 경우 main branch 로 merge 하는 것이 맞을 것이다
- 작업 수행 흐름
  - 1. 예측한다
  - 2. 시도한다
  - 에측하지 못한 일이 발생했을 때 행동 방침
    - 모든 사람이 해당 사안에 대한 의견을 제시한다
    - 최종적으로 실현 가능한 유용한 방안을 추려낸다 (갯수는 상관 없다, 납득 가능하면 상관 없다)
    - 기록으로 남겨두고 한가지를 선택해서 시행 (다수결을 하든 랜덤을 하든, 어차피 다 경험이 된다)
    - 이후 좋았는지 나빴는지 회고 (및 기록을 통해 경험 축적)
- 도시를 건설한다고 생각해보자
  - 우선 조악하더라도 기능적으로 '도시' 라고 부를 수 있을 만한 것, 혹은 도시를 '흉내'내는 것을 만든다
  - A 건물과 B 건물을 각각 짓고 있는데
  - B 건물이 A 건물의 상하수도관을 연장해서 사용하려고 할 때
  - A 건물이 상하수도관을 수정하려고 하면 B 건물에도 영향이 간다
  - 그럼 이를 미연에 방지하기 위해 전체 상하수도관 관리를 분리해두고
  - A 건물과 B 건물은 상하수도관 infra 위에서 생성한다고 할 때
  - 만약 B 건물이 상하수도관을 바꾸고 싶다면 상하수도관을 바꾼 후 이를 rebase 해서 사용하고
  - 상하수도관을 사용하는 모든 대상은 바뀐 상하수도관을 rebase 해서 사용하면 될 것이다
    - 근대 그러면 B 건물 담당자가 바꾼 상하수도관 변경 사항이 A 건물에 영향을 주면 어떻게 하지?
    - 거기다가 상하수도관 뿐만 아니라 건물을 위한 전기, 도로, 등 많은 infra 들은 어떻게 의존성을 두지?
  - 즉 모든 infra 위에 건물을 짓는 것이 아니라
  - infra 와 건물이 같은 계층급의 feature branch 에 속하게 되는 것이다
  - sudo function 만 작성해두고 이 sudo function 을 implement 하는 feature branch 를 만드는 것이다
  - release branch 는 외부 공개를 위한 
  - dev 는 모든 feature branch 의 base 이다
  - feature branch 들의 기능을 사용하는 app logic 을 작성하는 코드 또한 따로 feture branch 를 만들어서 작성 후 merge 해야 할 것이다
    - 이 때 이 branch 는 우선 sudo function 을 사용한다
  - 만약 새로운 feature branch 의 요구가 필요하고, 이를 기반으로 하는 sudo code 가 dev 에 추가되어야 할 경우에는 dev 자체를 update 한다
  - 그러면 다른 feature branch 들은 새로운 sudo code 를 사용할 수 있게 되고, 동시에 sudo code 를 위한 feature branch 를 만들 수 있게 된다
  - feature branch 가 완성되면 dev 는 그 branch 를 merge 하고 임무를 마친 feature branch 는 delete 한다
  - release tag 는 외부 공개용으로 완성된 commit 에 tag 한다
  - hot fix 가 있을 경우 hot fix 를 적용하고 hot fix version 으로 tag 한다
  - prerelease branch 는 차세대 공개할 release version 을 완성시키기 위해 버그를 수정하고 작동을 테스트해서 마무리하는 branch 이다
  - prerelease branch 의 목표를 달성하면 release tag 를 붙이고 hot fix 와 유사하게 dev 와 merge 한 후 계속 dev branch 를 rebase 추적한다
  - dev branch 는 차세대 release version 을 위한 feature 들을 수합하고 대기한다
    - 차세대 prerelease branch 도 항상 존재한다
  - 만약 건물 A 와 건물 B 를 위한 feature branch 를 만들어서 사용하다가 상하수관을 분리해야하는 일이 발생한다면
    - 1. dev 에 sudo code update
	- 2. sudo code 를 implement 하는 feature branch 생성 및 기존의 open branch 들을 최신 dev branch 로 rebase
- git 을 연습하는 용도의 도시 건설 project 가 있으면 재밌겠다
- apple 의 통합 기능은 연결이 가능한 환경에서는 훌륭한 사용 경험을 선사하지만 조금이라도 문제가 생기면 고질적은 치유 불가능한 문제가 되어 버린다
  - ex> 클러스터 컴퓨터의 apple id 적용 시 나타나는 버그
    - 이런 경우 직접 관리 가능한 방법이 있으면 유용하다
- 시간을 신경쓰지 않고 집중하기 위해 시야에 들어오던 시계를 제거했더니 효과가 좋았다. 무심결에 시계를 보았는데 없어서 시간을 알 수가 없어서 좋았다
- 꼼꼼해지는 과정은 마감을 여러 번 거치면서 학습하는 것이다. 매 번 꼼꼼하기 위해 노력하는 것은 그다지 효율적이지 않을 수 있다
  - 기준 자체는 높게 제시하되, 제출물을 제출할 때에는 제한이 없게 해서, 여러 번 시도하도록 유도하자
- 내가 평가를 한 시간 씩 진행하면 한 숨을 내쉬기 시작하는 분이 한 분 있는데, 어떻게 하는 것이 옳바른 해결책일까?
- 에어컨을 켜 놓은 후 창문이 열려있는 상황에 대한 해결책
  - 누군가 에어컨을 켰다, 누군가 창문을 열었다
  - 어어컨을 끄는 사람은 없다, 창문을 닫는 사람도 없다
- hard link 는 같은 inode 를 사용하는 파일을 생성하는 것이다
  - 그런데 이것은 file system 의 구체적인 특징이기 때문에 OS 공통의 file system 을 추상화한 git 의 경우 hard link 를 file 로서 기록하고, symbolic link 는 구체적인 inode 연결 이외의 공통적인 file system 특징이므로 일반 파일과 구분하여 기록한다



#2021-06-06

- 삭제된 'remote branch' 를 track 하는 'remote-tracking branch' 가 local 에 남아 있을 때 없애는 방법: 'git branch -dr origin/<branch>'
  - '-r' option 은 'https://git-scm.com/docs/git-branch' 에서 확인할 수 있으며 'remote-tracking branch' 를 의미한다
- 확실히 void * 를 사용해서 generic 한 값을 담을 수 있도록 구성하는 것이 코드 재사용에 굉장히 큰 역할을 하는 것 같다. C++ 이나 swift 처럼 generic type 을 위한 코드를 생성해주는 기능이 없다면(추측) 컴파일 단계에서 처리 불가능한 부분을 가능한 run time 에서 적용이라도 하기 위해 'void *' type 으로 content 를 정의하여 generic 한 structure 를 구성해보도록 하자
- 에어컨을 틀고 싶다면 창문을 다 닫았으면 좋겠다! (환경을 소중히!)
- 비교문을 작성할 때는 대소 관계에 따라 작은 것이 왼쪽, 큰 것이 오른쪽에 작성하는 것이 '아니라' 주어 역할을 하는 것이 왼쪽, 비교 값이 오른쪽에 두도록 하자 -> 문장처럼
- big o 계산 -> 수열의 합, 시그마 계산, 수열을 함수로 만들고 적분
- 다음에는 에러 전용 구조를 만들도록 하자



#2021-06-05

- 프로그램 함수 작성 시 함수의 종류는 크게 2 가지로 나눌 수 있다
  - 첫 번째는 기능을 구현하는 함수이다
    - 추상적인 동작이 중요한 것이 아니라, 하나의 구체적인 기능을 구현하기 위해 작성하는 함수이다
	- 이런 함수는 자신이 수행하는 기능을 중심적으로 서술해야 가독성이 좋다
  - 두 번째는 추상적인 동작을 구현하는 함수이다
    - 구체적인 동작이 작성되어 있지는 않지만 다른 함수들을 호출하면서 추상적인 동작을 수행한다
	- 이런 함수는 전체적인 흐름을 중심으로 서술하면 가독성이 좋다
- 빡센 최적화를 할 때는 내가 함수의 입력값과 출력값을 제한하면서 특별한 case 의 guard 를 넣지 않을 수도 있지만, 프로그램의 크기가 조금씩 커지고, 모든 것을 control 할 수 없는 경우, 다 기억하지 말고 적절히 guard 를 하도록 하자
- 최적화 전용 기능은 주 작업과 상관이 없는 내용이므로 분리하여 껐다 켰다 할 수 있도록 구성하면 좋은 것 같다
- 프로그램을 확장하는 방법 1. 원래는 상수, 변수를 사용하던 부분을 변수, 함수를 사용하도록 바꾼다
- '=' 는 강조하는 기능이 있다
  - 만약 '=' 를 사용하면 해당 부분이 강조되는 것이고, 사용하지 않으면 이후 부분이 강조된다
- create, edit, delete
- 실제 파일을 삭제하는 'git clean' command 가 실행되기 위해서는 '-f' 옵션을 줘야 하도록 만든 것이 마음에 든다. 마치 '정말 실행하시겠습니까?' 라고 묻는 것 같이 보인다
- 저 지랄맞은 현충일 캘린더 알림은 왜 계속 뜨는거지?



#2021-06-04

- 전에 한 번 빼먹고 특별한 값에 대한 basis_vector 적용을 그냥 넘긴적이 있는데, 이로 인해 오늘 원기둥을 출력할 때 0,1,0 을 normal 로 하는 원기둥의 위, 아래 면을 그릴 때 제대로 출력되지 않는 문제가 있었다. 새로운 기능을 구현할 때는 그 기능을 구현하기 위한 sudo code 를 작성하고, 더 필요하다고 생각이 나면 그 즉시 코드에 sudo code 를 바로 바로 추가하여, 구현하려고 생각만 하고 잊고 마는 일은 없도록 하는 것이 좋겠다
- 지금 bfs 와 lss 를 위한 데이터 및 인스트럭션을 각각 작성했는데, 이것 외에도, 마치 서버와 클라이언트처럼, 서버역할을 하는 데이터는 공통으로 두고 이를 통해 bfs 및 lss 전용 structure 를 다뤘으면 어땠을까?
- 제발 키보드 좀 가져오자!! 클러스터 키보드 고장난거 걸리면 너무 불편하다!!
- push_swap 의 경우 instruction 과, 가장 알맞은 구조를 작성하고, 이 구조를 가져와 사용하는 형식으로 진행했으면 더 좋았을 것 같다
- 자동으로 .c-.h pair 생성하는 프로그램
- typedef 보다 structure 를 사용하면 확장성 측면에서 유리하다
  - typedef 는 구조체와 달리 새로운 맴버 변수를 추가할 수 없어서, 이런 변경을 해야할 때는 큰 노동력이 요구된다
  - 반면 structure 는 쉽게 새로운 맴버 변수를 추가할 수 있다
- 항상 처음에는 확장하기 쉬운 유연한 구조로 프로그램 작성을 시작하자
  - 프로그램이 배포되기 전까지는 계속 계속 계속하여 프로그램이 유기적으로 변할 가능성이 있다
  - 후에 배포 전후로 성능을 개선해주도록 하자
- buffer 가 자신 만의 특수한 수정 기능을 가지고 있다면, 이름을 단순히 buffer 로 할 것이 아니라 접두사나 접미사를 붙이는 것이 좋을 것 같다
- instruction 을 화면에 출력하는 print 함수 파일도 따로 있었으면 좋았을 것 같다
- 맴버 변수의 데이터 타입은 선언만 되어서는 정의하는 것을 컴파일러가 에러를 발생시킨다. 꼭 구현을 include 해야 한다
- 텍스트를 생성하는 작업장이 있었으면 좋겠다



#2021-06-03

- 'git show <commit hash>:<path/of/file>': Display content of the file to stdout.
- 'git checkout <branch or commit> -- <path/of/file>': Get file from another branch or commit.



#2021-05-31

docker 를 run (또는 start) 할 때 실행한 명령이 종료되면 다른 실행중이던 명령도 다 종료되면서 container 가 exit 상태가 된다



#2021-05-30

- 어떤 대상과 비교를 할 때는 그 대상과 설명하는 내용하고의 공통점과 차이점을 가능한 한 구체적으로 해야 좋다
  - 예시> 신분증 제시와 ssl
    - 공통점: 제 3 자로부터 공인 받은 것으로 자신의 신분을 객관적으로 알린다
	- 차이점: 신분증은 고객이 서비스 제공자에게 자신의 신분을 알리고, ssl 은 서비스 제공자가 고객에게 자신의 신분을 알린다



#2021-05-27

- 어느 정도까지 최적화를 진행해야 하는가?
  - 사용하는 프로그램에 따라 정도가 다르다고 생각한다
  - 각 프로그램마다 가독성을 최우선으로 여기고, 그 다음에 최적화를 고려하도록 하자
  - 가독성이 떨어지는 최적화는 해당 언어를 사용하여 프로그램을 작성하는 프로그래머의 역할이 아니라 언어를 컴파일하는 컴파일러를 제작하는 프로그래머의 역할이다
0. 원형 양방향 모델, front 만 존재
1. 정렬한다
2. 거꾸로 돌면서 한바퀴를 순차적으로 돌 때 가장 큰 수부터 차례로 체크하여 숫자를 얼마까지 만나는가?
3. 그 수보다 하나 작은 수가 나올 때까지 더 작은 수는  b 로 이동시킨다, 이 때 ra 로 돌린다
4. 그 수는 b 의 하단에 보관하고 분류가 끝나면 a 로 옮긴다
5. 점차 작은 수를 가져온다, 이 때는 rb 또는 rrb 중 빠른 것을 선택한다
6. 만약 어떤 수를 탐색하던 중 그 수보다 바로 하나 작은 수를 먼저 마주치면 a 의 하단에 저장해놓으면 좋지 않을까?



#2021-05-26

- 탐색의 제한을 하는 부분은 어디에 둘까?
  - instruction 과 별개로 작동했으면 좋겠다
  - 'check_should_instruction_pa() -> pa()' 처럼 instruction 을 실행할지 건너뛸지를 체크하는 함수를 instruction 전에 실행하는 것이 좋겠으나, 성능상 우선 통합하도록 하자
- 어떤 구조체를 생성할 때, 만약 값이 밖에서 자유로운 값을 설정해주려면 인자로 받도록 하고, 주변 환경에 구애받지 않는다면 내부에서 생성해주도록 하자
- 구조체도 이름이 여러개면 좋을 때가 있는 것 같다
  - branch-node 개념을 list-element 로 구현함
    - 외부에서는 branch-node 가 좋고 내부적으로는 list-element 가 좋다
- array 만 heap 에 할당하고 그 외에 정적 크기를 갖는 list, queue 등은 stack 에 할당할까 생각해 보았는데, 매번 새로운 스택에서 list 와 queue 와 array 의 주소 값을 연결해줘야하는 overhead 가 존재해서, 그냥 heap 에 다 할당하는 것이 좋을 것 같다 (한 번 만들면 프로그램이 끝날 때까지 해제 없이 사용하기 때문에)
- 다음 프로젝트는 generic 한 구조로 진행해보자. 우선 성능을 신경쓰지 않고 작성한 후, 문제가 된다면 시간 복잡도가 가장 복잡한 곳부터 수정하는 방식이다
- 아무 값도 넣지 않아도 기본적으로 작동하도록 만들자
  - 직접 값을 설정하도록 만들고, 딱 한 번만 값을 쓰도록 여러 함수에 나눠놓았더니, 어떤 값이 설정됐는지 안됐는지 확인하기가 무척 어려웠다
- count 의 증가는 앞에서, 혹은 뒤에서?
  - while 에서 자연스럽게 1 씩 증가하는 경우 convention 적으로 뒤에 배치하도록 하자
  - 그 외에는 우선 loop 안에 count 의 증감식을 작성하고, 다른 내부 표현식들의 위치를 결정하자



#2021-05-21

- 값을 읽어서 model 을 만드는 정도의, 성능에 critical 하지 않은 경우는 하드 코딩하여 성능 향상을 추구하기 보다는 유연하고 확장적인 추상화 모델을 만들도록 하자
- name convention 을 통일하기 위해 vector3 를 p_vector3 로 하는 것이 더 좋았을 것이다
- [stackexchange/Vim search replace all files in current (project) folder](https://vi.stackexchange.com/questions/2776/vim-search-replace-all-files-in-current-project-folder)
  - ':args <file or directory>': similar 'vim <file or directory>' on cli
  - ':argdo <vim command>': do command to all open file



#2021-05-20

[wiki/regular expression](https://en.wikipedia.org/wiki/Regular_expression)
- '.' 은 '\n' 을 제외한 모든 문자와 matching 된다는데 regex 는 '\n' 와 matching 은 안되는 걸까?
  - 여러 주변 환경에 따라 추가할지 말지는 취향이다
[wiki/glob](https://en.wikipedia.org/wiki/Glob_(programming))
- '*': matches any number of any characters including none
- '?': matches any single character
- '[abc]': matches one character given in the bracket
- '[a-z]': matches one character from the (locale-dependent) range given in the bracket
- '[!abc]': matches one character that is not given in the bracket
- '[!a-z]': matches one character that is not from the range given in the bracket



#2021-05-18

```zsh
Undefined symbols for architecture x86_64:
  "_bmp_write_image_to_file", referenced from:
      _generate_image in t_application.o
ld: symbol(s) not found for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
make: *** [miniRT_debug.out] Error 1
```
  - 위와 같은 메세지를 띄우며 컴파일이 한참 진행중이다가 완료되지 못하고 끝에 link error 가 발생하는 경우가 있다
    - 이 경우 컴파일러가 해당 함수가 존재함을 function prototype 을 통해 인지했기 때문에 컴파일 에러가 발생하지는 않았지만 프로그램의 binary code 를 생성하기 위해 찾아보니 실제 해당 함수의 binary code 가 존재하지 않는 경우 출력되는 에러 메세지이다
- [linuxconfig/Understanding of ls command with a long listing format output and permission bits](https://linuxconfig.org/understanding-of-ls-command-with-a-long-listing-format-output-with-permission-bits)
  - permission / number of linked hard-links / owner of the file / to which group this file belongs to / size / modification or creation date and time / file or directory name
- directory 를 hard link 로 만드는 것은 간단하지 않다, 그러므로 libft directory 를 hard link 로 만들어서 사용하는 것은 norm 을 벗어나고 나서 생각하자



#2021-05-17

-[superuser/How to sort first directories then files etc… when using “ls” in Unix](https://superuser.com/questions/109537/how-to-sort-first-directories-then-files-etc-when-using-ls-in-unix)
  - ls | sort -k1,1 -k9,9 -r
- 화면에 vim 을 10 개 이상씩 가득 띄워놓고 보는 것은 솔직히 썩 바람직한 방식은 아닌 것 같다. 오늘 keynote 로 struct 간의 reference 그래프를 그려보았는데, 이렇게 하고 보니 전체적인 프름이 한 눈에 보였고, 어떻게 추상화할지를 판단하기 훨씬 수월했다 (전에는 거의 불가능하거나 오랜 시간을 들여야만 했다)



#2021-05-13

- search keyword
  - architecture
  - underneath
  - underlying mental model and architectur
- line 을 읽는 기능과 split 을 구현할 때, 이미 많은 것을 구현한 miniRT 폴더에서 진행하는 것이 아니라 새로운 모듈을 만드는 장소를 따로 만들어서 진행하고, 기능이 충분히 구현되었다고 생각하면 그 때 합치는 것이 좋을 것 같다



#2021-05-07

0x00 ~ 0x01:  2 "BM" as ascii
0x02 ~ 0x05:  4 total size of bmp file in byte (file header size (14) + dib header size (124 in v5) + color array size (width * height * bpp / 8)
0x06 ~ 0x09:  0 reserved, set 0
0x0a ~ 0x0d:  4 offset of color array (138 in v5)

0x0e ~ 0x11:  4 bV5Size: dib header byte size
0x12 ~ 0x15:  4 bV5Width: 가로 픽셀 수
0x16 ~ 0x19:  4 bV5Height: 세로 픽셀 수
0x1a ~ 0x1b:  2 bV5Planes: 1 고정
0x1c ~ 0x1d:  2 bV5BitCount: bit per pixel
0x1e ~ 0x21:  4 bV5Compression: 압축 없으면 0
0x22 ~ 0x25:  4 bV5SizeImage: 온전한 이미지 크기
0x26 ~ 0x29:  4 bV5XPelsPerMeter: 잘 모르면 0
0x2a ~ 0x2d:  4 bV5YPelsPerMeter: 위와 동일
0x2e ~ 0x31:  4 bV5ClrUsed: 위와 동일
0x32 ~ 0x35:  4 bV5ClrImportant: 위와 동일
0x36 ~ 0x39:  4 bV5RedMask: big endian 형식의 argb mask
0x3a ~ 0x3d:  4 bV5GreenMask: 위와 동일한 형식
0x3e ~ 0x41:  4 bV5BlueMask: 위와 동일한 형식
0x42 ~ 0x45:  4 bV5AlphaMask: 위와 동일한 형식
0x46 ~ 0x49:  4 bV5CSType: 42 47 52 73
0x4a ~ 0x6d: 36 bV5Endpoints: 잘 모르면 따라하기, 아마 색상의 한계를 결정
	0000040                               80 c2 f5 28 60 b8
	0000050 1e 15 20 85 eb 01 40 33 33 13 80 66 66 26 40 66
	0000060 66 06 a0 99 99 09 3c 0a d7 03 24 5c 8f 32
0x6e ~ 0x71:  4 bV5GammaRed
0x72 ~ 0x75:  4 bV5GammaGreen
0x76 ~ 0x79:  4 bV5GammaBlue
0x7a ~ 0x7d:  4 bV5Intent: 이 이미지의 의도에 대한 데이터를 담는다. 04 00 00 00
0x7e ~ 0x81:  4 bV5ProfileData: 0
0x82 ~ 0x85:  4 bV5ProfileSize: 0
0x86 ~ 0x89:  4 bV5Reserved: 0

- 코드에 압도되는 것은 좋지 않은 상황이다. 앞길이 막막해지고, 어딜 건들여야할지 바로 보이지 않을 때가 있다
- 코드의 많은 부분에 영향을 줄 경우 2 가지 경우의 수가 있다
  - 오류가 나지 않는 경우: 이 경우는 빠르게 굴러가는 프로그램을 작성할 수 있어 좋다
  - 오류가 발생하는 경우: 이 경우는 끔찍하다. 코드의 너무 많은 부분을 바꾸었기 때문에 어디에서 문제가 발생했는지 알 수 없게 되기 싶상이다
- lldb 로 특정 변수 값이 변경되는 지점을 break 하는 것이 가능 'watchpost'
- lldb 로 특정 frame 으로 이동하는 것이 가능 up, down, frame set
- 나는 위치와 방향에 따른 모든 경우를 출력 가능하도록 구현햇는데, 다른 방법으로 default 상태를 구현하고 이를 평행 이동, 회전 이동 하여 도형의 최종 상태를 출력하는 방법도 있는 것 같다



#2021-05-06

- 최적화를 위한 다양한 기법은 멀리서 보면 서로 다 다르고 각각을 공부해야 한다고 생각할 수도 있다. 하지만 하고자 하는 진정한 마음이 있고, 본질을 공부한다면 그것들은 공부하지 않아도 만들어낼 수 있는 것들이다, 라고 생각한다
- t_bmp 가 엔디안을 신경 쓸 필요는 없다. 이미지를 생성하여 서버에 전송할 때 빅 엔디안이면 스몰 엔디안 형식으로 바꾼다던가, 등 작업을 하기 때문에 bmp 는 이렇게 생성된 이미지를 저장하기만 하면 된다
  - 아니다. 이미지의 주소를 받아오면서 얻는 endian 값은 서버의 endian 이기 때문에 이것이 적용된 상태로 이미지를 저장하면 안된다. 현재 프로그램이 작동하는 시스템의 endian 을 토대로 small endian 방식으로 저장하면 된다
  - endian 은 메모리와 관련된 것이라고 한다. 따라서 현 endian 을 자연스럽게 저장하면 제대로 된 bmp 파일이 되지.. 는 않을 것 같다
- 왜 해야하는가, 왜 추가해야하는가
  - 지금까지 만든 것은 어떤 기능을 가지고 있는가
  - 지금까지 만든 것은 무엇인가
    - 새로운 기능을 추가하면 기존과는 무엇이 다른가
	- 꼭 추가해야만 하는가
- 꿈을 꿔라, 그리고 끊임없이 꿈을 위한 목표를 만들어라
0x00 ~ 0x0d: bitmap file header
0x0e ~ 0x11: bV5Size
0x12 ~ 0x15: bV5Width
0x16 ~ 0x19: bV5Height
0x1a ~ 0x1b: bV5Planes
0x1c ~ 0x1d: bV5BitCount
0x1e ~ 0x21: bV5Compression
0x22 ~ 0x25: bV5SizeImage
0x26 ~ 0x29: bV5XPelsPerMeter
0x2a ~ 0x2d: bV5YPelsPerMeter
0x2e ~ 0x31: bV5ClrUsed
0x32 ~ 0x35: bV5ClrImportant
0x36 ~ 0x39: bV5RedMask
0x3a ~ 0x3d: bV5GreenMask
0x3e ~ 0x41: bV5BlueMask
0x42 ~ 0x45: bV5AlphaMask
0x46 ~ 0x49: bV5CSType
0x4a ~ 0x6d: bV5Endpoints
0x6e ~ 0x71: bV5GammaRed
0x72 ~ 0x75: bV5GammaGreen
0x76 ~ 0x79: bV5GammaBlue
0x7a ~ 0x7d: bV5Intent
0x7e ~ 0x81: bV5ProfileData
0x82 ~ 0x85: bV5ProfileSize
0x86 ~ 0x89: bV5Reserved
- BMP format 으로 이미지를 저장하기 위해 file_header[], dib_header[] 등을 만들었는데, 각 데이터의 index 를 define 하여 데이터를 쓰고, 만들어진 배열을 파일에 write 하려고 했다. 그런데 index 로 입력한 값을 그냥 배열 통채로 사용해버릴 때는 문제가 없었지만, 결국 이미지의 width, height 등은 다른 곳에서도 쓰일 수 있기 때문인데 일단은 다른 곳에 있는 데이터를 가져다가 사용하기로 했다 (width 와 height 는 p_image 로부터 등)



#2021-05-05

- 테스트 환경 구성하여 테스트 진행
  - 이점: 원하는 값을 넣고 결과 값이 잘 나오는지 확인할 수 있다
  - 디버깅 툴과의 차이점
    - 디버깅 툴은 에러를 잡아내는 것: 실제 프로그램을 실행해볼 수 있지만 테스트에 비해 부담스럽고 값을 원하는데로 마구 넣어보기 번거롭다
- 프로그래머가 하는 일은 글을 쓰는 것이다. 문체도 물론 중요하지만 가장 중요한 것은 얼마나 방대한 세상을 가지고 있느냐 하는 것이다. 그리고 그것을 글로 잘 풀어냈는가이다
- 프로그램을 만드는 과정에는 재밌는 과정도 있고 재미 없는 과정도 있다. 다소 재미 없는 과정이라면 그 과정에 당신의 꿈을 담아라
  - 가령 특정 파일을 파싱하는 기능을 추가하거나, 출력된 이미지를 파일로 저장하는 기능을 추가하는 작업은 지루할 수 있다. 하지만 그것이 불가능한 경우와 가능한 경우를 생각하면서 있으면 정말 좋겠다고 생각을 하는 것이다
- 평면 도형의 normal 과 ray 의 direction_vector 과 수직인 경우 intersects, blocks 는 어떻게 처리해야 할까?
  - 평면 도형의 두께는 0 으로 생각하자
- antialising 말고 테두리 픽셀의 절확한 밀도를 계산해서 출력하면 어떨까?
- rgb 소자들이 뭉쳐 하나의 픽셀 을 보는 것처럼, 여러 픽셀들이 뭉쳐 하나의 점을 볼 수도 있다. 이로 인해 픽셀 단위의 단절된 이미지를 자연스럽게 만들 수 있다
- 기울기가 정확히 축과 평한한 경우 등 double 의 오차로 인해 충돌 여부가 판가름 나는 수도 있다. 이런 경우는 따로 처리하지 않겠다. 처리를 하는 것도 야매로 가능하지 정확한 계산은 불가능해 보인다 (이미 정확히 계산한 결과가 저런 것이다)
  - 마찬가지로, 오차로 인한 그림자 여부도 추가로 잡아주지는 않겠다
- [BMP file format](https://en.wikipedia.org/wiki/BMP_file_format)
  - bitmap 은 더 포괄적인 의미이고 BMP 는 bitmap 중 특정 포멧이다
  - 아마 최적화를 위해 프로그램 내부적으로 사용되는 이미지는 자신만의 bitmap 데이터 타입을 정의하는 모양이다



#2021-05-04

- 빛이 평면 위의 점일 경우를 잘 처리해주자
- 일단 돌아가는 프로그램을 작성하라, 그리고 계속 보다보면, 그리고 반복해서 작성하다 보면, 최적화를 할만한 부분이 보인다!
  - 물론 최소한의 계획은 가지고 프로그램을 작성해야 한다
    - (최소한의 계획이라는 녀석은 주관적이다)
- 제대로 표현하지 않으면 어차피 나중에 계속 후회한다
  - 일단 내 잘못이면 나중에 후회할 확률이 높다 문젝 없더라도 사과하는 것이 맞다 그게 맞다
- x 와 z 가 모두 0 인 카메라 orientation 을 받을 때 xz_magnitude 가 0 이 되어 0 으로 나누게 되는 문제



#2021-05-03

- 공유의 목적이 아닌 기록 및 보관 용도로는 잘 꾸미는 데에 시간을 투자할 필요가 없으므로 (최소한의 가독성 확보가 목표이다) md 포멧보다는 txt 포멧을 사용하는 것이 유리하다
- 우연히 발견한 것이지만 double 의 오차로 랜덤하게 0 또는 1 을 생성할 수 있을 것 같다
- pow 의 남발을 지양하고 sqrt 와 * 를 사용하자

- geometry 위의 어떤 점 P 가 line 과 geometry 가 만나는 가장 가까운 점인지를 확인하기 위해 intersects 만으로는 부족하다. intersects 는 가장 가까운 k 값을 반환하지만, 가장 가까운 점이 P 일 때 P 를 위한 k 값과 가장 가까운 k 값을 비교하면 double 타입이기 때문에 오차로 인해 같은지 판단하는건 부정확하다. 따라서 도형마다 어떤 점이 도형 위에 있는 점이라고 가정하고, 그 점이 빛을 받는 점인지 확인할 수 있도록 추가적인 함수를 둬야 좋겠다
- reference type 은 instance method 의 첫 인자로 instance 를 받고,  value type 은 instance method 의 마지막 인자로 instance 를 받도록 하면 좋을 것 같다
- vector3_init() 추가
- vector3_cos_theta() 추가
- 빛의 세기는 거리의 제곱에 반비례한다
  - 이 경우 특정 부위는 과하게 밝게 표현단다
    - 이를 해결하기 위해서는 2 차 3 차 반사를 적용해야 한다
- 삼각형은 각도록 점의 위치가 안에 있는지 밖에 있는지를 구분했다



#2021-04-11

- 다음 두 함수의 차이가 있을까?

int strlen(char s[])
{
	int i = 0;
	while (s[i] != '\0')
		++i;
	return i;
}

int	strlen(char *s)
{
	char *ptr = s;
	while (*ptr)
		++ptr;
	return (ptr - s);
}

- -1L vs 1UL: unsigned long 타입으로 변환되고 비교한다면 -1L 이 더 크게 된다. 실제는 어떨까?



#2021-01-28

클러스터는 예약시스템 지금은 코로나가 심해져서 예약조차 안되는 듯 하다
2.5 단계 밑으로 내려가야 클러스터 사용이 가능하다



#2021-01-15

```zsh
% cat display_line.sh
$1 | wc -l
% ./display_line.sh set
      41
% sh display_line.sh set
      41
% zsh display_line.sh set
     145
% set | wc -l
     167
% source display_line.sh set
     167
% bash

The default interactive shell is now zsh.
To update your account to use zsh, please run `chsh -s /bin/zsh`.
For more details, please visit https://support.apple.com/kb/HT208050.
bash-3.2$ set | wc -l
      47
```

- 왜 set 의 결과 값이 달라지는 것일까?



#2021-01-14

- 전선이 모든 주파수를 다 통과시키지 못하고 제한된 영역의 주파수만 전달이 가능한 이유가 무엇일까? [youtube](https://youtu.be/1pfTxp25MA8?t=368)
- 디지털 신호도 원하는 주파수를 만들어서 전송할 수 있을 것 같은데 굳이 아날로그 신호로 바꾸어서 전송해야 하는 이유가 무엇일까? [youtube](https://youtu.be/1pfTxp25MA8?t=386)
ttps://opentutorials.org/module/3747



#2020-12-25

(T: Think, D: Do)
- T: Ratio of my study and others study
  - Just help others study, and if i get some thought of 'It's not right', then reject it
  - Never present a fish, teach how to get that
- D: More practice the way to use `find` command



#2020-12-24

(Q: Question, I: Idea)
- Q: When i set the argument type of main, even making it pointer is common, making it array also possible, will there some difference?
- Q: Will it possible executing according to the extension of file in vim?
  - :set autoindent for .md
  - :set cindent for .c
- I: What about a program which show real memory state on one side and what happenning at code at the other side?
  - Simulate very little computer, so i can see the memory at one display
- Q: Can i access NULL pointer?
- Idea: mobile golf game
  - Scroll the mobile display, if your display stop at to goal, you are hole in one :D



#2020-12-23

- Q: I can set the data type of function as array or pointer, if I set the type as array, will it take all feature of array? (or it's actually just pointer)
    char    str[] = "lol";
- Q: imo, `"lol"` might be stored in data block and copy it to str array, correct?



#2020-12-08

1.3. x: delete a character
1.4. i: enter `insert mode`
1.5. a: enter `insert mode` with appending

2.1. dw: delete a word
2.2. d$: delete to the end of line
2.3. `command target`: dw, de, d$
	enable target example: w, e, $, 0, b, h, j, k, l, H, L, {, }
2.4. `count command`: 2w, 3e
	0: move cusor  the start of the line
2.5. `command count target`: d2w
2.6. dd: delete a line
	`count command target`: 2dd, 2dw
2.7. u: undo last command
	ctrl-r: redo last undo

3.1. p: put vim's buffer content behind the cursor
	if vim's buffer has a line, put it under line of the cursor
3.2. r: replace a character without mode change
3.3. c target: delete target and enther `insert mode`(change): ce, c$, c2w, 2cw

4.1. ctrl-g: display the path of the file and state
	G: move to the last line of the file
	gg: move to the first line of the file
	count G: move to the count line
4.2. / 'what to search': search downward
	? 'what to search': search upward
	n: search next
	N: search previous
	ctrl-o: move previous cursor position
	ctrl-i: move next cursor position
4.3. %: move to the matching bracket
4.4. :s/old/new/g: subtitute 'old' to 'new'
	:s/thee/the: subtitute only first encountered 'thee'
	:s/thee/the/g: subtitute all(globally) 'thee' to 'the' in this line
	:#,#s/old/new/g: #,# mean the line number of two line
	:%s/old/new/g: search target from whole the file
	:%s/old/new/gc: you can command by prompt whether subtitute or not

5.1. :! 'extern command' <ENTER>: excute extern command
5.2. :w FILENAME: write current file as FILENAME
5.3. :'<,'>w FILENAME: save selected range as FILENAME
5.4. :r FILENAME: read and put FILENAME file under the cursor line
	:r !ls: read and put the result of 'ls' extern command under the cursor line

how to show pressed command state?
default output resolution: 853x480



#2020-11-27

which vimmemo
(in vim normal mode): ":echo $MYVIMRC"
	# You can easily find the location and name of the file on any operating system.
how to move cursor to top or bottom of screen in vim?
	# H: move cursor to top of screen.
	# L: move cursor to bottom of screen.
	# {: move cursor to previous paragraph.
	# }: move cursor to next paragraph.
why use link?
	# For to call same function as different names
what is the difference between soft link and hard link?



#2020-11-05
c7r9s4% ./a.out test.dat 10
fd: 3 
[ 1]read character: ''(104) 
ret_read           : [1] 
[ 2]read character: ''(105) 
ret_read           : [1] 
[ 3]read character: ''(32) 
ret_read           : [1] 
[ 4]read character: ''(112) 
ret_read           : [1] 
[ 5]read character: '.'(10) 
ret_read           : [1] 
[ 6]read character: '.'(106) 
ret_read           : [1] 
[ 7]read character: '.'(104) 
ret_read           : [1] 
[ 8]read character: '.'(10) 
ret_read           : [1] 
[ 9]read character: '.'(10) 
ret_read           : [0] 

analyze:
test.dat has 8 bytes size.
8th byte(last character of file) is newline character.
after read last character, if you try to read more character, the return value will be 0.
if `read()` try to read impossible, it will return 0.
`read()` function return read byte size.



#2020-11-4
"abcd"[2]: has something to think!
strcmp return 2 case (1. -1, 0, 1), (2. ch1 - ch2)



2020-11-1
test git when init pull would delete another file?



#2020-10-21

ctrl + u: clear current terminal line befor cursor
ctrl + k: clear current terminal line after cursor
[vim] d: cut selected text
[vim] y: copy selected text
[vim] p: paste selected text before cursor
[vim] P: paste selected text after cursor



#2020-??-??

echo "*"    # *
echo '*'    # *
echo /*    # *
echo *    # display all files
echo ~    # display home path
echo ?    # display all 1 character

echo "$truc"    # isACar
echo '$truc'    # truc

cat [-e]
more    # work like man page
head
tail

grep [-iv]

ls bonjour 2> error.log
ls bonjour test* > res.txt 2> error.log
ls bonjour test* 2> error.log | grep test00

cat batman.txt | grep Joker | wc -l
grep Joker < batman.txt | wc -l

echo coucou > res.txt    # write file
echo coucou >> res.txt    # append file

cat << FIN    # read until FIN
ls bonjour *.txt > resultat.txt 2>&1
cat resultat.txt

ctrl d
ctrl c
ctrl \



#2020-10-14

gzip -d <file>
tar -zxvf <file>
man cut
man diff
man patch
tar -cf exo2.tar *



#2020-10-13

ctrl a
ctrl e

opt <-
opt ->

ctrl u
ctrl k

hexdump

Put some unfamiliar shortcut image aside. 
