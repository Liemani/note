pour.txt

2022-02-07
- C++ Primer Plus 5ed
	- 378p
	- template function을 override하기 위해 non-template function을 사용하면 되는데 굳이 explicit specialization function을 사용하는 이점이 무엇일까?
	- swift의 generic function은 특정 조건을 만족하는 Type을 위해 mece하게 정의한다.
	- 반면 c++의 template은 조건 없이 모든 Type에 대해 함수를 정의한다.
	- 그래서 swift는 추가적인 syntax인 specialization등이 필요 없이 필요에 따라 generic function을 더 구현하면 된다.(수평적 구성)
	- 하지만 c++는 specialization이라는 추가적인 syntax를 만들어서 특정 Type을 위한 특별한 함수 호출을 가능하게 하였다.(수직적 구성)
	- 380p
	- template으로부터 생성된 특정 Type을 정의하는 함수를 an instantiation of the template이라고 한다.
	- Compiler generates an instantiation of template function.
	- implicit instantiation
	- explicit instantiation
```
template
void	swap<Type>(Type& lhs, Type& rhs);
```
	- 해당 prototype을 구현할 때 swap template을 사용한다는 의미이다.
	- 381p
	- explicit specialization
```
template <>
void	swap<Type>(Type& lhs, Type& rhs);

template <>
void	swap(Type& lhs, Type& rhs);
```
	- 381p
	- implicit instantiation, explic instantiation, explicit specialization은 모두 specialization에 포함된다.
	- 382p
	- overload resolution: best viable function을 찾아가는 과정
		1. 이름이 같은 함수들의 list를 만든다.
		2. viable function list를 만든다.
			- viable function: signature가 일치하거나, implicit type conversion을 했을 때 일치하도록 만들 수 있는 함수
		3. best viable function을 결정한다.
			- best viable precedence
			1. template이 아닌 정확한 일치
			2. conversion by promotion(char, short를 int로, float을 double로)
			3. conversion by standard conversion(int를 char나 long이나 double로)
			4. user-defined conversion
	- 383p
	- c++는 exact match를 결정하기 위해 trivial conversion을 한다.
		- trivial conversion
			- Type <-> Type&
			- Type[] -> * Type
			- Type (argument-list) -> Type (*) (argument-list)
			- Type -> const Type
			- Type -> volatile Type
			- Type* -> const Type*
			- Type* -> volatile Type*
		- 단, exact match에서도 non-value type에 대해 non-const type이 const type보다 more viable이다.
		- 그리고 template function보다 non-template function이 more viable이다.
		- more specialized template이 more viable이다.
	- 385p
	- most specialized
		- most specialized는 explicit specialization을 의미하는 것이 아니다.
		- compiler가 overload resolution 중에 viable function list에서 best viable function을 결정하기 위해 template들의 viable 정도를 비교하는 과정에서 적용할 template type을 추론하는 과정에서 가장 적은 type conversion을 요구하는 것을 most specialized라고 한다.
```
template <typename T> void	myFunc(T t);
template <typename T> void	myFunc(T* t);

Type	type;
myFunc(&type);
```
		- 이 경우 viable function pool에 2개의 function prototype이 발견되어 포함될 것이다.
			- void	myFunc<Type*>(T* t)
			- void	myFunc<Type>(T* t)
		- compiler는 이 둘 중에 'void	myFunc<Type>(T* t)'가 more specialized라고 판단한다.
			- 어떤 Type을 추가적인 conversion 없이 template의 T에 그대로 적용할 수 있기 때문이다.
	- partial ordering rule: function template들 중에 most specialized function template을 결정하는 rule
	- 388p
	- more viable of multiple argument function
		- 인자가 여러개인 함수간에 more viable이라고 하기 위해서는, 한 쪽이 다른 쪽에 비해 모든 인자에서 일치하는 정도가 부족하지 않은 채로, 최소 하나의 인자가 더 일치해야 한다.
- gv in vim normal mode: reselect previous selected range

2022-02-06
- C++ Primer Plus 5ed
	- 352p
```
sysop	copycat;
copycat = (const sysop&)looper;
copycat.used = 42;
```
	- 위 코드가 error나 warning 없이 잘 컴파일되고 실행되네?
	- 왜 const type으로 형변환해서 non-const type에 넣어줬는데도 불구하고 error가 발생하지 않는거지?
	- 왜 'sysop&	copycat = looper'와 같이 받지 않고 'copycat = (const sysop&)looper'와 같이 할당해도 alias로 동작하는 거지?
		- 아하, 이 때 copycat은 looper의 alias가 아니라 looper를 copy한 것이구나!
	- const reference type을 인자로 받은 경우 그 object를 non-const reference type으로 return하는 것은 어떨까?
		- 이 경우 const qualifier는 해당 함수 내에서 해당 인자를 수정하지 않겠다는 의미를 지닌다.
		- 반환값에 추가적인 method를 concatenate할 수 있다는 장점이 있다.
		- 하지만 const type을 인자로 넣었을 경우 non-const type을 인자로 받는 method를 concatenate할 수 있다는 치명적인 부작용이 존재한다.
		- 즉, const는 한 번 더 진화할 필요가 있다.
		- const type이 들어오면 const type을 반환하고, non-const type이 들어오면 non-const type을 반환하도록!
	- 355p
	- 만약 c++에서 이런 method call chain을 의도한 것이 아니라면, 이는 의도된 interface들의 side effect이며, 그런 side effect는 직접적으로 의도된 것이 아닌 경우 작동이 보장되지 않을 수도 있고, 작동을 명확하게 이해하기 힘들게 될 수 있다.
		- 따라서 가능하면 작동이 보장되지 않는 side effect를 사용한 기능 구현은 피하여 명확한 코드 작성을 추구하자.
	- 357p
	- conversion from TypeA to TypeB이 존재하는지는 2 부분을 확인한다.
		1. TypeA가 지원하는가?
			TypeA가 TypeB를 인자로 받는 constructor가 존재하는지 확인할 것이다.
		2. TypeB가 지원하는가?
			TypeA로의 type conversion operator가 존재하는지 확인할 것이다.
		- 만약 둘 다 지원하는 경우에는 compiler가 ambigous conversion error를 출력할 것이다.
	- 358p
	- derived class
	- base class reference can refer to a derived class instance without requiring a type cast.
	- 359p
	- EXIT_FAILURE
	- 362p
	- callee에서 primitive type인 caller의 variable을 수정하기 위해서는 pointer type으로 전달받는 것이 좋다.
		- 단순 값을 복사하여 전달하는 것이 아니라 구체적으로 주소를 전달한다는 의도를 명백하게 서술할 수 있다.
	- 363p
	- 꼭 method가 아니더라도, 일반 함수도 default argument를 설정할 수 있다.
	- 365p
	- 함수에 추가적인 guard를 두게 되면
		1. 프로그램의 크기가 커진다.
		2. 프로세스의 처리 시간이 길어진다.
		3. 추가적인 dependency가 생길 수 있다.
	- c 프로그래머는 guard를 두기 보다는 사용자가 함수를 올바르게 사용하도록 두는 경향이 있다.
	- 반면 c++는 안정성에 무게를 둔다.
	- 빠르게 작동하지만 잘못된 동작을 하는 프로그램보다, 천천히 작동하더라도 제대로된 동작을 하는 프로그램이 더 낫기 때문이다.
	- function polymorphism is also called function overloading.
	- function's argument list of function overloading is also called function signature.
	- 366p
	- 함수 호출 시 function signature가 일치하는 prototype을 발견하지 못하는 경우 type conversion을 하여 일치시킬 수 있는 prototype을 찾기 시작하는데, 이 때 이렇게 찾은 prototype이 여러개인 경우 compiler가 ambiguous error를 출력한다.
	- reference to a type과 type itself는 같은 signature로 판단한다.
	- argument type에 const qualifier 유무도 다른 function signature로 판단한다.
	- return type은 function signature에 포함되지 않는다.
		- 따라서 return type만 다른 경우 function overloading이 불가능하다.
	- 370p
	- name decoration(= name mangling)
	- function templates let you program in terms of a geniric type instead of  a specific type
	- generic programming
	- parameterized type
	- 371p
	- template에서 class keyword 대신 typename keyword를 사용할 수 있다.
	- 373p
	- template 기능을 사용하면 기능이 적용된 함수를 호출할 때마다 실제 사용된 type을 위한 함수를 생성한다고 하는데, 그러지 말고 대신 특정 register에 type의 크기를 담고 함수를 실행하여 동적 size를 사용하면 실행할 함수를 하나만 생성해도 되지 않을까?
	- 하지만 c++의 template 기능은 단순히 Type의 size를 치환하는 것을 넘어 Type의 operator를 호출할 때 호출할 함수도 Type이 달라질 때마다 달라질 것 같다.
	- 376p
	- explicit specialization
	- override: 덮어쓰기(overload는 과적)
	- template, specialization, non-template
	- specialization function은 template을 override하고, non-template function은 둘 다를 override한다.
```
template <typename T>
void	swap(T& lhs, T&rhs);

template <> void	swap<Type>(Type& lhs, Type& rhs);
//	== template <> void	swap(Type& lhs, Type& rhs);

void	swap(Type& lhs, Type& rhs);
```

2022-02-05
- C++ Primer Plus 5ed
	- 330p
	- pointer to function인 pf는 (*pf)()로도 호출할 수 있다.
	- 340p
	- https://wikidiff.com/alias/nickname
		- Nickname vs Alias - What's the difference?
	- nickname은 별칭인 것이 공공연한 가명이고, alias는 실제 이름과 마찬가지의 권위를 지니는 가명이다.
	- 342p
	- standpoint, aspect, perspect, point of view
		- https://wikidiff.com/aspect/standpoint
			- Standpoint vs Aspect - What's the difference?
		- standpoint는 point of view를 의미한다.
		- aspect는 겉보기 모습의 뜻을 가진다. 측면이라는 뜻도 있다. direction을 가진다.
		- perspective는 전망이라는 뜻이다. '멀리 내다보기' 같은 느낌이다.
	- 'Type&' type은 마치 'Type* const' type처럼 처음 한 번 초기화 후 alias 대상을 변경할 수 없다.
	- 344p
	- interface와 implementation을 구분지어 설명하도록 노력하자.
	- "call by value가 실제 값을 복사하여 사용하는 반면 call by reference는 인자에 직접 접근하여 사용한다"라는 문장은 마음에 들지 않는다.
		- 이는 interface를 설명한 것인데, interface인지 implementation인지 설명을 해주지 않으면 implementation으로 생각할 수 있다.
		- 실제로 내가 이 설명을 implementation으로 생각하고 "응? 그러면 reference type의 인자는 값을 그대로 사용하니까 포인터보다 더 가볍겠네?"라는 어리석은 생각을 갖게 되었다.
		- 하지만 이 설명은 implementation이 아니고 interface이기 때문에, 실제 implementation은 pointer와 완전 동일할 수도 있다는 것이 중요하다.
	- 349p
	- temporary variable
		- 'x + 3.0'이라는 expression을 평가한 값을 지니는 개념의 변수를 (nameless | unnamed | anonymous) temporary variable이라고 한다.
	- reference type을 인자로 받는 함수에 인자로 variable이 아닌 expression을 pass할 때 c++는 temporary variable을 생성할 수 있다.
	- 단, const reference type을 인자로 받는 함수에 한해서 temporary variable을 생성한다.
	- 이렇게 생성된 temporary variable은 stack에 존재할 것이기 때문에 값을 바꾼다고 해도 다른 곳에 저장하지 않으면 사라진다.
	- 따라서
		1. 다른 곳에 저장하지 않을 것이라면 값을 바꾸는 것이 의미가 없다.
		2. 다른 곳에 저장할 것이라면 저장하고 그것을 바꾸면 된다.
	- 따라서 temporary variable은 값을 수정할 필요가 없다.
	- 하지만 그렇다고 해도 const qualifier가 붙지 않는 type을 인자로 받는 함수의 인자로 사용되지 못할 이유는 무엇일까? 
	- lvalue와 rvalue를 생각해보자.
	- temporary variable은 명백한 rvalue이다.
	- rvalue의 다양한 형태를 생각해 보자(데이터 수집): 'var + 1'(operator expression), 'function()'(function return)
	- 이런 rvalue들은 반드시 특정 메모리 공간을 할당받는 것이 보장되지 않는다.
	- 단지 register에서 load, store를 사용하는 것만으로 rvalue를 처리하는데 충분할 때도 있을 것이다.
	- 따라서 rvalue라는 interface를 정의할 때 const type으로 강제하자고 해도 납득이 간다.
	- 게다가 rvalue의 interface를 const type으로 강제하더라도 code를 작성할 때 추가적으로 문제가 생기는 것도 아니다.
	- 추가적으로 temporary variable을 값을 바꾸지 않도록 제한함으로써, 실수로 non-const type의 인자를 받는 함수의 인자로 전달할 때 error를 발생시켜서 빨리 문제를 파악할 수 있는 이점을 얻는다.
	- 351p
	- const keyword는 프로그램의 작동에 차이를 만들지는 않는다.
	- 하지만 값을 쓰지 않는 공간이라는 개념을 표현함으로써, 실수로 값을 update했을 때 이를 인지하고 error 메세지를 출력하도록 할 수 있다.
- array[index] = 0
	- 이 표현을 assembly에서 하나의 instruction으로 처리한다.(array와 &index를 x9와 x10에 저장하는 instruction 제외)
	- str w8, [x9, x10, lsl #2]
		- w8도 굳이 'mov w8, #0'을 하던데 왜 wzr를 사용하지 않은 것인지는 모르겠다.
- index가 0부터 n이 될 때까지 loop하면서 array의 값에 접근해야 하는 경우 array[index]가 body에서 2~3번 이상 호출된다면 아래와 같은 방식이 가장 좋은 것 같다.
```
int	index = 0;
Type*	element = array;
while (index < n) {
	//	body

	element += 1;
	index += 1;
}
```
- local variable은 stack의 마지막 위치에 생성되는데, sp는 0x10 단위로 감소하기 때문에 변수를 위한 공간이 딱 맞아떨어지지 않으면 남는 공간이 생기는데, 이 때 sp가 가리키게 되는 stack의 마지막 공간(가장 작은 주소)이 사용되지 않고 남는다.

2022-02-04
- minishell project를 AST를 사용하려고 시도하는 분이 계시던데, minishell의 경우 특정 syntax가 여럿 존재하는 것이 아니라 AST로 구현하는 것은 적합하지 않다고 생각한다.
- 'adrp xn k' in assembly: 특정 주소부터 0x1000 * k 만큼 더한 주소값을 xn에 저장한다.
- 'xxd -a a.out'으로 프로그램을 출력해보면 상당히 큰 공간을 '00'이 차지하고 있는 것을 알 수 있다.
	- 이는 cpu를 덜 쓰기 위해 program의 memory load를 단순 복사만으로 구현했기 때문일 것 같다.
- 아래와 같은 source를 compile했을 때, **array는 array[0][0]을 의미한다. 그렇다면 array는 &array[0]를 가지고 있을까?
```
int	main(void) {
	int	array[2][3] = {
		{ 5, 4, 3, },
		{ 2, 1, 0, },
	};
	int	(*pointerArray)[3];
	int	*pointer;

	pointerArray = array;
	pointerArray += 1;
	pointer = *array;
	pointer = *array + 1;

	return 0;
}
```
- pointerArray는 'int (*)[3]' type이고, pointer는 'int*' type이다.
- 아래 코드는 위 source의 assembly의 일부이다.
	- &array는 sp + 0x20이다.
	- &pointerArray는 sp + 0x10이다.
	- &pointer는 sp + 0x8이다.
```
`** 9   		pointerArray = array;

    0x100003f4c <+60>:  str    x8, [sp, #0x10]

** 10  		pointerArray += 1;

    0x100003f50 <+64>:  ldr    x9, [sp, #0x10]
    0x100003f54 <+68>:  add    x9, x9, #0xc              ; =0xc 
    0x100003f58 <+72>:  str    x9, [sp, #0x10]

** 11  		pointer = *array;

    0x100003f5c <+76>:  str    x8, [sp, #0x8]

** 12  		pointer = *array + 1;
   13  	

    0x100003f60 <+80>:  add    x8, x8, #0x4              ; =0x4 
    0x100003f64 <+84>:  str    x8, [sp, #0x8]
``
- 'pointer = *array'의 assembly를 보면 'pointerArray = array'와 마찬가지로 x8의 값(&array[0][0])을 'sp + a'에 store하고 있다.
	- 즉, 'int (*)[3]' type의 값을 저장하는 배열이 따로 존재하는 것이 아니다.
	- 따라서, 이중 배열의 경우 *array를 실제 array가 저장하고 있는 값을 주소로 하는 변수의 값을 반환하는 것이 아니다.
	- 이중 배열의 포인터 연산의 경우 내부적으로 의미에 맞는 assembly를 생성한다.
		- '*array'는 'int [3]' type이기 때문에 '*array + 1'은 'add x8, x8, sizeof(int)'가 된다.
		- 이때 array는 이중 배열이기 때문에 *array를 evaluate할 때 &array[0]를 저장하고 있는 x8의 값을 주소로 하는 값을 읽는 것이 아니라 x8의 값을 그대로 반환한다.
- C++ Primer Plus 5ed
	- 314p
	- c는 처음에는 argument로 structure type의 variable을 value로 전달하지 못하도록 했다.
	- carry
	- 316p
	- rectangular coordinates
	- polar coordinates
	- 320p
	- pointer to structure
	- 324p
	- c에서는 main()에서 main()을 호출하는 것이 허용된다.
	- c++에서는 main()에서 main()을 호출하는 것이 허용되지 않는다.
	- recursion
	- recursive function
	- 326p
	- recursive function이 한 번 호출될 때마다 sp가 0x30정도씩 감소할 것이라고 생각했는데 0xd8씩 감소한다고 한다.
		- 아마 'cout << string literal'에서 string literal이 std::string type으로 type conversion을 하면서 function이 stack에 요구하는 공간이 많아진 것인가 싶다.
	- geometrically
	- arithmetically
- c++에서는 function overloading을 지원해서 같은 이름에 다른 type을 가지는 함수를 implement하여 사용할 수 있다.
	- 같은 이름에 같은 type을 가지는 함수도 overloading을 지원했으면 좋겠다.
	- 이 경우 입력값이 특정 상수인지를 통해 호출할 함수를 구분하면 된다.
	- 가령 입력값이 n이면 myFunction(input = n)을 호출하고 입력값이 m이면 myFunction(input = m)을 호출한다.
- git
	- 하루를 시작하며 commit하지 말고 하루 일이 끝나면 작업물을 commit을 하도록 하자
- find <path> -type d: directory type만 출력

2022-02-03
- process status
- disassemble --pc
- target stop-hook add
	disassemble --pc
	DONE
- thread step-inst
- thread step-inst-over
- thread step-in
- thread step-over
- thread stop-out
- thread continue
- thread until


2022-01-31
- C++ Primer Plus 5ed
	- 308p
	- 이중 배열을 인자로 전달하기
		- prototype: int sum(int (*array2d)[4], int size);
		- 동일한 의미: int sum(int array2d[][4], int size);
	- 309p
	- 각 함수들은 의도된 적절한 사용법이 있다.
	- 적절하지 않은 사용법으로 사용하는 경우의 문제에 대해서는 undefined behavior를 하도록 둘 수도 있고 guard로 막을 수도 있다.
	- 여기서 guard로 막는 선택은 의도된 입력에 한해서 사용하는 것이 좋은 것 같다.
	- 의도하지 않은 인자까지 gaurd하는 것은 불필요한 코드라고 생각한다.
	- int array2d[ROW][COLUMN]을 array2d[row]로 접근하면 *(array2d + row)와 같고, array2d의 데이터 타입은 'int [][]'로, dereferene 시 type은 'int []'이기 때문에 실제 array2d + row의 value를 주소로 하는 위치에 저장된 값을 반환하는 것이 아니라 array2d + row의 value를 반환한다.
	- 나는 이중 배열이 이중 포인터와 비슷할 거라고 알고 있었는데 이중 포인터가 아니라 배열의 주소값을 저장하는 포인터였다.
	- pointer가 담고 있는 주소값에 저장된 변수를 수정하지 못하게 하기 위해 'const Type*' type으로 인자를 받았었는데 이는 Type이 pointer type이 아닌 funcdamental type일 경우에 한한다.
		- 
- lldb command
	- me read $sp: sp가 가지고 있는 값을 주소로 하는 메모리의 데이터를 0x20 길이만큼 출력한다.
	- dis: assembly를 출력한다.
	- register: register에 들어있는 값을 읽고 쓸 수 있다.
	- memory: memory에 들어있는 값을 읽을 수 있다.
		- memory read -c <count> $sp: sp register에 들어있는 값을 주소로 하는 메모리로부터 <count> byte만큼을 출력한다.
	- help <command>: help command
	- disassemble -m -n <functionName>: function의 assembly를 source와 함께 출력한다.
	- sizeof(word) == sizeof(int)
	- sizeof(doubleword) == sizeof(int) * 2
	- sizeof(quadword) = sizeof(int) * 4

2022-01-30
- https://linuxize.com/post/how-get-size-of-file-directory-linux/
	- How to Get the Size of a Directory in Linux
- C++ Primer Plus 5ed
	- 295p
	- 어차피 function의 parameter를 상수처럼 사용할 거라면 const reference type으로 받는게 좋겠다!
	- 그리고 함수를 정의할 때 항상 value type 인자를 const reference type으로 받도록 하는 것은 어떨까?
	- 프로그램을 만들다보면 유기적으로 각 모듈이 연결되게 되는데, 마찬가지로 '함수'라는 개념의 assembly code도 고정된 규칙을 사용하는 것이 아니라 함수 안팎으로 필요한 부분은 최적화를 해주는 것이 좋지 않을까?
	- 297p
	- 'array + i'보다는 '&array[i]'를 사용하는 것이 더 보기 좋은 것 같다.
		- 그리고 array가 어떤 user-defined type의 배열이라면 정의한 subscript operator를 사용하기 때문에 primitive type과 user-defined type이 차이 없이 똑같이 작성할 수 있어서 좋을 것 같다.
	- 299p
	- c나 c++는 type에 const keyword를 사용하여 어떤 reference를 전달할 때, 해당 reference가 가리키는 값이 변하지 않는 함수라는 것을 보장할 수 있다.
	- 만약 const가 없었다면 암묵적인 약속으로 값을 update하지 않을 것임을 보장해야 했을 것이다.
	- 아니면 어떤 함수가 값을 update하는지 test하기 위해 추가적인 시간을 사용해야 했을 것이다.
	- const와 같은 기능을 입맛에 맞게 compiler 개발자가 추가하여 새로운 언어를 만들 수도 있을 것 같다.
	- const의 수정 범위?
		- 'const Type*' type이라고 해도 Type 안의 pointer가 가리키는 값은 수정이 가능하다!
		- 더불어 const type으로 전달받은 parameter도 const가 없는 type으로 explicit type conversion으로 값을 수정하는 것이 가능했다.
		- 즉, source에 const를 describe하는 것의 1차적 목적은 수정을 불가능하게 하는 것이 아니라, 수정을 하지 않을 것이라는 의도를 compiler에게 알림으로써 의도치 않은 수정이 수행되었을 때 error를 발생시켜 compile time에 debugging을 할 수 있게 하는 것이다.
	- 302p
	- Type을 먼저 정의하고 프로그램을 작성하는 bottom-up programming은 OOP와 잘 어울린다.
	- 304p
	- array의 정보를 함수에 전달하기 위해 array의 count를 사용한다면 'for (int index = 0; index < arrayCount; index += 1)'를 사용하고, array의 정보를 함수에 전달하기 위해 'int* start'와 'int* end'를 전달한다면 'for (int* element = start; element != end; element += 1)'를 사용하는 것이 좋다.
		- 이 때, end는 swift Array type의 endIndex와 마찬가지로 마지막 element의 다음을 의미한다.
	- 305p
	- const qualifier가 붙은 변수에는 const type이 아닌 값도 할당할 수 있다.
	- 306p
	- const가 붙었던 type인데 const가 없는 type을 할당할 수 있는 유일한 경우는 'const Type*' type의 변수에 'Type*' type을 할당하는 경우이다.
		- 'const Type**' type에 'Type**' type을 할당하는 것은 const로 의도한 data를 수정할 가능성이 존재하기 때문에 허용되지 않는다.
```
const int	constValue = 10;
int*		pointer;
const int**	constPPointer;

constPPointer = &pointer;		// 만약 이렇게 'const int**' type에 'int**'를 넣을 수 있다면
*constPPointer = &constValue;	// 'int' type의 주소값을 저장하는 pointer에 'const int' type의 주소값을 할당할 수 있는 문제가 생긴다.
*pointer = 42;
```

2022-01-29
- https://linuxize.com/post/how-get-size-of-file-directory-linux/
	- How to Get the Size of a Directory in Linux
	- du -sh <path>
- 원래 pdf 파일을 private repository에 넣어두고 밑줄을 그어가면서 읽다가 컴퓨터를 옮길 때 동기화를 시키는데, 확인해보니 이 기능은 용량을 너무 많이 차지하는 것 같다.
	- git이 바뀐 내용을 효율적으로 보관하지 못해 100MB가 넘는 공간을 차지하고 있었다.
	- 밑줄을 그은 pdf 파일 자체가 큰 용량을 차지하는 문제도 있었다.
	- 결국 pdf 파일에 밑줄을 추가한 파일을 동기화하지 않고 local에 보관하기로 했다.
- C++ Primer Plus 5ed
	- 282p
	- C++에는 함수의 반환값 type에 제한이 있다.
		- 한수 반환값 type으로 array type을 사용할 수 없다.
		- 다른 type은 다 가능하다.
		- 특이하게도 array 자체는 return type으로 사용할 수 없지만, array type을 member variable로 가지는 Type은 사용할 수 있다.
		- 일반적으로, 함수는 반환값을 CPU의 특정 register나 memory 공간에 복사하여 반환한다.
	- 284p
	- prototype, not possible in library
	- prototype이 없다면 compile time에 compile하는 모든 source code를 읽고 모든 함수들을 구체화하는 작업이 선행되어야 정의되지 않은 함수를 사용한 것인지 판단할 수 있을 것이다.
		- 하지만 library 함수의 경우 object 파일로 제공되기 때문에 함수의 구체적인 prototype을 알 수 없게 되어 error 메세지를 띄우거나 link를 진행할 수 없을 것이다.
	- 285p
	- c에서 function argument list를 empty로 두는 것은 아무 인자도 받지 않는 함수를 정의하는 것이 아니라 함수 인자 정의를 따로 하지 않는 것을 의미한다.
	- c++에서는 따로 인자 정의를 하지 않는 것을 의미하기 위해 '...'를 사용한다.
		- Type functionIdentifier(...);
		- 이런 표현은 printf()함수 같이 c언어와의 호환을 위해 필요하다.
	- 286p
	- 함수 호출 시 prototype과 인자 개수가 다를 경우 c의 경우 define된 함수를 실행시키지만 c++은 error로 처리한다.
	- 함수 호출 시 인자의 type이 prototype과 다를 경우 c는 define된 함수를 그냥 실행시키지만 c++은 implicit type conversion을 한다.
	- 더 작은 size로의 automatic type conversion의 시도는 compiler가 error를 일으킬 수 있다.
	- static type checking
	- passing by value(= call by value)
	- 287p
	- formal parameter(parameter): callee가 caller에게 값을 전달받아 복사해 저장하는 변수
	- actual argument(argument): callee가 caller에게 값을 전달할 때 복사의 대상이 되는 실제 변수
	- creating and destroying variables
	- local variable(= automatic variable)
	- function의 argument type을 결정할 때 해당 parameter가 음수값을 정의하지 않는 정수형이라면 unsigned type을 사용하면 좋다.
		- parameter의 initial value가 'greater than or equal to 0'를 보장할 수 있다.
	- 294p
	- c++에서 'Type*'와 'Type []'는 function header나 function prototype에서 사용했을 때에 한해 같은 의미를 갖는다.
		- 둘 다 'Type*'의 의미를 갖는다.
		- 하지만 'Type []'는 단순히 Type instance의 주소를 의미함과 더불어, 특히 어떤 array의 첫 번째 element의 주소값임을 시각적으로 표현한다.
	- 295p
	- typeArray[i]가 '*(typeArray + i)'와 같다는 것은 알고 있었는데 &typeArray[i]가 'typeArray + i'와 마찬가지로 compile될 수 있을 것이라는 것은 생각하지 못했다.

2022-01-28
- C++ Primer Plus 5ed
	- 277p
	- EnumType identifier = EnumType::enumerator;
		- 이런 식으로 작성은 불가능하다!
		- enumerator는 EnumType의 name scope 안에 있을 수 없다.
		- 따라서 enumerator의 identifier를 지어줄 때 'enumType_enumerator' 같은 형식으로 지어주도록 하자.
	- Type declaration에서 'static const' type을 initialize할 때, hpp 파일에서는 가능하지만 cpp 파일에서는 Type declaration 밖에서 해주어야 한다.
- parameter expansion
	- ${parameter%word}: 'word' pattern과 matching하는 가장 짧은 suffix를 delete
	- ${parameter%%word}: 'word' pattern과 matching하는 가장 긴 suffix를 delete
	- ${parameter#word}: 'word' pattern과 matching하는 가장 짧은 prefix를 delete
	- ${parameter##word}: 'word' pattern과 matching하는 가장 긴 prefix를 delete
- pattern matching
	- bash의 pattern rule은 glob이다.
- clang -c -g $path && objdump -l -S $baseName.o > $baseName.s && vim $baseName.s
	- c 파일로 보기 좋은 assembly code를 만들기 위해서는 object file을 생성하고 objdump로 assembly code를 생성하는 것이 좋다.
- indexing array with index or pointer
	- index를 사용하는 것과 pointer를 사용하는 것 사이에는 2 개의 작업에서 차이가 있다.
	1. 값 접근
		- index는 pointer에 비해 array의 시작점으로부터 값의 위치를 알아내야 하므로 instruction이 2 개 정도 더 필요하다.
	2. 대소 비교
		- index는 length와 간단한 정수 연산을 통해 빠르게 대소 비교가 가능하다.
		pointer는 array의 주소값과 차이를 계산하고 그 값을 pointer가 가리키는 type의 size로 나눠야 하기 때문에 index에 비해 3 개 정도의 instruction이 더 필요하다.
	- 따라서 대소 비교를 많이 해야 하는 경우 index가 유리하고 값에 접근을 많이 해야 하는 경우 pointer가 유리하다.
	- 대부분 대소 비교 보다는 값에 접근을 해야 하기 때문에 값 접근이 2 번 이상 필요하다면 pointer가 유리하다.
	- 하지만 대부분의 경우 가독성 측면에서는 index가 유리하다.
	- loop를 작성할 때 array의 각 element에 접근해야 한다면 test condition과 update expression의 가독성을 높이기 위해 index를 사용하는 것이 좋고, body statement에서 element의 값에 접근하기 위해 array의 subscription operator를 사용하는 것이 아니라, 'ElementType&' type의 element에 'array[index]'를 한 번 할당해놓고 이번 cycle 동안 사용하는 방법이 가장 좋아보인다.
```
for (int i; i < array.count; i +=1) {
	const Element	element = array[i];
	//	access element
}
```
	- 그러면 큰 성능 저하 없이 가독성을 챙길 수 있다.

2022-01-27
- ipad를 sidecar로 연결할 때 같은 wi-fi에 연결되어 있을 필요는 없다.
- C++ Primer Plus 5ed
	- 258p
	- if 안에서 break나 continue를 사용할 경우 else를 사용하지 않아도 된다.
		- 이 if statement의 test condition이 true인 경우 loop를 빠져나오거나 다음 loop를 진행할 것이고, false인 경우 if statement의 다음 statement가 실행될 것이기 때문에 else가 필요가 없다.
	- 261p
	- 함수는 기본기를 익혀두고 잔기술은 필요할 때마다 익히는 것이 좋은 것 같다.
	- 입력을 처리할 때는 기본적으로 'cin.get()'을 사용하고, 복잡한 작업을 쉽게 처리할 수 있는 경우 해당 함수를 사용하는 식으로 구현해 나가는 것이 좋은 것 같다.
	- 263p
	- consol I/O
	- file I/O
	- 264p
	- cin은 stdard input을 text file format이라고 가정하고 입력을 parsing한다.
	- 265p
	- cin: console input
	- cout: console output
	- 268p
	- std::ofstream의 default mode는 파일의 크기를 0으로 truncate한다고 한다.
	- 파일이 이미 존재하는데 open()을 시도할 경우 파일의 권한에 따라 실패할 수 있다.
	- 269p
	- std::ifstream이 default mode로 존재하지 않는 파일을 open()하려고 시도하면 실패할 수 있다.
	- 270p
	- cstdlib에는 exit()의 prototype과 EXIT_FAILURE의 define이 있다.
- https://stackoverflow.com/questions/146452/what-are-pod-types-in-c
	- What are POD types in C++?
	- POD(Plain Old Data)
	- POD is a user-defined Type.
	- POD has no user-defined destructor, no user-defined copy assignment operator, and no nonstatic members of pointer-to-member ype.
	- 272p
	- ifstream::open()을 호출할 때, 존재하지 않는 파일을 인자로 넣어주는 것 뿐만 아니라, 권한이 없어서 deny되면서 실패할 수도 있다.

2022-01-26
- stack segment를 큰 주소에서 작은 주소로 키워나가는 것의 장점 중 하나는, 어떤 변수가 할당된 공간을 넘은 공간에 값을 write할 때, 실행에 치명적인 공간이 corruption될 확률이 높아지기 때문에 corruption 시 crash를 유도하여 문제를 인식할 수 있다는 점이다.
- i_CTRL-G_[jk] in vim: [위, 아래] 줄의 입력을 시작한 column으로 jump
- i_CTRL-G_u in vim: undo element를 redefine하기 시작한다.
- i_CTRL-G_U [<LEFT><RIGHT>]in vim: undo element를 redefine하지 않고 [<LEFT>, <RIGHT>]를 한다.
- i_CTRL-O <command> in vim: command를 하나 실행하고 다시 insert mode로 돌아온다.
- i_CTRL-\_CTRL-O <command> in vim: i_CTRL-O와 같지만 eol에 있을 때 전 column으로 cursor를 옮기지는 않는다.
- v_b_[IAcC<>r] in vim: 각 줄의 range마다 해당 command를 적용한다.
- i_CTRL-V <number> in vim: 문자를 number로 입력할 수 있다.
- i_CTRL-R <register> in vim: register에 있는 데이터를 typing한다.
- i_CTRL-R_CTRL-R <register> in vim: register에 있는 데이터를 literally insert한다.
- i_CTRL-K <char1> <char2> in vim: digraph를 insert한다.
- C++ Primer Plus 5ed
	- 238p
	- ; , || &&는 모두 sequence point이다.
	- 241p
	- 입력받은 값이 valid한지 판단할 필요가 있는 경우 우선 임시 변수에 값을 입력받은 후 valid한 경우에만 실제 변수에 저장하는 방식이 멋있다.
	- 245p
	- 수를 입력받을 때 결국 저장할 데이터는 int type인데도 불구하고 double type으로 입력받는다.
	- 난 long type으로 입력받을 줄 알았는데, double type으로 입력받음으로써 long type이상으로 큰 수도 처리할 수 있게 된다.
	- INT_MAX와 INT_MIN은 <climits>에 정의되어 있다.
	- 처음부터 입력받을 때 입력값의 range를 명시하는 것이 아니라, user가 잘못된 입력을 했을 때 valid range를 출력하는 ui가 세련된 것 같다.
	- 247p
	- alternative representation은 keyword는 아니지만 reserved word이다.
	- C++에서는 특별한 header file을 include하지 않아도 alternative representation을 사용할 수 있지만,
	- C에서는 alternative representation을 사용하기 위해서는 iso646.h 파일을 include해야 한다.
	- <cctype>에는 isalpha(ch), ispunct(ch)등 data를 다양한 기준으로 분류한 값을 반환하는 함수들이 존재한다.
	- 248p
	- 어떤 statements를 함수화하는 것은 그 기능을 추상화하여 사용하는 것이다.
		- 마치 constant를 정의하면 한 constant를 추상화하여 사용하는 것이기 때문에, 그 constant하나를 수정하여 코드 전역에 영향을 미치는 것처럼, statements를 함수로 추상화시켜 사용하면 그 추상화된 함수 하나를 수정하는 것으로 코드 전역에 영향을 미칠 수 있다.
		- constant와 function의 가장 중요한 기능이 바로 이 추상화를 통해 코드 전역으로 영향 미칠 수 있다는 점인 것 같다.
	- 250p
	- conditional operator(?:)
	- 251p
	- switch statement의 case의 label은 integer constant expression이다.
	- case label에 문자 등 의미있는 expression을 작성하기 어렵다면 enumerator를 사용할 수도 있다.
	- 만약 integer-expression이 어떠한 label과도 match하지 않는다면 line labeled default로 jump하고, 만약 line labeled default가 없다면 switch statement가 끝나고 이어 나오는 statement로 jump한다.
	- 256p
	- 분기가 3개 이상이고 switch statement를 사용할 수 있는 상황이라면 일반적으로 if statement보다 switch statement를 사용한다.
- 구체적인 자료 수집 > 공통점을 추려내어 추상화 > 작동하는 프로그램 구현

2022-01-25
- C++ Primer Plus 5ed
	- 207p
	- C-style string과 달리 string class instance는 string의 끝에 '\0'이 없다.
		- 하긴 끝에 '\0'을 넣는 C-style string은 간단히 첫 문자의 주소를 주고 받음으로써 string 전체를 인식하기 위해 끝을 표시했지만 필요한 모든 data를 가지는 string class의 경우 끝을 표시하지 않아도 되는 것이다.
		- 만약 그럼에도 불구하고 끝에 '\0'을 넣고 싶다면 그 때는 string class가 독립된 단일 class로서의 최적화보다 C-style string과의 compatibility를 우선시 할 때일 것이다.
	- 208p
	- for statement의 test expression을 비우면 true로 evaluated된다.
	- 'for' statement와 'while' statement는 서로 전환이 가능하지만 'continue;' statement가 사용될 경우 좀 복잡해진다.
	- 일반적으로 loop count가 명확할 때는 'for' statement를, 그렇지 않을 때는 'while' statement를 사용하곤 한다.
	- 209p
	- clock() in <ctime>
	- 211p
	- #define vs typedef
		- #define TypeB	TypeA*
		- typedef TypeA*	TypeB
		- 위의 두가지 방식이 가능할텐데 'TypeB typeA, typeB;'라는 선언 시 define을 사용한 경우 'TypeA* typeA, typeB;'가 되어 typeA는 'TypeB*' type으로 선언되는 반면 typeB는 'TypeB' type으로 선언되는 문제가 있다.
		- 하지만 typedef로 TypeB를 alias한 경우 이런 문제가 없다.
		- compiler가 제공하는 기능이 존재하면 굳이 define을 사용하지 않고 compiler의 기능을 사용하는 것이 좋다.
		- 그래야 다양한 예외 상황에서 내 의도에 맞는 실행을 보장할 수 있다.
	- 212p
	- 'do while' statment는 exit-condition loop이다.
	- 214p
	- sentinel character: a character indicating when to stop
	- 217p
	- 만약 cin이 EOF signal을 받으면 eofbit와 failbit을 1로 set한다.
	- basic_istream::eof()는 eofbit를 return한다.
	- basic_istream::fail()은 eofbit | failbit를 return한다.
		- 엄밀히 말하면 basic_istream::fail()은 failbit를 return하지만, 대부분의 경우 eofbit가 set될 때 failbit도 set되는 것이다.
		- 참고: https://en.cppreference.com/w/cpp/io/ios_base/iostate
	- 218p
	- basic_istream::eof()와 basic_istream::fail()은 다음 호출 시 일어날 일을 반환하는 것이 아니라 바로 이전에 호출했을 때 발생한 일을 반환한다.
	- 220p
	- c에서 'int putchar(int)'는 argument로 int type을 받지만 c++에서 'ostream& std::ostream::put(char ch)'는 argument로 char type을 받는다.
	- https://jike.in/?qa=1136832/c-why-argument-type-of-putchar-fputc-and-putc-is-not-char
		- c - Why argument type of `putchar()`, `fputc()` and `putc()` is not `char`?
		- 이 글에 의하면 과거에는 argument로 char을 받을 때는 기본 정수 자료형인 int를 사용했었는데, putchar()은 그것이 남은 거라고 한다.
	- 상수 EOF는 iostream에 정의되어 있다.
	- 221p
	- EOF는 어떤 문자를 표현하지 않는다.
	- 대신 EOF는 더 이상 문자가 없다는 것을 의미하는 signal이다.
	- 즉 'int std::istream::get()'의 return value는 어떤 문자 또는 signal이다.
	- 'int std::istream::get()'이 반환하는 EOF는 int type의 음수이기 때문에 이를 char type에 담으려고 시도하면 unsigned char을 default로 하는 하드웨어에서는 저장된 값이 EOF와 달라질 수 있다.
	- (int)(unsigned char)EOF == 255 != EOF == -1
	- 따라서 반드시 int type 변수로 값을 저장하도록 해야한다.
	- 다만 이 경우 'std::ostream::put()'이 overloaded일 경우 argument를 int type으로 받는 prototype이 있을 수 있기 때문에 char type으로 explicit type conversion을 해주어야만 한다.
	- 222p
	- subexpression: 특히 expression 안에 포함된 expression을 지칭할 때
	- 반면 'istream& istream::get(char& ch)'는 argument로 받는 ch에 EOF를 저장하지 않기 때문에 ch에 저장될 수 있는 값은 온전히 어떤 문자 값이다.
	- 227p
	- string의 array를 만들 때,
		- 내용을 바꾸지 않을 것이라면 'char* []'으로 선언한다.
		- 내용들의 길이가 고만고만하고 살짝 바꾸고 싶다면 'char [][]'으로 선언한다.
		- 자유자재로 변경하기를 원한다면 'std::string []'으로 선언한다.
		- 바꾸지는 않을 생각이지만 std:: string의 이점을 이용하고 싶다면 'const std::string []'으로 선언한다.
- cppModule01
	- std::ifstream	ifs = std::ifstream(name, std::ifstream::in);
	- 위의 코드는 implicit copy constructor를 중심으로 하는 error를 발생시킨다.
	- /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/streambuf:492:64: error: base class 'std::__1::ios_base' has private copy constructor
	- 대충 private으로 선언된 copy constructor를 implicit하게 호출하려 시도하는 것에 대해 error를 출력하는 것이다.
	- 나는 원래 위와 같은 코드의 경우 copy constructor가 아니라 단순히 std::ifstream의 parameterized constructor 중 하나가 호출될 거라고 생각했다.
	- 일단 실제로는 parameterized constructor가 아닌 copy constructor를 호출하려 시도했기 때문에 왜 그런가 천천히 알아보기 위해 error가 출력하고 있는 파일의 해당 위치로 가보았다. 
```
488 #ifndef _LIBCPP_DO_NOT_ASSUME_STREAMS_EXPLICIT_INSTANTIATION_IN_DYLIB
489 _LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_streambuf<char>)
490 _LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_streambuf<wchar_t>)
491 
492 _LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ios<char>)
493 _LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ios<wchar_t>)
494 #endif
```
	- 뭔지는 몰라도 EXTERN이라는 글자가 눈에 보인다.
	- 그리고 이 코드가 추가되는 조건을 ifndef가 친절하게 설명해주고 있다.
	- 'dylib에서 stream이 instantiation을 explicit하게 가정하지 말것'이 정의되어 있지 않을 경우에 해당 라인을 추가한다.
	- 즉, explicit이라 가정하도록 하는 것이 해당 라인의 역할이라는 얘기다.
	- 그런데 내가 작성한 코드는 implicit하니 error로 인식한 것이다.
	- 그럼 initialization으로 instance를 초기화하는 것을 불가능하도록 강제하는 explicit instantiation이 무엇인지 알아보자.
	- https://leimao.github.io/blog/CPP-Explicit-Constructor/
		- C++ Explicit Constructor
	- https://en.cppreference.com/w/cpp/language/explicit
		- explicit specifier

2022-01-24
- C++ Primer Plus 5ed
	- 141p
	- The symbolic constants defined in enumeration are called enumerators.
	- instance of enumeration은 enumerator defined in the enumeration만 할당할 수 있다.
	- band = red + orange;
		- red + orange는 각각 int로 type conversion되어 더해지고, 결과값의 type인 int는 spectrum type이 아니기 때문에 band에 할당될 수 없다.
	- spectrum(int)로 explicit type cast가 가능하다.
	- 하지만 enumerator의 범위 밖의 값을 인자로 주었을 경우 결과는 undefined이다.
	- 서로 다른 두 enumerator가 같은 값을 갖도록 할 수도 있다.
	- type cast가 가능한 범위는 최소값과 최대값을 포함하는 가장 작은 m과 n이다. -2^m + 1 ~ 0 or 0 ~ 2^n -1이다.
	- 145p
	- dereferencing operator(*)(= indirect value operator)
	- 148p
	- int* p1, p2;는 p1을 pointer type으로, p2를 value type으로 declare한다.
	- 150p
	- new operator(new)
	- 152p
	- new operator가 메모리 할당에 실패하면 null을 반환하기 때문에 반환값을 보고 메모리 할당이 성공했는지 실패했는지 확인할 수 있다.
	- 또한 new operator가 메모리 할당에 실패하는 경우 bad_alloc exception을 throw하기 때문에 try catch로 예외처리를 해줄 수도 있다.
	- 153p
	- null pointer를 delete해도 안전하다.
	- static binding: compile time에 array를 메모리 할당하는 것
	- dynamic binding: run time에 array를 메모리 할당하는 것
		- 이렇게 메모리 할당된 array를 dynamic array라고 한다.
	- 154p
	- new로 메모리 할당한 object를 delete []로 free하는 것과 new []로 메모리 할당한 object를 delete로 free하는 것은 undefined이다.
	- 156p
	- pointer arithmetic
	- 159p
	- array[i]는 *(array + i)로 변환된다.
	- 165p
	- cout은 char* type을 문자열 표현으로 출력하기 때문에 주소값을 출력하기 위해서는 다른 type의 포인터 type으로 type cast하여 출력해야 한다.
	- member access operator, member operator
		- dot membership operator(.)(== dot operator)
		- arrow membership operator(->)(== arrow operator, arrow member operator, pointer dereferencing operator)
	- 178p
	- for (loop initialization; loop test; loop update) { loop body }
	- for (initialization expression; test expression; update expression) { statement list }
	- increment operator(++)
	- decrement operator(--)
	- 180p
	- entry-condition loop: loop which evaluates the test expression before each loop cycle
	- 181p
	- for statement는 마치 함수처럼 생겼는데 대게 C++에서는 함수의 경우 함수 이름과 괄호 사이에 space를 두지 않지만 함수가 아닌 경우 keyword와 괄호 사이에 space를 하나 둔다.
	- expression은 결과값을 갖는다.
	- 183p
	- assignment operator는 expression으로서 lhs를 결과값으로 하고, side effect로 lhs에 rhs 값을 할당한다.
	- age = 100은 expression이고, age = 100;은 statement이다.
	- 184p
	- 하지만 반대로 statement의 ';'를 뗀다고 해서 expression이 되는 것은 아니다.
	- for statement의 경우에는 아예 ';'이 없는 statement이다.
	- int toad;는 statement이지만 int toad는 expression이 아니다.
	- for statement의 initialization expression에서 initialization statement를 사용할 수 있게 되면서 for (for-init-statement condition; dexpression) statement list로 syntax가 수정되었다.
	- 190p
	- sequence point: side effect의 영향 범위를 구분하는 지점
		- C++에서는 ';'이다.
		- full expression의 끝도 sequence point이다.
			- full expression의 예> expression statement의 expression이나 while loop의 test condition에 해당하는 expression 등
		- while (guests++ < 10) printf("%d \n", guests);의 경우 increment operator가 condition에 있는데, condition은 full expression이기 때문에 condition 끝이 sequence point이다. 따라서 condition의 side effect가 printf();를 실행하기 전에 적용되는 것이 보장된다.
		- y = (4 + x++) + (6 + x++);의 경우 왼쪽의 괄호 (4 + x++)은 full expression이 아니기 때문에 해당 subexpression이 evaluated 후 side effect가 적용되는 것이 보장되지 않는다.
	- 191p
	- user-defined operator++()은 prefix operator이며, postfix 버전은 기존 값을 임시 공간에 저장하고 operator++를 적용하고 임시 공간에 저장한 기존 값을 반환한다.
	- 193p
	- combined assignment operator
	- block: C++에서는 따로 block이라는 개념을 사용한다.
	- 197p
	- comma operator(,) is a sequence point
	- 201p
	- strcmp()는 alphabetically compare하기보다는 엄밀하게는 in the system collating sequence compare한다.
- <count><C-[AX]> in vim visual mode: range 안의 숫자들을 count만큼 더하거나 뺌
- <count>g<C-[AX]> in vim visual mode: range 안의 숫자들을 차례대로 count의 n배만큼 더하거나 뺌
- gv in vim normal mode: 이전 visual range로 visual mode 시작하기
- gn in vim normal mode: 다음 search pattern match를 range로 visual mode 시작하기
- [ai][w(b){B}[]<>t"'`]: 포함, 안을 의미

2022-01-23
- C++ Primer Plus 5th edition
	- 75p
		- unsigned types의 overflow는 보장이 되지만 signed types의 overflow는 implementation defined이다.
	- 79p
	- decimal int의 literal constant는 int, long, unsigned long 순서로 matching되고, hexadicimal과 oxtal의 literal constant는 int, unsigied int, long, unsigned long 순서로 matching된다.
	- 81p
	- membership operator(.)
	- 86p
	- char의 기본형은 하드웨어에 따라 signed일 수도, unsigned일 수도 있다.
	- 90p
	- exponent: 지수부
	- mantissa: 가수부
	- 91p
	- sigmificant figures: 유효 숫자
	- 95p
	- arithmetic types
		- integer types
			- bool, char, wchar_t, signed integer, unsigned integer
			- signed integer types
				- signed char, short, int, long
			- unsigned integer types
				- unsigned char, unsigned short, unsigned int, unsigned long
		- floating-point types
			- float, double, long double
	- arithmetic operator
		- addition opeerator(+)
		- subtraction operator(-)
		- multiplication operator(*)
		- division operator(/)
		- modulus operator(%)
			- 두 operands 중 하나가 음수일 때 결과값의 sign은 implementation defined이다.
			- 가능하면 양수만 사용하자.
	- 97p
	- associativity
		- left-to-right associativity
		- right-to-left associativity
	- int dues = 20 * 5 + 24 * 6;
		- 에서 associativity가 왼쪽 곱연산을 먼저 하라는 것을 의미하지는 않는다.
		- 이 경우 implementation defined이다.
	- 99p
	- operator overloading
	- 102p
	- int 범위를 넘는 부동 소수점 상수를 int에 할당하는 것은 implementation defined이다.
	- 110p
	- compound type(= derived type): 다른 type을 사용하여 만든 type
	- 113p
	- array를 initialize하지 않으면 element value는 undefined이다.
	- array에서 {}를 사용하여 값을 할당하는 것은 오직 initialization 시에만 가능하다.
	- 한 array의 내용을 다른 array로 할당하는 것도 불가능하다.
	- 전체 array의 개수보다 적은 양으로 initialize하면 남은 element는 0으로 initialize된다.
	- array initialization에서 [] 안을 비워두면 알아서 element의 개수만큼 메모리를 할당한다.
	- 115p
	- char boss[8] = "Bozo";
		- bozo\0\0\0\0가 할당된다.
		- 아마 배열을 초기화할 때는 모든 element를 할당해야만 하는 모양이다.
	- 123p
	- function overloading
	- basic_istream::getline(char_type* s, std::streamsize count)은 '\n'를 extract하기 때문에, 버퍼가 꽉 채워졌을 경우 인자로 준 count만큼이 다 차서 extract가 멈춘 것인지 아니면 '\n'를 만나서 입력이 멈춘 것인지 알 수 없다.
	- 반면 basic_istream::get(char_type* s, std::streamsize count)는 delimiter를 extract하지 않기 때문에 다음 character를 보고 왜 멈춘 것인지 알 수 있다.
	- 131p
	- istream class는 string class가 추가되기 전에 C++에 포함됬다. 그래서 istream은 primitive type에 대해 작동하도록 design되었고, 따라서 string type은 제외되었다. 그래서 basic_istream::getline()의 인자는 primitive type만 인자로 받고, string type을 위한 static std::getline 함수는 friend specifier를 사용하여 cin으로부터 input을 받도록 작성되었다.
	- 133p
	- struct Type { char name[20]; double price; };
		- Type instance = {"Gloria", 4.2};
		- structure를 이런식으로 {}를 사용하여 initialization하는 것이 가능하다.
	- 136p
	- assignment operator는 기본적으로 shallow copy를 한다.
		- 또한 이를 memberwise assignment라고 한다.
	- 137p
	- struct Type {int a, int b} instance = {4, 2};
		- 이런식으로 struct definition과 동시에 해당 struct의 instance initialization을 할 수도 있다.
	- struct {int a, int b} instance;
		- 이런식으로 Type을 이름 없이 정의할 수도 있다.
		- 하나의 instance만을 생성하는 경우 이름에 prefix를 부여하는 용도로 사용할 수 있을 것 같다. 그런데 그러면 namespace가 더 좋지 않을까?
	- 139p
	- bit fields in structures
		- 이런 것은 처음 본다.
		- C에도 이런 것이 있던가?
	- 141p
	- anonymous union
		- union {int a, int* b);
		- a = 42; b = &a;
		- union의 instance이름을 생략하고 사용할 수 있다.
		- 이런 사용법이 가능하다니 C에서도 가능한건가? 미쳤다.

2022-01-22
- https://zhjwpku.com/assets/pdf/books/C++.Primer.Plus.6th.Edition.Oct.2011.pdf
	- 1103p
		- cout >> ch는 spaces를 건너뛰기 때문에 space까지 읽어 처리하기 위해서는 cout.get() 등을 이용해야 한다.
		- get(char& ch)가 아닌 get(void)를 사용한다면 c로 porting할 때 이점이 있다.
		- 반대로 c를 c++로 porting할 때 getchar를 get(void)로 바꾸어 쉽게 할 수 있다.
	- 1108p
		- getline()은 termination charaacter를 discard하고 get()은 termination character를 discard하지 않는다.
- C++ Primer Plus 5th edition
	- 13p
		- procedural language
		- structured programming
		- base name for file, period, file name extention
	- 44p
		- BASIC 같은 언어에서는 선언이 따로 없이 새로운 identifier를 사용할 수 있기 때문에 오타로 인해 다른 identifier를 사용하는 경우를 debugging하기 어렵다.
		- declaration이 따로 존재하는 것은 이런 문제를 방지한다.
	- 72p
		- initialization: 선언과 동시에 값을 할당
		- 함수 안에서 변수를 초기화하지 않으면 그 변수의 값은 undefined이다.
	- ~ 78p
- 반환값만 다른 함수는 overloading되지 않는다.
- cppreference.com이 설명이 더 구체적이고 좋다.

2022-01-21
- c++03부터는 value initialization이 생겼지만 c++98에서는 empty initializer의 경우 zero initialization이 되었던 모양이다.

2022-01-20
- constructor에서 member variable에게 assign operator를 사용하면 member variable의 constructor가 두 번 호출될까?
	- default constructor도 호출되고 추가적인 constructor도 호출되고 copy assignment opertor도 호출되고 destructor도 호출된다.
	- : property(10)을 사용하면 parameterized constructor 하나만 호출된다.
- Property의 default constructor가 없는데 Type이 Property를 member variable로 가지고 constructor에서 명시적으로 initialization을 하지 않으면 어떻게 될까?
	- error: constructor for 'Type' must explicitly initialize the member 'property' which does not have a default constructor
- lvalue, rvalue, temporary
	- lvalue는 read/write가 가능
	- rvalue는 read가 가능
	- temporary는 read만 가능
- https://effort4137.tistory.com/entry/Lvalue-Rvalue
	- Lvalue Rvalue
- c++에서는 초기화에 사용되지 않는 생성자는 소멸자를 호출한다.
- https://www.learncpp.com/cpp-tutorial/introduction-to-iostream-cout-cin-and-endl/
	- 1.5 — Introduction to iostream: cout, cin, and endl
	- insertion operator(<<)
	- extraction operator(>>)
- new keyword는 heap영역에 메모리 공간을 할당할 뿐만 아니라 default constructor도 호출한다.
- class basic_filebuf: public basic_streambuf {};
- typedef basic_filebuf<char> filebuf;

2022-01-19
- buffer in vim
	- 주기: load -> unload -> delete -> wipeout
	- load는 buffer가 memory에 할당된 상태이다.
		- active나 hidden 상태이다.
	- unload는 buffer를 위해 할당한 memory를 free한다.
		- buffer list에는 보인다.
	- delete는 unload를 하고 buffer list에서 제거한다.
		- unlisted 상태가 된다.
		- :buffers!로 이렇게 unlist된 buffer도 볼 수 있다.
		- file name과 mark를 기억하기 위해 남는다.
	- wipeout은 delete를 하고 buffer에 대한 모든 것을 지운다.
		- mark와 option 설정도 사라진다.
- 여러 파일을 동시에 수정하는 명령으로 :argdo 외에 :bufdo, :tabdo, :windo 등도 있다.
- ciw in normal mode: 커서가 위치한 단어를 삭제 후 insert mode
- ci" in normal mode: 커서가 위치한 ""로 둘러쌓인 내용 삭제 후 insert mode
- http://www.lirmm.fr/%7Educour/Doc-objets/ISO+IEC+14882-1998.pdf
	- Programming languages - C++
	- 2.5 Alternative tokens
		- %:(#)
		- and(&&)
		- or(||)
		- not(!)
		- 이걸 활용해서 더 가독성이 좋은 코드를 작성할 수 있을 것 같다.
- The C++ Programming Language 3rd Ed
	- data abstraction
	- data hiding
	- overloading resolution
	- abstract class
	- multiple inheritance
- http://www.softwarepreservation.org/projects/c_plus_plus/cfront/release_e/doc/ReferenceManual.pdf
	- The C++ Programming Language - Reference Manual
- ambiguous error가 발생하는 경우
	- Type A에서 Type B로의 conversion operator를 정의하였는데, Type B에서 Type A를 인자로 받는 constructor를 정의하였을 때
	- 어떤 overloaded function을 호출할 때, 인자가 여러 Type으로 implicit type conversion이 가능해서 한 함수를 특정하지 못할 때
	- default constructor를 정의하였는데, 모든 인자가 default value를 가지는 parameterized constructor를 정의하였을 때
- https://stackoverflow.com/questions/1568091/why-use-getters-and-setters-accessors
	- Why use getters and setters/accessors?
	- getter와 setter를 사용하면, 나중에 derived class에서 해당 property에 대한 read/write 시에 특별한 작업을 추가하기 쉽다.
	- 언제나 해당 property에 대한 추가 작업이 필요할 때 getter와 setter를 수정하는 것으로 간단히 추가할 수 있다.

2022-01-18
- https://www.learncpp.com/cpp-tutorial/variable-assignment-and-initialization/
	- 1.4 — Variable assignment and initialization
	- declaration과 동시에 assignment를 하면 initialization이라고 한다.
	- default initialization: 초기값이 없는 initialization
		- 대게 결정되지 않은 값이 들어간다.
		- int a;
	- copy initialization: primitive type의 경우 효율적이나 복잡한 Type에서는 비효율적일 수 있다.
		- int a = 5;
	- direct initialization: identifier 바로 뒤의 괄호 안의 값으로 초기화
		- int a(5);
	- brace initialization: 중괄호를 사용하여 여러 값을 한 번에 array 등을 초기화
		- int a[2] { 5, 6 };	// direct brace initialization
		- int a[2] = { 5, 6 };	// copy brace initialization
		- int a {};				// value initialization
		- == uniform initialization == list initialization
		- data loss가 없는 경우에만 conversion이 일어난다고 한다.
			- int a { 4.5 };	// error: not all double values fit into an int
	- value initialization: 선언 시 identifier 뒤에 빈 중괄호를 붙이면 value initialization이 일어난다.
		- 대게 0으로 값을 초기화한다.
		- Type에 따라 다른 값으로 초기화될 수도 있다고 한다.
		- 0으로 초기화되는 경우 zero initialization이라고 한다.
	- zero initialization:
		- int a {};
	- insertion operation(<<)

2022-01-17
- https://www.learncpp.com/cpp-tutorial/comments/
	- 1.2 — Comments
	- 저번에 그래픽 과제를 하면서 특정 함수는 복잡한 수식으로 이루어져 있어서 도대체 각 연산이 왜 필요한지 알기 어려웠었다.
	- 그런 함수의 경우 복잡한 수식의 이유를 수식을 보면서 파악하는 것이 아니라 주석으로 설명을 했다면 좋았을 것 같다.
	- 그리고 두 가지 선택지 중에 하나를 선택했다면 왜 그것을 선택했는지도 주석으로 남겨놓으면 좋다.
	- "왜 저렇게 하지 않고 이렇게 한거지?"라는 의문이 들 때 그 선택을 한 이유를 쉽게 이해할 수 있다.
	- 관점에 따른 주석 내용
		- 함수 밖에서 주석을 달 때는 사용자를 위한 주석을 담는다.
		- 함수 내에서 주석을 달 때는 제작자를 위한 주석를 담는다.
	- assignment operator 중에 lhs와 rhs의 Type이 같으면 copy assignment operator라고 한다.
	- 선언과 동시에 값을 할당하는 것을 initialization이라고 한다.
- https://en.cppreference.com/w/cpp/language/initialization
	- Initialization
	- value initialization
	- direct initialization: 선언의 identifier에 바로 괄호를 붙여 새로운 instance를 생성하는 initializer
		- int a(5);
	- copy initialization
	- list initialization
	- aggregate initialization: array나 class등을 초기화할 때 사용할 수 있는 initializer
		- T object = { arg1, arg2, ... };
	- reference initialization
	- default initialization
	- zero initialization
- https://en.cppreference.com/w/cpp/language/lookup
	- name lookup
	- unqualified name lookup
	- qualified name lookup
		- scope resolution operator(::)
		- identifier가 scope resoultion operator 뒤에 오는 경우 qualified name이라고 한다.
	- argument-dependent lookup

2022-01-16
- 협업 시 remote repository와 자주 동기화를 해주는 것이 좋다.
	1. 내가 처리해야 할 conflict가 작아져서 해결 난이도가 낮아진다.
	2. 내가 적용한 변경사항에 대해 협업자가 해결해야 할 conflict가 작아져서 해결 난이도가 낮아진다.
- prettier같은 자동으로 소스의 작성 형식을 동일하게 수정해주는 프로그램을 사용하여 코드 리뷰 때 시간을 절약할 수 있다.
- https://www.learncpp.com
	- binary digit을 줄여 bit이다.
- https://etherealmind.com/network-dictionary-magic-hand-wave/
	- Network Dictionary – magic hand wave
	- Refers to those times when a colleague says “let me fix that” and proceeds to issue a string of commands on the keyboard (thus waving hands about) and then says “there you go”.
	- 어떤 문제를 해결하기 위해 프로그래머가 타다닥 작업하고 짠 보여주는 것을, 마법사가 마법을 사용하기 위해 어떤 동작을 하고나서 발휘되는 것에 비유한 말인 것 같다.
	- magic hand wave는 그렇게 마법사(현상을 이해하는 사람)가 어떤 마법(관측자가 이해하지 못하는 현상)을 시전하기 위해 하는 손놀림 등을 이르는 말이다.

2022-01-15
- https://www.learncpp.com/cpp-tutorial/variable-assignment-and-initialization/
	- 1.4 — Variable assignment and initialization
	- initialization: 변수를 선언하고 초기값을 설정하는 과정을 말한다
	- default initialization: When no initialization value is provided, this is called default initialization.
		- In most cases, default initialization leaves a variable with an indeterminated value.
	- copy initialization
		- copy constructor와 유사하게 생각하면 된다.

2022-01-14
- const type
- https://www.youtube.com/watch?v=mx2HFzRvQg0
	- title
	- Class의 constructor를 호출하여 새로운 instance를 얻어냈을 때, c++은 Object Oriented Programming language이기 때문에 이 instance는 object이다.
	- instance의 사전적 한글 단어는 실례, 예, 예증이다.
		- 내 iPhone은 iPhone이라고 애플이 정의한 iPhone Class의 한 예(instance)이며 동시에 실제 하나의 iPhone(object)이다.
		- 내 다른 iphone도 iPhone의 한 예(instance)이며 동시에 실존하는 하나의 iPhone이다.
	- 나라는 존재는 하나의 object로 존재하지만 보는 관점에 따라 사람의 한 instance일 수도 있고, 남자의 instance일 수도 있고 한국인의 instance일 수도 있다.
	- swift에서는 Type이라는 관점에서 새로운 object를 생성하기 때문에 instance라고 부르는 모양이다.
		- 만약 Shape Type의 자식 Type인 Circle이 있다고 하자.
			- 이 때 Circle Type object를 하나 만든다면 이는 Circle의 instance이며 동시에 Shape의 instance이다.
			- object를 생성했다고 하면, 
			- 즉, instance라는 단어를 사용하는 이유는 단순히 Circle이라는 Type으로 하나의 object를 생성했다는 의미 전달을 넘어서 이 object가 다른 어떤 Type의 instance일 수도 있지만 특히 Circle의 instance임을 강조하고 싶어서 사용한 것 같다.
- https://en.wikipedia.org/wiki/Instance_(computer_science)
	- Instance (computer science)
	- instance를 생성을 instantiation이라고 한다.
	- concrete class가 아닌 abstract class는 instantiated될 수 없다.
- https://stackoverflow.com/questions/779091/what-does-object-reference-not-set-to-an-instance-of-an-object-mean
	- What does "Object reference not set to an instance of an object" mean?
	- 어떤 object가 아직 instantiated되지 않았다면 이 object는 해당 Type의 instance가 아니다.
		- 하지만 그럼에도 불구하고 object이기는 하고 type도 Type이겠지만 Type의 instance는 아니다.
		- 그래서 모든 instance는 object이지만 모든 object가 instance인 것은 아니라고 생각한다.
		- object > instance
- https://www.fluentcpp.com/2019/04/19/compiler-generated-functions-rule-of-three-and-rule-of-five/
	- Compiler-generated Functions, Rule of Three and Rule of Five
	- default constructor: Type(void)
	- copy constructor: Type(const Type& type)
	- copy assignment operator: Type& operator=(const Type& rhs)
	- destructor: ~Type(void)
	- If the class contains a const or address property, the compiler won't be able to come up with an copy assignment operator.
- assignment operator: Type1& operator=(const Type2& rhs)
- compiler가 필요에 따라 자동으로 생성해주는 default method의 내부 구현은 딱 필요에 맞게 생성한다.
	- default constructor: super class의 default constructor와 property의 default constructor를 호출한다.

2022-01-12
- C++에서 정의한 class의 instance를 heap에 할당하기 위해 malloc() 등 c에서 사용하던 메모리 할당 함수를 호출하면 당연하게도 constructor가 호출되지 않는다.
- 마찬가지로 free()를 호출할 때도 destructor를 호출하지 않는다.
- overload: 같은 identifier를 갖지만 인자가 다른, 실질적으로는 완전히 구분된 독립적인 새로운 함수를 정의할 때 overload한다고 한다.
- https://www.geeksforgeeks.org/when-does-compiler-create-default-and-copy-constructors-in-cpp/
	- When Does Compiler Create Default and Copy Constructors in C++?
	- constructor
		- species
			- default constructor
			- copy constructor
			- parameterized constructor
		- If no user-defined constructor is defined, the compiler creates a default constructor.
			- Auto created default constructor's body is empty.
		- If no user-defined constructor is defined, the compiler creates a copy constructor.
			- Auto created copy constructor's body is not empty.
			- It copies all instance variables.
- https://www.interviewsansar.com/default-member-functions-for-a-class-in-c/
	- What default functions provided by compiler in C++?
	- default instance methods
		- default constructor
		- copy constructor
		- assignment operator
		- destructor
- error
	- content
		- error: no viable overloaded '='
		- zombies[i] = Zombie(name);
		- note: candidate function (the implicit copy assignment operator) not viable: 'this' argument has type 'const Zombie', but method is not marked const
	- 'no viable overloaded '=''라는 문구는 overloading된 instance method 'operator=' 중에 argument Type들이 matching되는 method가 존재하지 않는다는 뜻이다.
	- 나는 zombies를 선언할 때 const qualifier를 붙였는데, 따라서 'zombies[i] = Zombie(name)'은 'Zombie& Zombie::operator=(const Zombie& zombie) const'를 찾으려 시도할 것이다.
	- 하지만 나는 따로 assign operator를 define하지 않았기 때문에 compiler가 자동으로 생성한 'Zombie& Zombie::operator=(const Zombie& zombie)'만 존재할 것이다.
	- 따라서 원하는 method는 'this' argument가 'const Zombie'인데 존재하는 비슷한 함수는[1] const가 mark되어 있지 않다는 메세지가 출력된 것 같다.
		- 그런데 왜 'this'를 'const Zombie' type으로 출력하는 것일까? 'const Zombie&' type이어야 하지 않을까?
[1] argument type이 일치하는 함수를 찾지 못하면 const만 다른 함수를 찾아보고 이 때 발견하면 const가 빠졌다는 메세지를 출력하는 것 같다.

2022-01-11
- namespace의 identifier로 keyword를 사용할 수 없다. 
- global에 선언된 type은 '::'로 global type에 접근 가능하기 때문에 namespace 내부에서 같은 identifier를 사용하여 namespace를 정의할 수 있다.
- namespace에서 constant를 선언하려면 extern으로, class에서 type constant를 선언하려면 static const로 선언한다.
- cpp_module을 진행하다가 문득 commit message를 확인해보니 의미없는 'backup'이라는 메세지만 잔뜩 찍혀있었다.
	- 이런식으로 의미 없는 backup만 반복되는 이유는 별다른 계획을 세우지 않고 흘러가는데로 공부하며 프로젝트를 진행했기 때문이다.
	- 하지만 공부를 할 때는 그럴 수도 있다고 생각한다.
	- 공부도 실전처럼 하면 가장 좋겠지만, 그래서는 공부 이외의 일로 인해 집중력도 떨어지고 효율도 떨어진다.
	- 공부할 때는 공부에 전념하고, 프로젝트 관리가 필요한 경우에는 프로젝트 관리를 철저히 하는 식으로 진행해보자.
- &(const std::string)this->_firstName);
	- error: taking the address of a temporary object of type 'const std::string' [-Waddress-of-temporary]
	- identifier가 없는 temporary object는 non-lvalue이며, 주소 연산자를 사용해 주소를 알아낼 수 없다.
	- 이 경우 형변환을 통해 identifier를 가지지 않는 temporary object가 생겨난다.
	- 따라서 C++에는 'Type' 을 'const Type'으로 형변환하고 바로 주소를 알아내어 'Type *const' 개념의 type을 갖는 값을 얻는 것은 불가능하다.
	- reference를 사용하는 방법
		- 수정이 불가능한 object type의 주소를 전달하기 위해서는 reference type을 사용할 수 있다.
		- 입력받는 입장에서 'const Type &'을 인자로 받으면 수정 불가능한 object의 주소를 전달할 수 있다.
		- reference type은 기본적인 방법으로 'Type &' 사용하기만 해도 'const Type *' 개념이 적용되어 있어 identifier에 처음 init한 주소값을 바꿀 수 없는 성질을 가지고 있다.
		- 이 때 Type의 앞이나 뒤에 const를 명시해주면 'const Type &' type 의 변수가 담고 있는 주소값이 가리키고 있는 object를 수정하는 것이 불가능하다.
		- 'const Type *' 개념의 type이 'const Type *const' 개념의 type이 되는 것이다.
		- 동시에 'const Type &' type을 인자로 가지는 함수는 사용자에게 있어 해당 인자에 담겨 있는 주소가 가리키는 대상을 수정하지 않는다는 정보를 얻을 수 있다.
		- reference를 통해 'const Type *'를 전달하거나 이를 'const Type *const'로 형변환 하는 개념을 reference를 통해 가능하도록 만들어져 있다.
	- 주소값을 형변화하는 방법
		- 'Object *const' type을 입력받는 함수에 어떤 'Object' type의 주소를 알아낸 후 형변환해주는 방법이 있다.
		- '(Object *const)&instance'처럼 'Object *' type인 '&instance'를 'Object *const' type으로 명시적 형변환을 해주면 된다.
- namespace 안에서 static global variable이나 global variable을 선언함과 동시에 값을 초기화할 수 있지만, 여러 파일에 include시키게 되면 여러번 실행되는 문제가 있다.
	- 이를 막기 위해 static const int 등을 선언과 동시에 초기화하고 싶다면 namespace가 아니라 struct나 class를 사용해야 한다.
- 이 내용은 나의 착오이다.
	- 'std::string'의 default constructor를 호출해서 default instance를 만들고 'push_back()', '+', '+=' 등을 사용해서 문자를 추가해보려 했지만 전부 실패했다.
		- 'std::string::at()'의 반환값을 'push_back()'의 인자로 넣었을 때 의도대로 작동하지 않는 문제가 있었다.
		- 예상한 함수가 아닌 다른 함수가 실행되고 있었던 것이다.
		- 다시 말해, 'std::string::push_back(ch)'와 'std::string::push_back(ch &)'는 완전히 다른 작동을 한다.
	- 반복문에 초기에 'std::string::clear()'를 호출하고 있어서 값이 제대로 축적되지 않았던 것이었다!
	- 게다가 인자로 포인터 타입을 받고 있었는데 가끔은 주소값에 연산을 해서 segmentation fault도 발생했다!
- C++의 핵심은 어떤 함수가 호출되었는지를 집요하고 정확하게 파악하는 것이다.
	- swift는 argument label과 parameter label이라는 개념을 통해 모든 사용 가능한 함수들을 다르게 표기하는 훌륭한 방법을 사용했지만, 반면 C++는 정확히 똑같은 이름을 가진 함수 일지라도 들어가는 인자의 type에 따라 완전 다른 함수가 실행될 수 있다.
- 'echo > .temp; hexdump .temp'를 하니 0x0a가 나왔다.
	- 'man ascii'로 0x0a를 찾아보면 new line을 의미하는 nl이 적혀있다.
	- 내 cli에서 new line character를 줄바꿈으로 사용하는 것이다.
	- vim에서는 0x0a를 의미하는 '<C-V><C-J>'를 누르면 0x00을 의미하는 ^@이 입력되고, 0x0d를 의미하는 '<C-V><C-M>'를 누르면 정상적으로 0x0d를 의미하는 ^M이 입력된다.
	- 0x0a는 줄바꿈으로 이미 사용되고 있기 때문에 '<C-V><C-J>'를 누르면 대신 ^@를 입력하는 모양이다.
- '<C-K> {char1} {char2}' *digraphs-use*: 다양한 문자를 입력할 수 있다!? はê
- zsh은 내가 만든 line입력받는 프로그램과 달리 '^J'를 입력해도 두 개의 명령이 입력된 것이 아니라 하나의 명령이 입력된 것으로 처리한다.
	- 나는 'std::string::getline()'을 호출하여 new line을 기준으로 하나의 입력을 받는 것으로 처리했지만 zsh은 특정 signal 등이 들어오는 것을 기준으로 들어온 모든 데이터를 하나의 입력으로 처리하는 모양이다.
- constructor는 initializer이다.
- destructor는 deinitializer이다.
- initializer는 처음에 한 번만 호출된다는 점에서 언제든 호출 가능한 assign operator와 구분된다.
- const type의 object는 initializer를 통해 초기화가 가능하지만 assign operator를 호출할 수는 없다.

2022-01-10
- https://www.quora.com/What-is-the-difference-between-a-protocol-and-an-interface-An-interface-is-like-a-wall-plug-you-need-to-adapt-to-in-order-to-use-it-a-protocol-seems-to-be-the-same-but-using-the-word-rules-or-isnt
	- What is the difference between a protocol and an interface? An interface is like a wall plug you need to adapt to in order to use it, a protocol seems to be the same but using the word rules, or isn't?
	- network 관점에서, interface는 hardware를 의미하고 protocol은 software를 의미한다.
	- interface는 두 layer가 공유하는 경계(shared boundary)이다.
		- plug의 socket, computer의 printer, program의 호출 함수 등.
	- protocol은 layer 간의 상호작용(interaction)을 위한 규칙(rule)들의 집합(set)이다.
		- 내용물(content), 발생하는 환경(circumstance), 연속(sequence), 의미(meaning) 등.
	- protocol은 interface에서 일어나는 일에 적용된다.
		- booster cable을 사용해서 방전된 자동차 배터리에 시동걸기, 컴퓨터와 USB 프린터의 통신(communication) 등.
	- 또한 protocol은 도중에 마주치는 interface 장치들과 별개로, 멀리 떨어진 통신 대상 사이에도 적용된다.
		- http protocol은 web browser와 web server 사이의 문제이다. 이 protocol은 사이에 존재하는 우리 컴퓨터의 WiFi interface, 서버의 Ethernet interface, routing protocol과 flow control protocol이 무엇이든 상관이 없다.
	- 우리는 개념적으로 일반화하여 "http protocol 은 web browser와 server 간의 interface를 제공한다"라고 말할 수 있다.
- https://en.wikipedia.org/wiki/Protocol_(object-oriented_programming)
	- Protocol (object-oriented programming)
	- 보다보니 protocol은 "interface의 interface"라는 생각이 들었다.
	- 기본적으로 interface를 만족하는 구체적인 implementation은 다양하게 존재할 수 있다.
	- 마찬가지로 protocol을 준수하는 구체적인 interface도 다양하게 존재할 수 있다.
	- 그리고 interface는 developer와 user라는 두 layer 사이에 있는 것인데,
	- protocol도 layer를 나누기는 하지만, protocol 'A'를 준수하면 implementation 'a'와의 어떤 interaction이 가능함을 보장하는 느낌이다.
	- 이 protocol 'A'를 만족하는 implementation은 다양하게 존재할 수 있다.
	- 그리고 그렇게 만든 다양한 implementation들은 안전하게[1] 'a'와의 그 interaction이 가능함을 보장받는다.
	- 이렇게 구체적으로 보니 protocol은 implementation을 위한 set of rule로서 interface를 제공한다고 할 수 있겠다.
- interface의 탄생 배경은 protocol과 달리 layer를 나눠서 큰 작업을 작은 작업으로 나누는 것이라고 생각한다.
	- 큰 작업을 layer 하나로 퉁치고 작업할 수도 있겠지만, 누군가는 layer를 나누어 분업을 하고 싶었던 것이다.
	- 가령 컴퓨터에서 운영체제 없이 바로 작동하는 프로그램을 만들 수도 있겠지만, 운영체제 layer와 그 위에서 작동하는 프로그램 layer로 나누어 개발을 한 것이다.
	- 이 때 두 layer는 상위 layer를 지원하기 위한 개발을 하는 developer layer와 하위 layer를 활용하여 실질적인 program을 개발하는 user layer로 나뉜다고 할 수 있다.
	- 즉, 한 layer는 공급을 담당하고 한 layer는 수요를 담당하는 수직구조가 되도록 layer를 나눈 것이다.
	- 이 때 수요와 공급이 적용되는 대상이 있을텐데, 그 대상들의 집합을 interface라고 할 수 있겠다.
	- 가령 문서 편집기 프로그램을 보면 개발자와 사용자가 있을 것인데, 사용자 입장에서는 어떤 키를 누르면 어떤 행동을 하기를 기대한다.
		- 이런 '입력 - 행동'들이 사용자 층이 요구하는 수요이고, 이것을 개발자가 구현하여 공급하는 것이다.
		- 그럼 사용자는 경험이나 문서화된 설명서를 통해 "어떤 키를 누르면 어떤 행동을 할 것이다"라는 interface를 어느정도[2] 이해한 상태에서 프로그램을 사용하게 되는 것이다.
		- 만약 더 나아가 사용자가 편집기 프로그램의 interface를 자동화하여 방향키를 누르는 행동을 반복하는 것으로 <Home>, <End> 등의 기능을 구현할 수 있을 것이다.
		- 또는 cursor가 위치한 문자를 저장해서 사용할 수 있도록 하는 기능을 interface에 추가했다면, 다음 스페이스까지 이동하는 기능 등도 구현할 수 있을 것이다.
		- 이 때 사용자는 interface만 이해하면 구체적인 프로그램의 구현을 알지 않아도 복잡한 기능을 빠르게 구현할 수 있게 된다.
		- 단, 프로그램 개발자가 프로그램의 구현을 전부 이해하고 직접 다음 스페이스까지 이동하는 기능을 추가하는 것 보다는 불필요한 동작을 더 할 수도 있다.
		- 하지만 layer를 나누어 분업을 한다는 것은 그런 performance 손실에도 불구하고 여러 장점이 있다.
			- 프로젝트의 작업을 분리하여 여러 인원이 같이 작업을 해도 자기 작업에 집중할 수 있다든가,
			- 한 번 구현한 하위 layer를 재사용하여 상위 layer에서 빠르게 다음 기능을 구현할 수 있다든가,
			- 하위 layer가 한 번 잘 작동하는 것을 확인했다면, 재사용하기 때문에 오류가 없는 안정된 layer라는 것을 보장하고 상위 layer에서의 작업을 진행할 수 있다든가,
			- layer를 구분하여 작업함으로써 더 자주 풍부한 단어들을 정의하여 사용할 수 있게 된다든가,
			- 사용하는 단어가 많아지니 필연적으로 저장 공간도 다양해지기 때문에 어떤 내용을 어디에 저장해야할지 판단하기가 쉬워진다든가,
			- 동시에 어떤 내용이 어디에 적혀있을지 파악하기 쉬워진다든가,
		- 등등 마치 반복되는 기능을 함수로 만들어서 재사용할 때 발생하는 trade-off와 거의 동일하다고 보면 된다.
		- 단점이라면 위에서 말한 성능 손실과, 실제 행동을 정의하는 작업 이외의 부가적인 작업의 양이 많아진다는 점이다.
- protocol의 예로는 통신 규약을 들 수 있다.
	- 두 기기가 하나의 전선을 사용하여 데이터를 주고 받는다고 할 때, 데이터 원본을 보낼 수는 없고, 전압과 타이밍 등을 이용해 정의하는 언어(규칙)로 변환하여 송수신을 할 수 있을 것이다.
	- 이 때 전압과 타이밍 등을 이용해 정의한 규칙을 protocol이라고 할 수 있을 것이다.
	- 즉 기본 핵심 개념은, 데이터 송수신 시 나의 언어와 통신을 위한 언어를 서로 변환해가며 사용해야 하는데 이 때 "통신을 위한 언어는 이런 것이다"를 정의해 놓은 집합이 protocol인 것이다.
	- 그럼 A와 B가 이 protocol을 사용하여 통신을 하기 위해 A는 이 프로토콜을 따르는(conform) 송신 프로그램을 만들고, B는 이 프로토콜을 따르는 수신 프로그램을 만들었을 때, A가 송신 프로그램을 사용해 데이터를 전송하면 데이터는 프로그램에 의해 protocol에 정의된 통신 언어로 변환될 것이고, B는 수신 프로그램을 통해 protocol이 정의하는 통신 언어를 데이터로 변환하는 것으로 통신이 이루어질 것이다.
	- 이런 통신 protocol은 interface와 달리 수요와 공급이 따로 분리된 것이 아니라 자신이 필요한 것을 스스로 만드는 것 같다.
		- A든 B든 어떤 경로[3]를 통해 서로 데이터를 주고 받기 위해서는 메모리를 공유하지 않는 이상 한 기기 내부에서 사용되는 데이터 전달 방식 이외의 통신 방법을 사용해야 할 것이다.
		- 이 때 같은 경로를 사용한다고 하더라도 전압과 타이밍에 따라 데이터를 전송하기 위한 다양한 규칙이 존재할 수 있다.
		- 따라서 송수신자가 서로 "데이터를 이렇게 보내겠습니다"라는 약속을 하여 송수신을 위해 데이터를 적절히 변환하여 송수신을 하는 것이다.
		- 이 때 이 약속들의 집합을 protocol이라고 한다.
		- 이 protocol을 준수하는 두 기기 사이에서는 서로 데이터 송수신이 가능한 것이다.
		- 어떤 protocol을 준수한다는 것은 그 protocol에 포함된 규칙들을 잘 따르는 프로그램을 작성하는 것이다.
	- interface가 두 layer 사이에서 수요와 공급이 존재하는 대상들의 집합이었고, protocol도 같은 방식으로 interface로 이해할 수 있다.
		- 추상적으로 존재하는 어떤 protocol 개념이 존재할 때, 이걸 실재 작동하는 프로그램으로 구현하는 작업을 한다고 하자.
		- 이 때 두 layer로 나눠서 작업을 하는 것이다.
		- 하나는 추상 protocol을 구체화하는 일이고, 두 번째는 그렇게 구체화된 것을 구현하여 프로그램을 만드는 일이다.
		- 그럼 두 layer는 서로 수직관계이고, 수요와 공급이 발생하며, 이 때 대상은 protocol을 이루는 규칙들이다.
		- protocol을 이루는 규칙들이 프로그램에 어떤 추상 protocol을 구현하기 위한 interface가 되는 것이다.
		- 하지만 구현의 주체가 다르다.
			- interface는 두 layer가 함께 구체화하고, 하위 layer가 구현하고 상위 layer가 사용한다.
			- protocol은 하위 layer가 구체화하고 상위 layer가 구현하고 사용한다.
	- 가령, swift의 Collection 중에 Array의 method들을 보자면 사용하는 입장으로서 Array의 interface가 될 것이다.
	- 만약 swift의 Array class의 interface요소들을 Array라는 class를 사용하기 위한 rule로 받아들이고, 그것들을 모아서 protocol로 만든다면, 그 protocol을 준수하는 나만의 Array class를 직접 정의해서 사용할 수도 있을 것이다.
- type A에서 type B로 implicit type conversion을 할 때, 'A::operator B'가 정의되어 있고, 'B(A const &a)'도 정의되어 있다면 'error: conversion from 'A' to 'B' is ambiguous'가 발생한다.
- change case in vim
	- 'gu{motion}' in vim normal mode: Make {motion} text lowercase.
	- 'gU{motion}' in vim normal mode: Make {motion} text uppercase.
	- 'g~{motion}' in vim normal mode: Switch case of {motion} text uppercase.
- ^D 같은 control character 문자 표기법을 caret notation이라고 한다.
- https://stackoverflow.com/questions/4103086/defining-constants-in-c
	- 
	- C++ 에서는 const qualifier를 붙인 idenifier는 주소를 사용하지 않으면 메모리 공간을 사용하지 않는 상수로 컴파일된다.
	- 반면 c에서는 const keyword를 사용해도, 값이 변하지 않는 변수로 컴파일되기 때문에 항상 메모리 공간을 차지해서, 진짜 상수를 정의하기 위해 반드시 #define이나 enum을 사용해 정의해야만 한다.
	- 따라서 부작용이 있을 수 있고 제한된 기능을 가진 '#define'으로 상수를 정의하는 것보다 const keyword를 사용하는 것이 권장된다.
[1] 버그를 제외한 예상치 못한 문제 없이
[2] interface를 사용하는 사용자 입장에서는 interface의 모든 내용을 이해할 필요가 없다. 하지만 개발자는 사용자의 요구 이상의 내용을 interface에 담아 구현했을 수도 있다.
[3] 전선 한가닥이든지, USB처럼 전선 여러가닥 이든지, HDMI cable 처럼 19가닥이든지

2022-01-09
- https://m.blog.naver.com/ttagui/10043795874
	- Implementation defined, Unspecified, Undefined behavior
	- 이런 용어는 interface specification document에 나온다.
	- implementation defined: implementation에 따라 behavior가 define될 수 있고, 그에 따라 문서화되어 있다.
	- unspecified: implementation에 따라 behavior가 define될 수 있으나 문서화될 필요는 없다.
	- undefined behavior: behavior을 define하지 않았기 때문에 implementation에 따라 어떤 behavior을 할 것이라 단정할 수 없다.
- swift/Generic Structure/Array
	- firstIndex: 특정한 조건을 만족하는 첫 element의 index
	- lastIndex: 특정한 조건을 만족하는 마지막 element의 index
	- startIndex: Array의 첫 index
	- endIndex: Array의 마지막의 다음 index
- https://stackoverflow.com/questions/843632/is-there-a-difference-between-an-instance-variable-and-a-property-in-objecti
	- Is there a difference between an "instance variable" and a "property" in Objective-c?
	- stored property와 instance variable은 다르다.
	- instance variable은 실제 instance가 할당받은 공간을 차지하는 변수를 의미하는 implementation 개념이다.
	- stored property는 실제 할당받은 공간의 변수를 의미하지는 않는 interface 개념이다.
	- object안에 정의되는 변수 등의 개념이 폭넓어짐에 따라 추가적인 layer를 두었다고 생각하면 된다.
- std::string::compare() 는 비교하는 두 std::string의 처음 발견한 다른 문자의 차를 반환할까?
	- https://www.cplusplus.com/reference/string/string/compare/
		- std::string::compare
		- 여기에서 가공된 interface 를 볼 수 있다.
		- 구체적으로 차를 반환하는지는 명시되어 있지 않다.
		- 음수, 0, 양수를 상황에 따라 반환한다는 것까지만 알 수 있다.
	- ISO/IEC 14882:1998(E) §21.3.6.8p2
		- 이 문서 역시 std::string::compare의 반환값을 음수, 0, 양수 상황만 명시하고 있다.
	- 구체적인 behavior 는 implementation defined 인 모양이다.
	- 그러므로 std::string::compare() 없이 문자의 차를 구하도록 해보자.
- 'if(!std::cin)'의 정체!!
	- https://stackoverflow.com/questions/38978266/how-can-stdcin-return-a-bool-and-itself-at-the-same-time/38978346
		- How can std::cin return a bool and itself at the same time?
	- if의 condition은 bool 타입이 들어올 것을 기대한다.
	- 따라서 std::istream 타입인 std::cin을 bool 타입으로 바꾸기 위해 implicit type conversion을 시도한다.
	- 이 때 conversion operator인 'std::istream::operator bool(std::cin) const'이 호출된다.
	- 그 결과 true 또는 false 가 expression 의 결과로 반환된다.
	- 만약 내가 conversion operator 를 정의할 일이 있다고 한다면 반드시 explicit qualifier 를 붙이도록 하자.
		- 이번 건과 같이 소리소문 없이 어떤 함수가 호출되면 프로그램을 파악하기가 힘들어진다.
		- 또한 implicit type conversion이 일어날 곳에 항상 explicit하게 type conversion을 명시하는 것도 좋겠다.
			- 사실 이런 시도는 만들어 놓은 기능을 반대로 틀어막는 식이라 썩 좋은 습관은 아니다.
	- 이제 이것의 정체가 operator method 라는 것은 알았는데 더 찾아보니 operator type 뿐만 아니라 operator!도 존재했다.
	- 살펴보니 C++98에는 'std::istream::operator bool'이 없기 때문에 'if (std::cin)'으로는 사용할 수 없고,
	- 'std::istream::operator!'가 있기 때문에 'if (!std::cin)'으로 사용해야 한다.
	- 그럼 C++98에서는 'if (std::cin)' 을 사용하면 type conversion 이 불가능하다는 에러가 발생할까? 아니면 C++11 의 'std::istream::operator bool'을 사용할까?
	- 추가적으로 if, while, for 등의 condition은 bool 타입을 기대하는데, 이 경우 condition의 결과 type 이 bool 은 아닌데 'explicit operator bool()'을 정의했을 경우, explicit 하게 type conversion 을 명시하지 않았더라도 implicit 하게 type conversion이 된다고 한다.
	- 가장 좋은 방법은 type conversion을 정의하고 사용할 때는 반드시 type conversion 용도로만 사용하는 것이다.
	- 그 외에 맞지 않는 행동을 하면 가독성과 직관성이 떨어지게 된다.
	- 가령 'if (!std::cin)'은 적절하지 못한 사용법이다.
	- std::cin 은 bool 타입으로 형변환하는 것이 '불가능' 하기 때문이다.
	- 이렇게 형변환 이외의 목적으로 오용하는 것은 가독성을 크게 해치고 코드를 암호화하는 요인이므로 절대 피하도록 하자.
	- 다른 관점으로 해석해보자면, interface 관점으로서, type conversion은 '형변환' 이라고 명시해 놓은 느낌인데, 'std::cin::operator!'는 이를 implementation하는 과정에서 약속한 '형변환'의 목적으로 구현하지 않고 마음대로 에러 유무를 반환하도록 구현했기 때문에 specification에 맞지 않는 구현을 한 것이라고 볼 수 있겠다.
- The Swift Programming Language (Swift 5.5 beta): Language Reference: Statements: If Statement
	- grammer를 보면 if 다음 오는 조건식을 condition 이라고 한다.
	- condition 은 expression 이 될 수 있다.

2022-01-08
- https://www.reddit.com/r/OSXElCapitan/comments/3lf3tj/help_reorder_results_in_spotlight_searches/
	- [Help] Reorder results in Spotlight searches
	- cmd-L in spotlight: 사전 항목으로 jump
	- cmd-B in spotlight: 브라우저로 검색
- tcpppl 389p ~ 393p
	- 'void Parser::logical(bool);' -> error: no logical() in Parser
		- namespace definition 밖에서 새로운 member 를 선언할 수 없다
- '::'(double colon) in cpp: Scope resolution operator
- initialization list: 'Object::Object(Arg arg1, Arg arg2): _attr1(arg1), _attr2(arg2) {}'
	- 이 때 _attr1 과 _attr2 는 assign 하는 것이 아니라 initialize 하는 것이다.
		- 따라서 const type 의 member variable 도 initialization list 에 명시하여 initialize 하는 것이 가능하다.
	- 'void Object::method(Arg arg) const {}' 에서 const 는 c 로 이해하자면 'void Object_method(Object *const this, Arg arg) {}' 인 것이다.
		- 즉, 해당 method 를 호출하는 Object 를 const type 으로 받아서 사용하겠다는 의미이다.
- visibility of access modifier
	- visibility 가 private 과 같은 member variable 과 method 의 identifier 에는 prefix 로 '_' 를 붙이는 convention 이 있다고 한다.
- structure vs class
	- structure 는 default visibility 가 public 과 같다
	- class 는 default visibility 가 private 과 같다
- getter and setter
	- 단순히 member variable 에 직접 접근하는 것을 금지하는 것 이상으로 값을 설정 시 특정 작업을 실행하고 싶다거나, 값을 읽을 시 특정 작업을 실행하고 싶을 때도 유용하다.
- static member variable, static method
	- static member variable 을 초기화할 때 global variable 이기 때문에 자동으로 0 으로 초기화되지 않을까?
		- 그럼에도 불구하고 초기값을 0 으로 결정했다면 명시적으로 0 으로 초기화해 주도록 하자.
		- 만약 자동으로 0으로 초기화가 된다고 하더라도 명시적으로 0 으로 초기화를 하면, 그 최적화는 compiler 의 역할이다.
		- 초기값이 0 으로 초기화됨을 명시적으로 표기해주는 것이 가독성 측면에서 유리하다.
	- class body 에 static member variable 를 선언하는 것은 extern 으로 선언하는 것과 같다.
- pointer from object
	- pointer from object to variable: 'type Object::*ptr;': 이 때 ptr 은 정확한 주소값을 저장하지 않는다.
		- 'ptr = Object::member1;' 와 같이 특정 Object 의 member variable 중 하나를 할당받으면 이는 instance 가 차지하는 메모리 시작점으로부터 member1 의 위치를 기억한다.
		- 'instance1.*ptr; instance2.*ptr;' 과 같이 각 instance 에 대해 member1 은 동일한 위치에 존재하므로 ptr 이라는 identifier 를 Object type 의 instance 모두에 사용 가능하다.
		- 그리하여 각 instance 의 member1 맴버 변수에 접근할 수 있다.
	- pointer from object to method: 'type (Object::*f)(Arg arg) [const];': 함수는 instance 마다 각각 갖는게 아니라 'Object::function' 으로 하나만 존재하므로 실제 함수의 주소가 저장된다.
		- 'f = &Object::function;' 으로 원하는 함수의 주소를 넣어줄 수 있다.
		- '(instance.*f)(arg);' 로 호출할 수 있다.
		- 'type *f(Object *const, Arg arg);' 도 똑같이 사용할 수 있을까 싶었지만 'newF = &Object::function;' 로 주소값을 저장하려고 시도하자 compile time 에서 'assigning to 'void (*)(Object *const)' from incompatible type 'void (Object::*)() const'' 라는 error 가 발생하면서 compile 되지 않았다.
		- compiler 가 이 둘을 명백히 다른 것으로 처리한다는 것을 알 수 있다.
- member function 의 가장 첫 인자로 들어가는 this 를 object argument 라고 한다.

2022-01-07
- C++ 에서 자동 형변환은 문제의 소지가 있는 나쁜 시스템인 것 같다
	- 때문에 형변환이 필요한 경우 명시해주도록 하자
- constructor and destructor
	- default constructor
	- parametric constructor
	- copy constructor
	- destructor
- Programming in C++ 59p ~
	- reference 는 반드시 초기화 되어야 하기 때문에 NULL 인지 test 할 필요가 없다. 마치 swift 의 non-optional 같다. pointer 와 reference 와의 관계가 optional 과 non-optional 과 같지는 않지만, c 와 달리 non-optional 적인 기능이 있어서 너무 좋다
- 초기화하기 전의 값을 사용하는 것은 큰 의미가 없다. 그런 쓰레기 값을 사용하는 것은 모든 상황에서 배제하고 항상 값을 설정한 후 사용하도록 하자
- https://www.geeksforgeeks.org/type-conversion-in-c/
	- Type Conversion in C++
	- There are two types of type conversion:
		- Implicit Type Conversion: Also known as 'automatic type conversion'
		- Explicit Type Conversion: Also called 'type casting'
			- Converting by assignment: This can be also considered as forceful casting
			- Conversion using Cast operator
				- Static Cast
				- Dynamic Cast
				- Const Cast
				- Reinterpret Cast
- literal 3.14 는 matching function 을 탐색할 때 implicit type conversion 에서 char, int, float 중에 우선 순위가 존재하지 않는다
	- 만약 literal 3.14f 라면 float 으로 우선 matching 된다
	- 하지만 double type 이 존재하면 우선적으로 matching 된다
- error: unused variable
	- compiler 가 생성한 default constructor 에 의해 생성된 instance 는 사용하지 않으면 이 오류가 발생하면서 compile 이 되지 않는다
	- 'Object object(2)' 와 같은 형태로 생성된 instance 는 사용하지 않아도 이 오류가 발생하지 않는다
	- 'Object object = Object(2)' 로 생성한 object 는 사용하지 않으면 이 오류가 발생한다
	- 'Object object = Object()' 와 같이 default constructor 를 호출하여 instance 를 생성한 후 object 를 사용하지 않으면 이 오류가 발생한다
	- 하지만 declaration 과 assignment 를 분리하여 'Object object; object = Object();' 로 사용하면 이 object 를 사용하지 않았을 때 이 오류가 발생하지 않는다
	- 한 줄 요약: declaration 시 default constructor 를 사용했다면, 이후 생성된 instance 를 사용하지 않았을 때 unused variable error 가 발생한다
- NULL 은 (void *)이기 때문에 "void (*)(int *)" 의 인자로 matching 되지만 "void (*)(int &)" 의 인자로는 matching 되지 않는다
- user-defined constructor 를 정의하면 compiler 는 default constructor 를 자동 생성하지 않는다
- compiler 는 default constructor 만 자동 생성하고, 인자를 사용하는 constructor 는 자동 생성하지 않는다
- 모든 인자가 default value 를 갖는 parametric constructor 를 정의하고 default constructor 를 정의하지 않았다면, default constructor 를 호출할 때 이 parametric constructor 를 호출한다
- 만약 위의 parametric constructor 를 정의했는데 default constructor 도 정의했다면, default constructor 를 호출했을 때 어떤 것을 사용해야 할지가 모호하기 때문에 'error: call to constructor of 'Object' is ambiguous' 에러가 발생한다
- 'function()' 과 같이 인자가 없을 때 'void' 를 명시하지 않고 'function(42)' 와 같이 사용한다면 c 에서는 warning 이 떠서 compile 이 되므로 void 명시가 함수를 의도에 맞게 정의하기 위한 필수 과정이었지만 cpp 에서는 warning 이 아닌 error 가 발생하기 때문에 compile 이 진행되지 않아 void 를 생략하더라도 의도와 구현이 일치한다
- 'Object object = Object();' 는 default constructor 호출 한 번으로 object instance 를 생성한다
- C++ 에서도 c 와 마찬가지로 지역 변수는 자도으로 초기화하지 않는다

2022-01-06
- Programming in C++
	- 42p ~
	- 231p ~
	- cpp 는 함수 인자로 정의되지 않은 user-defined type 이 들어왔을 때도 자동으로 형변환을 할까?
		- user-defined type 을 인자로, 필요한 type 의 생성자를 호출할까?
	- cerr: unit-buffered ostream, 일반적 에러 출력
	- clog: buffered ostream, 즉각 출력이 필요 없는 일반적 로그 출력
- https://stackoverflow.com/questions/37905125/is-cout-put-recommended-over-cout-for-printing-characters
	- Is cout.put() recommended over cout<< for printing characters
- 언어를 익히기 위해서는 reference 문서 읽는 법부터 배워야 한다
- https://www.cplusplus.com/reference/string/string/operator%3E%3E/
	- function std::operator>> (string)
	- 반환값이 'The same as parameter is.'라고 한다
	- https://stackoverflow.com/questions/10349857/how-to-handle-wrong-data-type-input
		- How to handle wrong data type input
		- 하지만 이 페이지에서는 'If cin is in a bad state, it will return NULL' 이라고 주장한다
	- 왜 reference 문서는 제대로된 설명이 적혀있지 않은 것일까?
	- 어디에서 제대로 된 reference 문서를 찾을 수 있을까?
- https://www.youtube.com/watch?v=dFCZxYfmDyc#t=25m50s
	- 변하고 싶다면 무조건 적어라 #영상모음zip
	- 문제 해결을 위해서는
		- 문제 인식 -> 문제 파악 -> 새로운 시도 -> 성공적인 결과가 나올 때까지
- 나는 밥먹을 때 심심해서 유튜브를 보게 되어 수시간 연달아 보는 문제를 겪었다
	- 뱝먹을 때 절대 유튜브 등을 보지 말자!
	- 하지만 밥먹을 때 심심하다
	- 그럴 때 영상을 보고 싶은 유혹에 빠진다
	- 공부 영상이라도 보기 시작하면 유튜브의 늪에 빠질 것 같다
	- 무제한 영상을 제공하는 유튜브 환경이 문제인 것 같다
	- 한 가지 방법만 도입하는게 아니라, 실패 시 2, 3 번 제어 장치를 두는 것이 좋다
	- 밥먹을 때 영상을 보지 않는 대체 행동을 찾는 동시에(슬랙 보기 등) 2차 3차 제어 장치를 마련하자
	- 2 차 제어 장치: 영상을 보기 시작했다면 영상 시청을 그만두고 본 궤도에 올라갈 것을 명령하는 신호를 보내는 병령 시슨템 도입
		- 밥먹기 전에 알람을 맞춰놓는다
			- 설정한 시간 동안 식사를 마치지 못했다면 영상을 보고 있을 확률이 높다. 이 때 알람을 듣고 정신을 차릴 것이다

2022-01-05
- PM: Project Manager: 프로그램 전반적으로 굴러가는데 차질이 없도록 관리하는 역할
- PD: Project Director: 프로그램의 핵심적인 부분이 잘 작성되도록 관리하는 역할
- Programming in C++
	- 29p
		- expression: 반환값이 존재
		- statement: 반환값이 없음(?)
			- expression 은 statement 에 포함된다
	- 34p
		- getopt()라는 library function 도 있구나?!
- interface vs implementation
	- ISO 에서 열람할 수 있는 자료는 interface 에 해당한다
	- 실제 구현된 compiler 등은 implementation 에 해당한다
	- 따라서 우리는 범용적인 spec 을 확인하기 위해서 ISO 등의 spec 문서를 보아야 하고, spec 문서에서 명시하지 않는 실제 구체적인 동작을 확인하기 위해서는 implementation 을 보거나 test 를 하여 알아내야 한다
- https://www.youtube.com/watch?v=MOYymnAFhY0
	- 성공하는 사람들의 공통적인 특징 3가지 (천인우 전 페이스북 LV5개발자)
	- assume good intentions: 상대가 선한 의도를 가지고 말을 한다고 가정해라
	- psychological safty: 심리적 안정감
		- 리더로서 심리적 안정감이 있는 조직문화를 만드는 것이 중요하다
	- 성과를 잘 내는 것도 중요하지만 주변 사람들을 얼마나 잘 retain 하느냐
- https://www.youtube.com/watch?v=Geb5ScWrGhA
	- 페이스북 개발자 시간관리의 5가지 비밀 (천인우 2부 전 페이스북 LV5 개발자)

2022-01-04
- zero-overhead rule
	- What you don't use, you don't pay for. And further: What you do use, you couldn't hand code any better
	- runtime type identification 과 exception 만이 예외라고 한다
- https://www.stroustrup.com/ETAPS-corrected-draft.pdf
	- Foundations of C++
	- object: set of data member and method for a notion
	- data member: variable of object

2022-01-03
- ':set all': display all set
- 함수 이름을 여러개로 쓸 수 있도록 필요할 때마다 추가할 수 있도록 하면 결국 지저분해질 뿐이다, 따라서 문서 편집기에서 특정 이름들을 특정 상수로 바꾸도록 처리하여 서로 다른 이름을 쓰더라도 결국 같은 상수가 되도록 처리하는 것이 좋다. 일괄적으로 변수 이름을 바꾸는 기능을 상위단에서 제공하는 것이다
- 여러 이름들, 최선의 이름은 있겠지만 최고의 이름은 없다
	- 하지만 한 번 정해진 이름은 여기 저기서 쓰이게 되면 나중에 다른 이름으로 바꾸기가 쉽지 않은걸?
- 'cut -f 9-': 9 번째 word 부터 끝까지 출력
- 'c_<C-R>_<C-L>': insert the line under the cursor
- ':range': 명령을 할 대상의 범위를 명시하는 방법들
- :[range]m[ove] {address}			*:m* *:mo* *:move* *E134*
			Move the lines given by [range] to below the line
			given by {address}.
	- 이 때 address 에 마크를 넣어주면 지정된 위치로 텍스트를 보낼 수 있어서 편리하다
		- ex> '<,'>m 'f
- ':*'
								*cpo-star*
		*	Use ":*" in the same way as ":@".  When not included,
			":*" is an alias for ":'<,'>", select the Visual area.

2022-01-02
- 'git status' 는 한글을 제대로 출력하지 못하므로 가능하면 파일명에 영어 이외의 문자는 사용하지 말도록 하자

2022-01-01
- vim: 가끔 한글이 마지막에 위치했을 때 보이지 않는 문제.
	- 아마 여러 공간을 차지하는 문자가 마지막에 왔을 때, 표기를 다음 줄로 넘기기 위해 공백을 의미하는 '>' 를 쓰고 다음 줄에 출력하는데 이로 인한 버그로 이전 줄로 되돌아갈 때 표시하지 않게 되는 것이 아닐까?
	- 마지막 2 칸에 한글 한 문자가 위치할 때 이전 한글 문자를 'r' 을 사용하여 다른 한글 문자로 수정하면 마지막 2 칸에 있던 한글 한 문자가 안보이게 되는 문제를 확인했다.
- '<S-R>' in netrw: rename file
- '<S-D>' in netrw: delete file
- 아침에 작업을 시작하기 전에 backup 을 한 번씩 해주는 것은 어떨까?

2021-12-31
- https://www.sciencedirect.com/topics/engineering/memory-address-register
	- pc: program counter

2021-12-30
# 시작 문서
getting started: 아주 기초적인 사용법부터~
	- 주로 실행 가능한 프로그램 등의 사용법을 소개하는 용도
tutorial: 간단한 모든 자료
tour: 다른 것과 비교되는 특징적 자료
reference: 모든 자료
예시
	- tutorial
		- https://lldb.llvm.org/use/tutorial.html
			- LLDB Tutorial
	- tour
		- https://docs.swift.org/swift-book/GuidedTour/GuidedTour.html
			- A Swift Tour

2021-12-27
- project base learning 의 개념을 가져와서 sprint base working 은 어떨까?
	- 작업을 진행할 때 한 번에 큰 일을 처리하는 것이 아니라 sprint 로 구분하여 작업을 처리하는 것이지
		- 게다가 에자일 이념을 붙여서 계획-수행-회고 과정을 수행하는 것도 좋을 것 같다.
- vim/help/usr_12.txt
	- ':%s/four/4/g': The "%" range means to replace in all lines.  The "g" flag at the end causes all words in a line to be replaced.
	- ':%s/\([^,]*\), \(.*\)/\2 \1/': "Last, First" -> "First Last"
		- '\2' and '\1' is called backreferences
			- They refer to the text matched by the "\( \)" parts in the pattern.
	- 'g<C-G>' in normal mode: count things of file in various aspects
	- 'g<C-G>' in visual mode: count things of selected range in various aspects
- git status 시 한글 파일의 이름이 아래와 같이 깨져서 나오는데 git status 는 한글 출력을 못하던가?
```
Untracked files:
  (use "git add <file>..." to include in what will be committed)
	"contents/list: \352\260\200\353\263\264\352\263\240 \354\213\266\354\235\200 \352\263\263.txt"
```

2021-12-25
- 아이폰에 한 손 키보드 모드가 있는지 몰랐다. 이게 그로스 해킹인가 뭔가 하는 녀석인가? 하지만 치명적인 문제가 있으니.. 아무리 한 손 키보드 모드라고 해도 결국 한 손으로 모든 조작을 처리하는 것은 불가능에 가까우며, 키보드가 더 작아져서 오타도 많아진다. 개인적으로 오타가 나지 않으려면 가로모드는 필수라고 생각한다. 키보드여서야 세로 모드의 빽빽한 키보드에서는 오타가 날 수밖에 없다. 다만, 한 손 키보드 모드가 두 손 사용을 전제로, 한 손만으로 타이핑을 하는 것을 목표로 만들어졌을 수 있다. 이 경우 그래도 약간은 의미가 있다고 생각한다.
- 밸런스가 중요하다. 트레이드 오프에서는 무게에 따라 명칭을 달리하면 좋다. 가령 캐쉬-메모리 처럼, 개인화 정도에 따른 명칭이 있다면 좋을 것. 영화 inside 정도의 피망 개인화를 나타내는 단어가 있다면 좋을 것이다. 그리고 그모다 더 시간을 들인 최적화도 있을 것이다. 동시에 이보다 적은 시간으로 개인화하는 '더빙' 등을 의미하는 단어도 붙여줄 수 있겠다.
- 일단 떠오른 단어를 먼저 적도록 하자. 서술하여 기록하다가는 10 중에 일부가 사라진다. 하지만 단어도 세세가 사라짐 가능, 동시 세세 선도 사라짐 추적 가능. 하지만 큰 틀을 잡는 것이 더 좋아보임. 마치 계획을 세우고 실천하는 느낌.
- 오늘 서울에서 본가로 내려가고 있다.
	- 8시 30분 버스를 타려고 했는데 몇 분 차이로 놓치고 말았다.
	- 그래서 9시 기차를 타기로 경로를 수정했다.
	- 일단 기차를 오랜만에 타서 좋은 경험이긴 하다. 버스보다 흔들림이 적어서 굳이 모바일을 사용할 필요도 없이 컴퓨터를 꺼내서 이 글을 작성할 수 있는 것이 좋았다. 그리고 자리가 넉넉하게 넓어서 비좁게 타는 버스보다 좋았다. 하지만 2시간 정도 걸리는 버스에 비해 싸고 느린 기차를 골랐기 때문에 3시간이나 걸리는 것은 단점이었다.
	- 그리고 난 용산역에서 기차를 탔는데 다음에 또 이런 일이 있다면 영등포역에서 타는 것을 고려해보고 싶다.

2021-12-23
- 다른 것을 하고 싶은 마음이 생길 때 나를 올바른 길로 이끌 것이 필요하다.
	- 이런 목적을 가진 무언가를 준비하도록 하자.
- [초청특강] 알아두면 쓸데없는 신비한 개발잡담 BY LG유플러스 신정호 CTO
	- 예측: 난이도/양/기간
	- 도메인 지식이 중요하다
	- 왜 이렇게 작성했어?
		- 예외 상황을 우회하기 위한 최선의 노력이다.
			- 이를 제대로 파악하지 못하면 요구 사항에 맞지 않는 작동을 하는 프로그램을 만들게 될 수도 있다.
	- 고객이 항상 맞지는 않다. 고객이 표현하지 못하지만 내면에 원하는 것을 파악하는 것은 엄청난 능력이다.
	- 현상
		- 빠르게 해결이 가능하다
		- 사이드 이팩트가 날 확률이 크다
	- 원인
		- 빠른 해결이 불가능하다
		- 사이드 이팩트가 덜하다
- case by case 인가?
	- 참이라면 데이터를 수집하여 어떤 case 에 어떤 것을 적용하는 것이 좋을지 파악한다.
- ':sort' in vim normal mode: sort lines
- ':g/<pattern>/y A' in vim normal mode: append all lines matching to register a

2021-12-20
- 동영상을 압축해서 단말기로 전송하는 것처럼, 만약 게임의 데이터가 크다면 압축해서 전송할 수 있을 것이다.
	- link: https://www.youtube.com/watch?v=itdPTcBHRbM
- 뭔가 정리를 할 때 정리할 대상의 규모가 예측 불가능해서 의지를 뺏기는 효과가 있다. 만약 정리할 대상의 규모가 예측 가능하다면 정리를 하면서도, '이 정도 시간이 걸리겠구나' 라는 생각을 가지고 각오를 다지고 진행할 것이다. 따라서 정말 끝까지 정리를 완료하고 싶다면 우선 무엇을 정리할 것인지를 정리하는 것이 필요해 보인다.
- 일을 처리하는 과정
	- 일의 규모를 예측한다.
	- 각오를 다지고 일을 진행한다.
- 환경만을 의지해서는 안된다. 자기 통제도 동시에 필요하다. 자기 통제란 스스로 약속하고 못지켜서 비참해지는 것이 아니라. 긴 시간의 사고 후 어떤 약속을 만들었으면 다음부터는 긴 시간을 들이는 사고 없이 그 약속을 지키는 것이다.

2021-12-19
- '날씨의 아이(2019)'를 보았다.
	- '너의 이름은(2016)'을 만든 신카이 마코토 감독의 만든 작품이라고 한다. 사실 '너의 이름은'을 봤을 당시 너무 별로여서 큰 기대를 하지는 않았는데, 바로 다음 작품인 '날씨의 아이'를 보고 작품의 전체적인 밀도가 굉장히 빽빽해진 것을 보고 대단하다고 생각했다. 다음 작품도 정말 기대가 된다.
	- 나는 최근에 어떻게 해야 다시 열심히 할까를 생각하고 있었는데, 이 작품을 보면서, 이런 작품이 나오기까지 정말 오랜 시간이 걸릴텐데, 어떤 과정으로 작품이 탄생했을까를 살짝 생각해 보았다. 그러다가 역시 뜬구름 잡는 이론을 주구장창 공부하는 것은 혼자 하기 힘들고, 뭔가 결과물이 있고 재밌는 프로젝트 베이스로 배우는 것이 좋겠다는 생각을 다시 해보았다. '날씨의 아이' 가 탄생하기까지 거쳐온 이전 작품들이 존재하기 때문에, 나도 뭔가 하려고 한다면 그런 식으로 실질적인 프로젝트 기반 학습을 하는 것이 좋을 것이라고 생각했다.

2021-12-17
- safari 에서 tab group 을 변경하면 이전 탭 그룹에 있던 tab 들의 memory 들은 활성 상태 보기 창에서 cache 로 상태가 변한다.
- AppleScript 를 사용하면 System Preferences 의 설정을 매크로처럼 바꿀 수 있는 것 같았지만 cluster mac 의 administrator 권한이 없이는 제대로 사용할 수 없다

2021-12-16
- 도어락
	- 마스터 비밀번호 여부
	- 교통카드로 열 수 있는 도어락도 존재한다
		- 그런 경우 card 표시가 도어락에 존재하는 경우가 있다
		- 하지만 7분만에 복제가 가능해서 보안이 좋지 않은 경우 사용하면 위험할 수 있다.
	- 도어락에 지문 보안을 강화하기 위해 단순히 매번 화면이 켜질때마다 숫자가 한 칸씩 밀리도록 만들면 되지 않을까?
		- 그러면 각 숫자 위치의 디스플레이가 모든 숫자를 표시할 수 있게 되어야 하기 때문에 구조가 복잡해지고 비용이 늘어나는 문제가 있다.
		- 때문에 비밀 번호 전 후에 의미 없는 숫자를 누르도록 유도하는 허수 기능이 큰 변화 없이 문제를 해결하는 좋은 방법이라고 생각한다.
			- 단, 이 허수 기능으로 인해 비밀번호와 일치하는 패턴이 더 많아지는 것은 아닌가?

2021-12-15
- http://beemarketer.co.kr/youtube/timetag/
	- 유튜브 링크에 시간 추가하는 방법
- https://www.youtube.com/watch?v=1bcmmc2rTBE#t=9m26s
	- 증명할 수 없는 것은 크게 자료로서 가치가 없다
		- 증명을 위해 구체적인 루틴 등을 제시하는 것이 좋다
	- 결국 시스템을 만든 사람이 목표를 달성한다
		- 열정: 나는 한 달 동안 10kg을 뺄 거야
		- 시스템: 나는 매일 1만 보를 걸을 거야
	- 단순히 목표만을 제시하거나 추상적인 단어를 쓰기 보다는 시스템을 만들고 제시해라
		- 시스템의 예: 루틴, 규칙
- https://www.youtube.com/watch?v=7zI4qyLBEOM
	- 2021 데이터 그랜드컨퍼런스 Track3 데이터와 기술
		- 그로스해킹, 초 개인화, 개인정보보호의 상위일체 '고영혁'
		- 점점 동의하지 않으면 데이터를 수집하지도 못하는 식으로 변화하고 있다
			- ex> apple
		- 서비스가 진짜 올바른지를 데이터를 통해 객관적으로 확인
		- 사회가 파편화됨에 따라 최대한 잘게 쪼개서 봐야한다
	- 판매업의 고객 파악, 조선사의 조선 중 배를 특정 위치로 이동, 축산업에서 데이터 수집, 개인 데이터 수집을 통한 맞춤형 서비스, ai를 활용한 고객 응대, 건설 시 설계, 자제 관리, 시공 시뮬레이션, 유지관리 데이터 관리
- xcrun xctrace record --output philo.trace --template 'Time Profiler' --launch -- philo 200 210 100 100 5
	- cli 에서 특정 command 를 실행하고 실행 중의 다양한 수치를 기록한다. 이후 생성된 philo.trace 파일은 apple 의 instruments app 에서 열 수 있다.
	- 뭔가 함수 내부 코드 중에 어디에서 자원을 많이 사용하는지를 대략 보여주는 것 같지만 측정 프로그램과 분리된 독립된 프로세스가 일정 주기마다 측정하는 것이다 보니 아주 정밀하지는 않은 것 같다. 그래서 거대한 프로그램에서 대략적인 성능을 측정할 때는 좋겠지만 작은 프로그램의 성능을 측정하기에는 조금 아쉬운 부분이 있는 것 같다. 그 외에 어셈블리 코드를 보여주는 것은 objdump 와 같이 disassemble 해서 출력한다.
- command + shift + .: finder 에서 숨김 파일 보기
- 'file://<path>' on safari address line: open a file on safari
- https://en.wikipedia.org/wiki/Timeline_of_programming_languages
	- 프로그래밍 언어 타임라인
	- 1943-1946년에 한참 ANIAC 을 위한 프로그래밍 언어를 만들다가 1972 년에는 C언어, 1977년에는 APPLE2 가 출시되면서 APPLE2 를 위한 BASIC 언어가 생기기까지 했다. 그 사이에도 다양한 언어가 치열하게 생겨났다. 1980년에는 C++ 가 만들어졌다.

2021-12-13
- thread list
- thread backtrace all
- thread select 2

2021-12-12
- 두 쓰레드에서 동시에 printf 를 찍고 mutex 를 걸지 않는다면 아래와 같이 출력이 섞일 가능성이 있다.
```
// 섞임
expect sleep: [0 199990]                   1024          86 has taken a fork
, real sleep: [0 200345]
```
```
// 기대한 출력
expect sleep: [0 199990], real sleep: [0 200345]
                   1024          86 has taken a fork
```
- philosopher 과제를 진행하다보니 걱정했던 것보다 sleep 을 많이 걸어주니 실제 돌아가는 thread  가 적어져서 usleep()의 오차가 심하지 않았다.(200ms 을 주면 205ms 슬립 정도, 걱정은 1ms 만 줘도 160ms 정도 긴 잠을 자는 경우가 있지 않을까 생각했었음, 이 심각한 경우는 실제로 200 개의 쓰레드에 spin lock 을 걸면 관찰 가능)
- 새로운 형태의 인재를 만드는 교육과정을 존중하기 때문에 공개적으로 silent 클러스터를 두는 것은 좋지 않은 것 같다. 역시 조용히 숨겨진 그룹을 구성해보도록 하자

2021-12-11
- playground repo 에서 새로운 branch 를 만들고 변화 과정을 commit 으로 기록하였지만, 그것이 전체적인 git 의 data 크기를 줄이지는 못한다는 것을 안다. git 은 변화를 기록하는 것이 아니라 프로그램 자체를 기록해버리기 때문이다. 그러니 굳이 보기 힘들게 commit 형식으로 내용을 기록하지 말고 하나의 directory 를 만들어서 그 안에 변화 과정이 담긴 각 내용들을 추가적인 directory 안에 담아서 commit 하도록 하자
- 서브젝트에 있는 문장들을 아리송한 채로 놔두지 말고, 나의 언어로 정리하여 목적인 완성된 프로그램을 위한 구체적인 목표로 명시해두는 것이 좋다. 그렇지 않으면 구현할 때마다 아리송했던 정리되지 않은 명세 내역을 반복하여 확인하면서 매 상황에 따라 명세 내역을 새로 해석해야 할 것이다.
	- 하지만 처음부터 명세 내역을 명확하게 이해하기는 쉽지 않다. 구현을 진행하면서 생각지 못했던 부분이 존재하여 기존에 정의한 명세 내역이 적절하지 않다는 것을 알게 될 수도 있다. 따라서 가장 좋은 것은 명세 내역을 제시하는 사람과 의견 교환을 하여 뚜렷하게 하고, 구현 진행 중에 의문이 생길 때마다 명세 내역 제시자와 반복적으로 의견을 주고 받으면서 서로에게 바람직한 제품을 만드는 것일 것이다. 단, 질문을 할 때는 기본 원칙인, 상대방에 대한 존중을 지켜야 한다.
	- 마치 조각을 할 때 처음에 딱 불필요해 보이는 커다란 덩이들을 rough 하게 쳐낸다고 생각하면 된다. 그리고 그 계획에 따라 진행해나가다가 고려하지 못한 불명확한 부분이 있다면 명세의 내용을 세심하게 생각해보는 것이다.
- philosophers 의 philosophers_loop 에 state machine 을 적용하기에는 status 를 저장하는 변수도 기존에 따로 없고, 상태가 복잡한 것이 아니라 무조건 차례대로 바뀌기 때문에 적절하지 않다고 생각한다. 그냥 평범하게 작업을 순서대로 나열하는 것이 바람직해 보인다.
- race condition 이 발생하지 않도록 mutex 를 기술적으로 처리하는 코드가 삽입되면서 실제 원하는 작업이 가려져 가독성이 떨어지는 것 같다.

2021-12-10
- git stash pop == git stash apply && git stash drop
	- 만약 git stash apply 에서 conflict 가 발생하면 git stash drop 이 실행되지 않는다.
	- 출처: https://www.theserverside.com/video/How-to-easily-merge-and-resolve-git-stash-pop-conflicts
	- conflict 를 해결하고 git stash drop 을 하더라도 git stash 를 하려고 하면 '<path>: needs merge' 라는 문구가 출력되면서 실행되지 않는다.
		- 이 때 간단히 해당 파일을 git add 하고 다시 git stash 를 실행하면 제대로 수행된다.
- https://en.wikipedia.org/wiki/Lock_(computer_science)
	- coarse granularity: 굵직하게 mutex lock 을 거는 것, thread 가 적을수록 효율이 좋다. 당연히 mutex 가 겹칠 일이 적으니 lock overhead 를 줄이면 효율이 좋아진다.
	- fine granularity: 세세하게 mutex lock 을 거는 것, thread 가 많기 때문에 lock contention 을 줄여야 효율이 좋아진다.

2021-12-09
- 함수의 내부에서 사용하는 단어와 외부로 표출되는 단어가 다르다. 내부적으로 사용할 때는 굳이 해당 함수가 포함되는 구조체의 이름을 접두어로 붙일 필요도 없다.
- 행복한 완벽주의자가 되어라. 완벽주의 덕에 어떤 문제를 풀 때 여러 번 곱씹게 되지만, 스스로 원해서 그 문제를 완벽하게 푸는 것이기 때문에, 한 문제를 해결하는 과정에서 발생하는 수많은 의문과 작은 문제들을 추가적으로 맞닥뜨릴 때마다 새로운 특징과 기술을 학습하며, 이에 즐거움을 얻는다.

야곰맨토님 특강
	- 공유하라
		- 공유해서 그 내용이 다른 사람들에게 알려진다고 해도, 직접 내용을 작성한 사람과, 단순히 다른 사람이 작성한 내용을 보고 터득한 사람 간에는 깊이의 차이가 있다.
		- 공유를 할수록 내 특수성을 잃는 것이 아니고 기회가 많아지는 것이다.
	- 발표를 해보는 것은 공유하는 방법 중 훌륭한 방법이다.
	- 애매한 부분에서는 질문을 꼭 해야한다.
		- 의미 없는 삽질을 줄일 수 있다.
		- 사고치는 것 보다 질문을 하는 게 더 좋다.
		- 질문을 하지 않는 것 보다는 물음표 살인마가 되는 것이 좋다.
	- 작업의 목적이나 이유에 대해 이미 공유가 되어 있다고 착각을 하고 작업을 줄 수 있다. 왜 그 작업을 해야하는지 왜라는 질문을 통해 목적, 역사 등을 파악할 수 있다. 나아가 개선도 가능해진다!
	- 단순히 어떤 라이브러리를 조사해오라고만 해도 왜 조사해오라고하지? 라는 생각으로 질문한다면 조사 작업을 더 적합하게 진행할 수 있을 것이다!
	- 단
		- 같은 질문은 다시 하지 않는다.
		- 질문에 대한 배경 설명을 장황하지 않은 선에서 설명을 해야 한다.
			- 질문만 띡 던지지 말것!!
		- 쇠사슬은 이래서 좋고, 밧줄은 저래서 좋다고 하는데 어떻게 할까요?
			- 이 경우는 "아 이 친구가 내 의견도 존중해주는구나!" 라고 생각
			- 만약 그냥 쇠사슬이 좋다고 해서 쇠사슬로 만들었어요! 라고 한다면
				- 아니 누가 쇠사슬로 해도 된다고 허락했어?
	- 질문의 핵심은 존중과 배려이다
		- 내가 어떤 질문을 해야 상대가 더 명확한 대답을 해줄 수 있을까?

급변하는 세상에서 커리어란 <한기용>
- 급변하는 세상에서 전문성이란?
- 내가 가진 장점이 언젠가 단점이 되는 순간이 있다.
- 완벽주의자 -> 일의 경중을 따지지 않고 전부 열심히함 -> 오히려 단점
	- 중요하지 않은 것인데 필이 꽂히면 파고 든다.
	- 한 가지 해결 방법: 익숙한 것에서 벗어나보기
- 어떤 기술을 아느냐에 중요하지 않고, 결과를 내는 데 포커스를 하라
- 도메인에 따라 몸값이 달라진다
	- 물리학자 -> 데이터 과학자로 커리어 전환 (먹고 살기 위해서)
- 현재 일을 잘 하려고 하다보면 자신감이 생기게 된다.
- 요즘 세상의 전문성은 변화를 두려워하지 않는 것이다?
	- 자기 검열 안하기
		- non-동아시아권 -> 내가 승진하고 싶은데 내가 부족한게 뭐냐?
		- 동아시아권 -> 내가 열심히 해서 승진이 되길 바람
- 이력서 많이 넣기
	- 연락 오면 인터뷰 무조건 보기
		- 면접 보고 부족한거 보충해나가기
	- 가장 가고 싶은 곳은 마지막으로! (경험치 쌓고 도전)
	- 빨리 시작해서 발전해나가면 된다
	- 내 매니저가 누군지가 가장 중요하다!
		- nice 보다
		- 명확한가 피드백을 주는가, 윤리적인, 회사내 힘이 있는 사람
			- 나중에 그 사람이 가는 회사를 따라가면 된다.
	- 면접관들이 물어보는 거에만 답하지 말고 나도 많이 물어봐야한다 취직 후 3 달 간 무엇을 하는지?, 이 회사에서는 일을 잘하는 사람들의 특징이 무엇인가?
	- 면접관들의 질문을 통해, "아 내가 이런 쪽은 아예 모르는구나" 라는 것을 알수 있다
- 회사가 성장하면 내가 성장할 확률이 높다.
	- 회사가 성장하면 일하는 모두가 기분이 좋다.
	- 회사의 문화는 어떠한가?
- one way door vs two way door
	- two way door 라고 생각이 되면 일단 저지르고 본다
- scalar 가 중요한게 아니라 vector 가 중요하다
	- value 보다는 delta
- 매니저 입장에서 주니어의 무엇을 보는가? 가능성, 영향력, 긍정적
	- 얼마나 절실하고 얼마나 체계적으로 접근하는가?
- 시작할 때의 마음가짐
	- 처음 90 일이 가장 중요하다(첫인상)
		- 뭔가 하나라도 이뤄내기
		- 과거 상처어 얽매이지 말기
		- 일을 너무 열심히 할 필요는 없다
	-  새로운 기술의 습득이 아닌 결과를 내는데 초점 맞추기
- 공부를 위한 공부를 하기 보다는 일을 시작해보기
	- 남과 비교하지 말기
		- 어제의 나와 오늘의 나를 비교하라!
	- support network 가 있으면 좋다
		- 무조건적인 지지를 해주는
		- 딴지를 거는 것이 아니라, 만나고 나면 기분이 좋지 않는 경우, 사람들이 나를 서포트 해주지 않고 비판을 할 때
- 나의 장점이라고 생각했던 면이 나의 컴폴트 존이었고, 그로 인해 새로운 시도를 하지 못해 성장을 저해할 수 있다

설명
~해(주장) -> 되면 이렇게 안되면 이렇게(근거)

카카오 애자일
티켓에는 완성된 라면 한 그릇
이건 분업화 할 필요가 없다!
레스토랑에서 주문을 받을 때도 티켓에 하나의 음식 메뉴가 들어와도 여러 요리사가 완성된 하나의 음식을 만들어 낼 수 있다
만들려고 하는 대상에 대한 목표가 공유되어 있고 그것을 어떻게 구현해야 할까? 를 같이 고민하고 일을 나눠야만 한다! 그렇지 않으면 단순히 일 나누기가 되고, 각 나눠진 일 간에 디펜던시가 없을 수 없기 때문에 문제가 발생한다
숲을 구현할 때 숲에서 나뭇잎까지 구성원 모두가 파악할 수 있어야 한다.
충돌을 처음에 회피한다고 해도 나중 가서는 터지기 마련이다
한 프로젝트가 끝날 때 성공 또는 실패에 대한 이유를 객관적으로 생각해봐야 한다.
회고를 하기 위해서는 계획이 있어야 한다.
그렇지 않으면 단순한 감상적인 느낌만 나눌 수 있다.
궁극적인 목표를 위해 달리는 것보다 그 과정에 행위를 하면서 거기에 만족을 해버리는 것은 좋지 않다.
나뭇잎 하나하나 보면서 거기에 매몰되지 말고 숲을 향해 전진해야한다
일은 하고 있는데 전체적인 일이 어떻게 진행되고 있는지 모른다면 문제가 생길 것이다.
결과물, 미치는 영향, 리팩토링도 달라지게 된다.
축구 팀과 같다, 혼자 잘하는 것이 아니라 전략을 선수들이 모두 이해해야 한다.
넛지도 잘 하도록 하자. 일일이 참견하는 것이 아니라, 상대가 자신의 문제를 이해할 수 있도록 하는 질문을 잘 던져주는 것이 중요하다
매일 진행과정을 한 번씩 얘기를 나누는 것이 좋다 -> 데일리 미팅
아이데이션하는 프로젝트는 에자일을 적용할 필요가 없다.
축구 선수로서 기초 역량을 먼저 키우는 데에 집중하라
나는 이걸 이렇게 했는데 너한테도 이거 이렇게 좋다? 어때 좋아?
CI/CD 버튼 한번 누르면 사내 앱스토어에 배포되고 이렇게 테스트 할 수 있어~
새로운 급박한 일이 들어온다고 해도, 당장 하고 있던 일은 마무리 하고 넘어가야 한다.
중간 산출물들이 무엇이 될지, 언제까지 만들까? 이런 중간 산출물들을 만들려면 무엇이 필요해?
이걸 문서화해 놓고 모두가 볼 수 있는 곳에 놔야 한다.
코드의 문제는 얘기를 나누되, 너 왜 이렇게 짰어? 가 되면 싸우자는 것이 된다.
계획할 것 계획하고 회고하는 것이 가장 중요하다.
스프린트를 달리면서 힘조절을 계속 잘 조절해서 하라.
기본기가 충실해야 한다. 나의 무기 하나는 있으면 좋다. 왜 라는 질문을 던져라, 더 낫은 방법은 언제나 존재한다는 사실을 기억하자.

2021-12-08
- 소리의 착시를 이용해서 oni 에서 무한히 올라가는 음을 표현했다면, 색의 착시를 이용해서 무한히 어두워지는 색이나 무한히 밝아지는 색을 표현할 수 있을 것 같다
- <S-I> or <S_A> in visual block mode: insert text at the beginning of visual block of each line
- :'< or :'> in visual mode: the number of star or end line of block range
- :norm <commands>: Execute normal mode commands. <commands> are execute like they are typed.
- :let @a="" | g/<pattern>/y A: yank all line including <pattern>
- 이런 애니메이션 효과가 있으면 좋겠다. 전체 지도를 보다가 특정 지역을 자세히 보고 싶을 때가 있다. 이 때 화면 자체를 새로 만드는 것이 아니라 전체 지도에서 해당 지역이 줌 인 되는데, 이 때 피로도를 줄이기 위해 0.1s 정도 동안 전체 alpha 를  0.2 정도로 fade out 하고 0.1s 정도 동안 zoom in 하고 다시 0.1s 정도 동안 fade in 하는 것이다. 전체 지도로 돌아가는 것은 이 역순으로. 이 때 zoom 은 bazier 함수를 적용하여 둥글둥글한 s 곡선 느낌으로 처리한다. fade 는 선형으로
- 에측 가능성은 중요하다. 코드의 한 줄을 80 자로 제한해 한 줄 한 줄을 구분 가능하게 만들어 예측 가능하게 하고, 함수들의 크기를 25 줄 정도로 비슷하게 유지해서 한 함수를 예측 가능하게 하고, 한 파일에 함수를 5 개로 제한하 한 파일의 크기를 예측 가능하게 하는 것이 좋다. 한 디렉토리도 파일 갯수를 제한해서 예측 가능하게 하는 것이 좋을 수 있다. identifier 들에 특별한 규칙을 지니게 해서 어떤 곳에서 어떤 의미로 사용되는지 예측 가능하게 하고, 또 함수의 의치, 변수의 위치, 상수의 위치를 구체적으로 제한해 예측 가능하게 하는 것이 좋다. 어떤 특정 값을 찾으려면 어떤 파일의 어디를 가면 되겠구나가 보일 것이고, 어떤 위치의 어떤 상수를 보았을 때 어떤 역할에 사용되겠구나가 보일 것이다.
- define 이든지 enum 안에 정의된 constant 든지, constant 를 정의하기 전에 사용하면 compile step 에서 undeclared identifier error 가 발생하면서 진행되지 않는다.
- .w! >> <path>: write current line to the end of <path> file
- |usr_27.txt|
- /<pattern>/[be]+<number>: search <pattern> and jump to next <number> character from [end or begin] of a matching
- /\(ab\)*: search "", ab, abab, ababab...
- /a\+: If you want to avoid searching empty string, use '+' rather than '*'.
- /a\=: search 'a' as optional, so "" and "a"
- /a\{3,5}: Search only specific(3 <= x <= 5) number of repeat pattern
- /a\{3}
- 코드를 수정하는 것과 코드를 작성하는 일은 하는 것이 다른다.
- 코드를 작성하는 일은 함수의 작동 방식을 정의하고, 필요한 모듈 목록을 만들고, 함수 및 모듈을 작성하는 것이다.
- 코드를 수정하는 것은 이미 이 모든 것이 이루어져 있기 때문에 함수의 작동 방식 및 모듈들이 이미 문서로 존재할 것이고, 문서를 읽으면서 해당 함수가 문서에 따라 잘 작동하도록 버그 등을 수정해주면 되는 것이다.
- 즉, 일반적으로는 함수를 새로 작성하는 것 보다 이미 작성된 함수를 수정하는 일이 더 쉽다.
- 연산 결과가 포인터를 의미해야 할 때는 포인터를 operand 로 하는 포인터 연산을 하고, 결과가 배열의 index 번째 element 를 의미해야 하는 경우에는 [] 를 사용한 subscript 연산을 사용하도록 하자

2021-12-07
- _init()을 실행하고 나면 해당 오브젝트를 바로 사용 가능하도록, 모든 property 에 적절한 값을 넣어 주도록 하자.
- sleep()과 마찬가지로 mutex_lock()도 때가 되었다고 바로 block 이 풀리는 것이 아니라 그 짧은 순간에 다른 thread 가 먼저 lock 을 걸어버리면 기존에 기다리던 thread 가 작동하기 전에 치고 들어온 thread 가 성공적으로 lock 을 걸면서 실행된다.
- 정리좀 하고 살자,, 메모랑 여기 pour 에 아마 엄청 다양한 생각들이 담겨 있을 텐데, 이거 나중에 어디에 나가서 발표라도 하려고 하면, 정리를 하지 못해 평소 하고 있던 생각을 제대로 발표할 수 없을 것이다.
- pthread_mutex 가 FIFO 가 아닌 것은 알았다. 그럼 다음으로 드는 생각이, FIFO 가 아니어도 그게 발생할 일이 thread 200 이하에서는 발생하지 않기 때문에 그냥 지나칠 것인지, 아니면 그럼에도 불구하고 정말 절묘한 타이밍에 FIFO 가 아니어서 발생하는 문제가 존재할 수 있기 때문에, 순서대로 write 하는 추가적인 처리를 하는 것이 맞을지 궁금할 수 있다.
	- 이 경우 나라면 먼저 FIFO 가 아니어서 발생할 수 있는 문제를 떠안고 프로그램을 작성하는 것이 무척 불편한 상황이기 때문에, 이를 어떻게 해결할 수 있을까 스스로 생각해본다. 지금 내가 할 수 있는 것으로부터 이 문제를 해결할 수 있는가를 생각해본다. 그리고 불가능하다면 무엇이 더 있어야 이 문제를 해결할 수 있을지 찾아본다. 그리고 해결책이 없다면 슬랙에 질문을 올려볼 것이다. 그렇게 해서 그나마 문제를 해결할 수 있는 방법을 발견했을 때, 만약 그 해결방법이 여러 이유로 마음에 들지 않거나, 적용에 투자하는 시간에 비해 얻는 것이 적다고 판단되면 과감히 버린다. 하지만 꼭 필요하거나, 불가능을 가능으로 만들어주는 부류의 내용이라면 가능하면 해보고 지나간다.
		- 이런 내용을 누군가에게 전달하는 것은 어떤 문제를 맞닥뜨렸을 때 그 문제를 해결하는 포괄적인 관점을 제공할 수 있다. 즉 물고기를 주는 것이 아니라 물고기 잡는 법을 알려주는 셈이다. 하지만 내가 얻은 것은 물고기 뿐만 아니라 물고기 잡는 법 뿐만 아니라 물고기 잡는 방법을 만들거나 알아내는 방법을 얻은 것이다. 즉, 직접 부딪혀서 문제를 해결법(물고기)을 찾아내는 방식(잡는 법)을 스스로만의 방법으로 개척해나가는 것(물고기 잡는 방법을 만들거나 알아내는 방법)은 물고기 잡는 방법을 알려주는 것만으로는 전달될 수 없다.
		- 다만 물고기 잡는 방법을 알려주면 다른 물고기 잡는 방법을 알아내기 위해 더 노력할 수도 있다. 혹은 반대로 앞으로도 물고기 잡는 방법을 직접 터득해나가지 않고 누군가에게 물어보는 수준에 머무르게 될 지도 모른다. 그것은 그 삶이 살아온 과거 성향을 통해 판가름날 것이다.

2021-12-06
- :ter[minal]: open terminal in vim
- ^: jump to the first not white space character of the line
- g_: jump to the last not white space character of the line
- <C-T> in insert mode: indent
- <C-D> in insert mode: unindent
- <C-N>, <C-P> in insert mode: 다음, 이전 단어 자동 완성
- gJ: 추가 공백 없이 행 연결
- o in visual mode: jump another end of the selected range
- O in visual block mode: jump another end of selected block
- u, U in visual mode: to lower case or upper case
- `., '.: jump to last edit
- ==: auto align
- cn, cp: vimgrep 으로 search 한 목록의 다음, 이전 item 으로 jump
- cope[n], ccl[ose]: search 한 item 목록을 list 하는 분할 창 띄우기, 닫기
- <C-W>x: 두 창의 위치 swap

2021-12-05
- 기본적으로 overflow 는 instruction 을 오용하는 방법이다. 그런데 unsigned int 의 경우 6.2.6.1:3 에 의해 overflow 이후의 값이 보장되고 signed int 는 undefined 로 정의된다
	- 6.2.5:9 도 참고
- thread 가 호출한 함수의 local variable 을 사용하여 값을 변경할 때, thread 보다 호출한 함수가 먼저 종료된다면, 이후 stack 에 다른 함수가 이 공간을 사용할 수 있기 때문에 thread 가 인자로 받은 변수의 값을 바꾸게 되면 엉뚱한 중요한 값이 바뀔 수 있다. -> segmentation fault 등 다양한 종류의 에러를 만날 수 있다.
- sleep()의 특징
	- thread 의 수가 많아지면 초반에 thread 를 생성하느라 자원을 많이 소모하는데, 이 때 실행한 sleep 은 말도 안되는 수준으로 오래 걸릴 수 있다.
		- 1000us 를 sleep 했는데 162466us 가 걸린다거나!
- sleep()에 대한 생각을 정리하고 나서 philosopher 프로그램으로 돌아와보니, 어디까지 작성했었는지 알 수가 없게 되버렸다.

2021-12-04
- 오늘은 벌써 토요일이다. 나의 일상을 전부 기록할 수 있는 것이 있으면 좋겠다. 그러면 다양한 정보가 나올 것이고, 그 정보를 바탕으로 다양한 개념 모델을 만들어볼 수 있을 텐데. 가령, 잠에 대한 개념 모델 같은 것 말이다.
- philosophers 에서 sleep()을 예측하여 실행하는 방법은 썩 마음에 들지 않는다.
	1. 제대로 예측하지 못하는 경우에 대한 에러를 결국 해결하지 못한다.
	2. 모든 philosopher 들이 sleep()을 호출하는데, 이에 따라 두 가지 구현이 가능할 것이다.
		1. 모든 philosopher 가 공유하는 공간에 예측을 위한 과거 데이터를 두고 사용한다.
			이 경우 이 예측을 위한 과거 데이터는 mutex 로 lock 을 해야 할 텐데, 성능 손실이 클 것 같다.
		1. 각 philosopher 마다 sleep 예측을 위한 이전 데이터를 저장하도록 한다.
			이 경우 예측을 위한 데이터 양이 적어지기 때문에 오차가 커질 것 같다.
- 컴파일과 링크 과정에서는 현재 파일에 있는 header file 은 따로 include option 을 주지 않아도 알아서 탐색하는 것 같다.
	- gcc main.c -> 같은 directory 의 .h 파일을 알아서 찾음
	- 하지만 '.o' file 을 생성하기 위해 'gcc -c' 에서 '.h' 파일을 탐색할 때는 해당 source 파일의 위치를 중심으로 상대 주소로 탐색한다.
- playground 에서 실험을 진행한 후에는 꼭 결과를 주석으로 남겨두도록 하자. 어떤 결과가 있었는지 확인하기 위해 다시 테스트를 진행해야 하는 불편함이 있다.
- playground 에서 작성한 예제에 대한 설명을 커밋을 사용하여 변화마다 주석을 달아줄 수 있는데, 이 경우 주석의 설명을 보기 위해 각 커밋에 checkout 해야 하므로 불편하다. 따라서 이럴 경우 각 커밋의 주석 설명을 동시에 Readme.md 등의 파일에도 똑같이 기록하여 파악하기 쉽도록 하자. 자세한 내용을 보고 싶으면 그 때 가서 checkout 하면 되니까
- 겨울은 눈이 부시다. 해가 낮게 떠서 여름에 비해 시야에 해가 들어온다
- 만약 그런거(드론의 속도, 가속도 센서 값 등 다차 방정식 꼴의 데이터)라면 몰라도 sleep()은 system 에서 자체적으로 구현한 함수이기 때문에 걸리는 시간을 예측하는 것이 결국 오차가 클 수밖에 없다. (다차 방정식 꼴이 아니다) 그러므로 그냥 내 방식을 사용하도록 하자!
	- 그러므로 쓰레드의 갯수와 sleep 시간에 따른 평균 delay 를 이용하되, 크게 벗어난 값은 제외하는 방식으로 적용해보자!
- local variable 로 선언한 변수의 주소를 thread 의 인자로 넘겨주어 thread 가 dereferencing 하여 사용하는 경우, thread 의 종료를 확인하지 않고 main() 함수를 종료하게 되면, 끝나지 않고 작동중인 thread 가 free 된 stack 영역을 접근하여 segmentation fault 에러가 날 수 있나?
	- 그런 문제 때문에 segmentation fault 가 발생하지는 않는 것 같다. 내가 맞딱뜨린 segmentation fault 는 아래와 같은 이유로 발생했던 것이었다.
- int 가 overflow 하는 것은 UB 이고, unsigned int 가 overflow 하는 것은 UB 가 아니다?
	- https://stackoverflow.com/questions/59080105/illegal-hardware-instruction-from-very-simple-code

2021-12-03
- 테라리아 문로드를 잡았다. 그리고 다양한 유튜브 영상도 보았다.

2021-11-23
- 개념을 모듈화하면 모듈들을 사용해 더 거시적이고 재밌는 것들을 할 수 있다.

2021-11-18
- 무언가를 알아가고 마스터해가는 과정
	- 1. 필요성을 이해한다
	- 2. interface 를 이해한다
	- 3. implementation 을 이해한다
	- 4. 직접 만들어본다.(추상적인 구현에서 시작하여 점점 구체적으로)
- 4 frame 이 반복되도록 만들고 3 개의 image 를 1, 1, 2 frame 씩 설정해주면 꽤 흥미로운 그래픽이지 않을까?
	- 이런 식으로 음악의 규칙을 그래픽에 적용하는 것은 어떨까?
- 함수를 정의할 때 argument type 을 명시해준다. 그러면 caller 가 해당 argument type 의 값을 사용하여 함수를 호출하게 된다. 

2021-11-17
- 작동 설명 은 2 가지 관점으로 작성하면 좋다. 전체적인 관점과 내부적인 관점이다. 이는 마치 argument 와 parameter 의 label 을 각각 두는 것과 같다.
	- 즉 실 사용을 아는 것도 좋지만, 내부 동작을 아는 것도 좋다. 하지만 내부 동작에 대한 설명은 찾기 힘든 부분이 있다.
- 인자로 전달할 일이 많은 배열 데이터는 null terminated 하게 만드는 것이 좋다.
- 직접 내부 값을 변경하는 경우가 많은 배열 데이터는 시작과 끝의 주소를 저장하도록 하자.
- 실행 순서대로 서술되지 않은 코드는 이해하기가 끔찍하다. 가능하면 실행 순서대로 서술하도록 하자.
- 기능을 무작정 코드로 작성해나가기 보다는, 먼저 실제 언어로 서술해 보는 것이 도움이 된다.
	- 각 행위를 명명하는 단어를 끄집어내는 데 도움이 된다.
	- 큰 흐름을 잡는데 도움이 된다.
- 가능하면 바로 세밀한 부분을 서술하기 보다는 크게 크게 덩어리를 잘 나누도록 로직을 짜면서 서술해보자.
- local repository, wording directory
- recommand book: pro git
- binary large object
	- add 를 하면 blob 형태로 stage 에 올라간다.
	- git hash-object <file>: checksum 을 보여준다
		- 내용이 같으면 hash 값이 같다(메타 정보는 사용하지 않음)
	- tree .git: cli command
- 파일이 어떤 파일인지 보는거 어떤 명령어였더라?
- git add 시에 .git/ 에 파일이 저장된다.

- git cat-file -t <hash>: type 을 알려준다.
- git cat-file <type> <hash>: hash 파일을 type 으로 해석한 정보를 출력한다.

- git ls-files --stage: stage 를 출력해준다.

- git ls-tree <hash>: tree 의 내용을 읽기 좋게 보여준다.
- 이런 명령들을 메타 명령이라고 한다.

- git add: 대상 파일을 위한 blob 을 생성한다.
- git commit: 새로운 commit 을 위한 tree 와 commit 을 생성한다.

- git hash-object <file>: file 의 hash value 를 출력한다.
- git write-tree: stage 를 가지고 새로운 tree 를 만든다.
- echo "22" | git commit-tree <hash of tree> -p <hash of parent commit>
- git rm --cached <path>

#define STATE_NORMAL                    0
#define STATE_ENCOUNT_SLASH             1
#define STATE_IN_MULTI_LINE_COMMENT     2
#define STATE_ENCOUNT_ASTERISK          3
#define STATE_IN_SINGLE_QUOTE           4
#define STATE_IN_SINGLE_QUOTE_BACKSLASH 5
#define STATE_IN_DOUBLE_QUOTE           6
#define STATE_IN_DOUBLE_QUOTE_BACKSLASH 7

- 이런식으로 각 상수를 define 하는 것이 아니라 enum 을 사용한다면, 사이 사이에 새로운 constant 가 추가된다고 하더라도 아래의 숫자가 밀리지 않는 장점이 있다.!

2021-11-16
- c 에서는 데이터와 메타 데이터가 짝으로 활동하는 경우가 종종 있다.
	- array 와 array size: array 에 접근할 때 array 의 끝을 위한 메타 데이터가 함께한다
	- string 과 null character: string 을 다룰 때 string 의 끝을 표시하기 위해 null character 를 사용한다.
	- 이런 식의 pair 는 어떤 데이터를 표현할 때 반듯이 함께 다루어져야 한다. 만약 어느 하나를 생략한다면 데이터의 명시가 불명확해지기 때문에, 데이터의 범위를 제대로 표현하지 못하거나 데이터의 값을 제대로 표현하지 못하는 문제가 발생한다.
- 간단한 작동은 간단하게 만든다. 복잡한 작동은 통일화되도록 작성하여 가독성을 더 중시한다.
	- 작은 코드는 이해하기 어렵지 않다. 하지만 크기가 큰 코드는 이해하기 힘들기 때문에 오버헤드가 생기더라도 규격화된 형식을 따라 작성하는 것이 좋다.
- 어떤 source code 에서 source code 밖에 어떤 변수가 정의되어 있다고 가정하고 그 변수를 사용할 때 extern specifier 를 사용한다.
	- 하지만 컴파일 또는 링크 시에는 해당 변수가 포함된 source 파일을 포함해야 할지도 모른다.

2021-11-03
- 장점을 살리는 방법: 추가 구현 없이 base 의 특성으로 대체 가능한 경우
- 적절한 타협: 완전 무시하지는 않으나, base 가 제품 자체가 되지는 않음
- 특성을 무시하는 방법: base 에 얽매이지 않고 general 한 구현

2021-11-01
- 값을 변환할 때는 실패할 수도 있는데 메모리 관련으로 실패하면 어차피 exit()을 할 것이니 파싱에 대한 성공 실패 여부만 return 하면 된다
- value type 은 NULL 이 인자로 들어와도 빈 data 를 할당하여 반환하고, 그 외에는 NULL 인자에 대해 NULL 을 반환한다
- 즉, value type 은 non-optional 을 반환하고, 그 외에는 optional 을 반환한다
- exit()이 불가능한 환경에서는 _new()를 만들지 말고 _init() 까지만 만들자
	- _new()의 return 값으로 NULL 을 반환할 때 _init 의 실패만을 의미할 수 있다

2021-10-31
- write()를 쓰는 프로그램에서는 가급적 printf()를 사용하지 말자
- static 함수는 무조건 나만 호출하므로 내부에서 인자의 NULL 여부를 체크하지 않고, 호출하는 함수가 체크하도록 한다
	- 호출하는 함수는 어차피 특정 값이 NULL 등일 때 반환하도록 로직을 작성해야하기 때문에 최소한 callee 에서의 guard 를 줄일 수 있는 것이다
- 오늘 lmt_c_library 에서 exit()을 제거하기 위해 노력했었다. 그런데 exit()을 없애자 전체적인 코드의 가독성이 급격히 하락하는 큰 문제가 발생했다. 에러를 반환하고 이 값을 확인하기 위해 코드가 과하게 들어가다 보니 실제 실행에 필요한 로직을 읽기가 불편해졌다.

2021-10-30
- cherry-pick 은 delta 를 HEAD 에 적용하는 것이다
- malloc 을 _alloc()에서 NULL 을 체크하여 exit()을 호출하는 것은 좋지 않은 방식일까?
	- 만약 지금같이 작은 프로젝트가 아니라 더 큰 프로젝트의 모듈을 만든다면 exit()을 할 일이 결코 없을 것이다. 에러가 발생하면 에러를 검사한 후 적절한 처리를 하여 반환하는 로직이 대다수 일 것이다. 그러니 무작정 exit 하는 코드를 작성하기 보다는 오류를 잘 처리하고 반환하는 방식으로 코딩을 미리미리 연습해두자

2021-10-28
- iterator 등의 protocol 을 따르는 경우, structure 를 생성할 때 미리 그 protocol 을 위한 공간을 memory 에 같이 할당하면 좋겠다. 비록 무의미한 메모리는 많이 차지할 수 있겠지만, 속도는 조금 빨라질 것 같다.
	- 즉, lazy type 은 메모리를 적게 먹는 대신 할당을 위해 시간이 더 걸릴 것이고, early type 은 메모리를 더 많이 먹지만 메모리 할당을 위한 런타임 시간이 줄어들 것이다. 초기 할당에는 근소하게 시간이 더 걸릴 수 있다.
- vim <(cat $(find . -name "*.[ch]") | grep -v "/\*")
	- 현재 directory 안의 파일 중 source file 들을 42header 를 제외한 코드를 vim 으로 실행하는 command

2021-10-27
- 띠용, function prototype 에 void 를 명시해주지 않으면 그 함수를 사용할 때 인자를 넣어줘도 오류를 발생시키지 않네?
	- 인자를 받지 않는 함수의 prototype 에는 반드시 void 를 명시해주도록 하자
- 함수가 개인적으로 동작할 때 segfault 가 발생하는 상황이 존재하는 것은 좋지 않다

2021-10-26
- 어제 main 에서 return 시에 segfault 가 생기는 현상은 not_builtin_cmd()를 1 번 호출하면 문제가 없었는데, non_builtin command 인지 체크하기 위해 여러번 호출해서 생기는 문제였다.
- const 를 적지 않으니 해당 포인터의 내부 변수를 바꾸는지 확신하기가 힘들다.
	- const 는 대박이다!
- 와 진짜 이건 몰랐다!
	- child process 에서 누수가 나고 있었다!
	- should_execute_on_child()가 child process 에서 실행 중이었는데, 여기서 호출하는 not_builtin_cmd 가 누수가 나고 있었을 것 같다
	- 그래서 lldb 로 parent process 에서 leak 을 체크해도 leak 이 나지 않았던 것이다.
	- 그 원인으로 인해 이번 문제인 main 문의 return 시 segfault 가 발생한 것 같다
	- 아니다 leak 은 없었다.. 코드를 읽었을 때는 있을 것 같았는데..
	- 잘은 모르겠지만 parent process 에서 not_builtin_cmd()를 호출했을 때 동일한 문제가 발생하는 것을 확인하였다.

2021-10-25
- 프로젝트가 커짐에 따라 모듈화를 잘 해둬야 '버그를 잡기 쉬워진다'.
	- 모듈화가 잘 되지 않은 경우, 버그가 어디서 난 것인지 확인하기 힘들어진다.
		- 모듈화가 잘 되지 않았다는 뜻은, 전역 변수를 쓰는 것처럼, 수많은 많은 함수에 공통적인 인자로 들어가는 변수가 존재한다는 것이고, 따라서 이 변수가 어디서 변한 것인지 파악해야하는 일거리가 발생한다.
- service provider 가 정지해도 intranet 은 동작하네??
- debug 용 소스 코드를 분리해서 make 할 때 포함할지만 결정해주면 되겠네?
	- 컴파일 시에 'make debug' 로 make 하면 define <file_name> 을 해서 컴파일을 막는다던가?!
- 에러 체크의 흐름에 따라 장기 유지보수 가능한 코드
	- 새로운 에러 체크 작업을 간단히 추가할 수 있도록
- 오늘 알 수 없는 문제와 마주했다.
	- main()이 return 할 때 segfault 가 발생하는 문제
		- minishell 프로그램에서 외부 함수를 호출한 후 이 segfault 가 발생한다
	- child process 를 실행한 후 wait 을 하는데 -1 이 반환되는 문제가 있었다.
		- 아마 그러면 제대로 wait 을 실행하지 못한 채 프로그램이 종료되었을 것이다.
		- 하지만 이전 커밋에서도 그런 문제를 그대로 가지고 있는 채로도 segfault 가 뜨지 않았었다.
		- 따라서 다른 system call 에서 비슷한 문제가 발생했을 것이고, 그 에러가 제대로 처리되지 않아 main()의 return 시 segfault 를 발생시켰을 것 같다.
		- 왜냐하면 항상 main 의 retun 에서 segfault 가 날 때는 동시에 waitpid 가 -1 을 반환했기 때문이다.
		- 왜 한번에 모든 system_call 들이 interupt error 를 발생시키는 지는 모르겠지만, 그로 인해 발생한 segfault 일 것 같다
		- 직접 signal 을 찍어보니 waitpid 가 -1 을 return 할 때 아무런 signal 이 찍히지 않았다.
		- 즉, waitpid 는 signal 에 의해 -1 을 return 한 것이 아니었다!
		- 그래서 생각해볼 수 있는 가능성은, 아직 자식 process 가 제대로 생성되지 않았는데 waitpid 를 호출했을 가능성?
		- 그런데 fork 로 이미 pid 를 반환받았는데 그럴 수가 있나?
		- 그런데 waitpid 가 -1 을 return 한 후 perror()를 호출하면 'Interrupted system call' 가 뜬다.
		- 즉, system call 에 의해 interrupt 된 것은 맞는 것 같다
		- lldb 의 특성이 한 몫 했다.
		- signal()로 signal 이 특정 함수를 호출하도록 설정해도, lldb 안에서 실행할 때는 signal 이 적용되 버린다!
		- 따라서 모든 signal 에 대해 해당 signal 의 number 를 출력하는 함수를 호출하도록 signal()을 호출해서 설정해 두었더라도 lldb 안에서 실행할 때는 이 custom signal function 이 작동하지 않게 되었던 것이다!
		- 왠지.. lldb 안에서 segfault 가 더 많이 뜨더라..
		- 이로 인해 main 의 return 에서 segfault 가 system call 이 signal 로 인해 interupt 되었을 때 오작동으로 인한 문제라는 것에 무게가 더 실렸다
		- 결국 최후의 방법으로,, 하나씩 지울만한 함수를 주석 처리해가며 컴파일, 실행을 반복하고 있다.
		- 그 결과 should_execute_on_child()라는 함수의 유무로 segfault 가 나고 안나고가 결정된다는 사실을 알게 되었다.
- 프로그램을 많이 수정한 후 에러와 마주하면 상당히 난감해진다.
	- 반드시 조금씩 바꿔나가자!!!

2021-10-24
- 어떤 의도를 가지고 코드를 작성할 때, 의도에 의해 설정하는 규칙이 존재한다.
	- 이 때, 어떤 분기를 나눌 조건문을 작성한다면, 의도를 표현해야 읽기 좋다. 조건문에 규칙을 표현하지 말자.
- should_process_execute_on_child()와 prev_or_current_process_op_is_pipe()는 같은 역할을 수행하는 함수를 의미할 수 있다.
	- 즉 '이전 혹은 현재 프로세스의 op 가 pipe 일 때, 자식 프로세스를 만들어서 실행해라' 라고 하고 싶은 것이다.
	- 이 때 전자는 caller 에서 문맥상 읽기 쉬운 이름이고, 후자는 함수의 정의문에서 함수의 행동을 뚜렷하게 설명해주는 이름이다.
	- 함수를 설명하는 이름보다는 caller 에서 읽기 좋은 이름을 사용하자.
	- 후에 '그래서 언제 자식 프로세스에서 실행하는 건데?' 라는 의문이 든다면, 그 함수로 이동해 정의를 보려 할 것이고, 이 때 상단에 주석이라도 달아 놓아 이해를 돕도록 하자.
	- 즉, caller 에 적합한 이름은 주석 등으로 추가 설명을 달기 힘들지만 함수 정의를 위한 이름은 주석 등으로 추가 설명을 달기 쉽기 때문에 정보를 넣기 힘든 caller 를 위한 이름을 설정하는 것이다.
- case 에 벗어난 경우 오작동을 막기 위해 assertion 을 사용하고, 없으면 crash 를 내서 종료시키자.
- mandatory 와 bonus 를 분리시키는 것이 좋을까? 분리하라니까 분리하자!
- 말을 너무 빠르게 하지 말자, 상대를 당황시키게 만든다
	- 조근조근 천천히 말해야 상대방이 excite 하지 않고 이성적으로 받아들일 것이다.
	- 내가 excite 해서 빠르고 높은 톤으로 말을 하는 것은 안좋은 행동이다.
- issue 를 마구마구 날리고 나중에 같이, 혹은 인증된 사람이 검증을 쭉 하는 것도 좋겠다.
- 압박받는 듯한 느낌을 주는 것은 좋지 않다. 편안하고 편안하게 하자.

2021-10-23
- 프로그램 소스 코드는 1 차원적이다.(위, 아래의 선형 구조)
	- 때문에 이를 2 차원 이상으로 표현하여 정리하면 구조를 설계하고 이해할 때 도움이 된다. (공책 등에 구조를 정리해보기 == 2차원적)

2021-10-21
- structure 에 새로운 member variable 을 추가하면 바꿔야 할 것이 많아지는 경우가 있다.
- 가령 single linked list 를 double linked list 로 변경할 때, 새롭게 prev node 를 가리키는 member variable 이 추가될 것인데, 이 때 기존에 만들어 두었던, insert, append, remove 등의 element 추가 제거 함수에 코드를 추가해야 할 것이다. 이 때 무작정 생각나는, 보이는 부분부터 바꿔나가기 보다는, 바꿀 대상을 적당히 적어놓고 순차적으로 바꿔나가도록 하자. 생각대로 바꾸다보면 반드시 놓치는 부분이 생긴다. 만약 목록을 작성하고 바꿔나가는 중에 더 바꿔야 할 부분이 보인다면, 당장 바꾸는 것이 아니라!! 목록을 수정하고 순차적으로 바꿔나가자!
- man page 처럼 설명을 하면 될 것 같다. 설명을 할 때 대상이 무엇을 할 수 있는지 가능한 것을 먼저 제시해준다. 가령, "코드가 보고 싶으면 어떤 코드 보여달라고 얘기하고, 그림으로 그려달라고 하면 그려줄께!" 라는 얘기를 통해 상대방이 어떤 행동을 취하는 것이 허용되는지 알려주도록 한다.
- '_alloc': 메모리 할당
- '_init': shallow set
- '_set': deep set
- 데이터의 구조를 하나로 뭉치지 않고, 재귀적으로 작동하는 함수가 일부를 차지하도록 하면 데이터가 단절되어 서로 간의 접근이 불가능해진다. 만약 모든 데이터가 서로를 찾을 수 있게 하려면 하나의 뭉쳐진 구조로 모델링하라!

2021-10-20
- ps -o pid,ppid,pgid,tty,comm
- pgid 는 어떤 값으로 설정되는 것일까?
	- sleep 1000 | sleep 1000 을 실행하면 새로 생성된 두 자식 process 는 첫 프로세스의 pid 를 pgid 로 갖는다. 왜그럴까? 그리고 이런 특성하에서 wait4(0,,,)는 caller 의 pgid 와 같은 child process 가 exit 하는 것을 기다린다고 하는데, 생성된 자식 프로세스는 왜 parent process 와 pgid 가 다른 것일까?

2021-10-19
- 주 작업이 무엇인지 확실히 하라
	- 주된 작업이 아니라면 비효율적이더라도 유지보수가 편한 방법 및 읽기 쉬운 방법, 그리고 생산성이 높은 방법을 선택하라!
- 시간이 남고 할게 없으면 이전에 만든 코드를 유지보수 하는 것은 어떨까?
	- 특히 variabledText!
- 계획을 변경했다면, 왜 계획을 변경한 것인지, 전과 후의 장단점은 무엇인지를 꼭 꼭 꼭 기록해두도록 하자.

2021-10-14
- 내부적으로 반환에 사용하는 ERROR, NORMAL 과, program 이 반환하는 ERROR_CODE, NORMAL_CODE 를 분리하여 사용하면 좋겠다.
- find . -not -path "./.git*" | grep "\.o"
- child process 가 exit 을 하지 않으면 그 뒤의 코드가 끝날 때까지 계속 실행된다
- 한 파일에 사용하지 않더라도 함수를 정의하면, 컴파일된 파일의 크기가 변한다.
	- 해당 함수의 어셈블리 코드가 실행 파일에 추가된다.
- 하지만 include 했던 stddef 를 stdlib 로 바꾸거나, include 하지 않도록 수정해도, 생성된 실행파일의 크기는 변하지 않았다.
- 아마 stddef 나 stdlib 는 함수의 정의를 담고 있지 않고, 단순히 prototype 만을 담고 있기 때문에 그런 것 같다. 아마 실제 해당 함수를 실행해야 할 때는 컴파일되어 있는 해당 함수를 시스템에서 찾아서 호출하여 사용할 것 같다. 나는 모든 실행 파일이 각각 그런 시스템 함수를 바이너리 상태로 가지고 있을 것이라고 생각했으나, 오늘 확인한 결과를 보니 그렇지 않을 것 같다는 생각을 했다.

2021-10-13
- 빠르게 구현 가능한 방식으로 프로그램을 구조화하고 작성하는 것도 중요하다. 당장 눈에 결과가 보여야 오류도 잡아내고 방향도 결정할 수 있기 때문이다.
- 하지만 동시에 확장성을 고려하여 작성하는 것도 무척 중요하다. 만약 내가 minishell 프로그램을 작성하기 시작했을 때 ()를 잘 고려해서 작성했더라면 lmt_process_manager 를 만들었다 지웠다 다시 만드는, 이렇게 큰 일이 되지 않았을 것이다. 또한 그런 확장성을 고려한 부분은 왜 그렇게 작성했는지 독자들에게 잘 전달되어야만 한다. 그렇지 않으면 불필요한 부분으로 여겨져 코드에서 삭제될 수 있다.
- 무언가 색이 완전 같은 것은 좋지 않다. 구별이 가지 않기 때문이다. 미세한 차이라도 랜덤하게 주자.
- 처음 한 번에 한해 수행하고 후에는 작동하지 않도록 함수를 작성하면 계속 호출해도 작동하지 않는 기능을 구현할 수 있다. 이런 특성을 담은 이름을 잘 지어주도록 하자.
- 즉, 최초 한 회만 실행해야 하는 기능이 필요한 경우가 있고, 계속 같은 작동을 해야 하는 경우가 있는 것이다.

2021-10-12
계발 방식을 공고히 정해놓고 진행하는 것이 좋다.
dev branch 에 항상 release 가능한 버전을 pull request 하는 식으로

2021-10-11
- 왜 rebase -i 를 해서 commit 의 순서를 바꾸면 Debug diff 와 일반 diff 가 섞이는 경우가 생기는 것일까?
	- Debug commit 에서 수정한 내용이 일반 commit 에 섞여들어간다

2021-10-10
- function declaration 과 function prototype 의 argument name 은 같을 필요가 없다. function declaration 의 parameter name 은 argument label 을 사용하고 function prototype 의 parameter name 에는 parameter name 을 사용한다.
return_type	function_prototype(parameter_type parameter_name);
return_type	function_declaration(argument_type argument_label)
{
}
- 따로 sequence structure 를 사용하지 않으니 발생하는 몇가지 문제가 있다. 반복을 담당하는 변수 element 가 내부 호출 함수로 전달되지 않으니, sequence 를 iterate 하는 중에 sequence 안의 element 들의 순서가 바뀐다면, 이런 정보가 element 에 적용되지 않는다.
- 반복 작업을 하다보면 일부 범위에서는 특수한 케이스로 반복해야 하는 경우가 있다.
	- 어디까지 작업했는지 인덱스 및 주소를 반환하기.
		- 이것이 편한 경우가 있다. inner function 이 재사용되지 않는 경우이다. 그리고 어떤 위치에서 정확히 발생하거나 발생하지 않는 경우 유용할 것 같다.
	- 작업 위치를 기억하는 변수의 주소를 인자로 전달하기.
		- 이 방법은 너무 별로다. 만약 iterate 하는 대상이 주소라면 이중 포인터를 사용해야 해서 가독성도 떨어진다.
	- 상위에 object 를 둬서 현재 작업 위치를 기억하도록 하고, 이 object 를 전달하여 사용하기
		- 이 방법은 가독성은 좋으나 모듈화되지 않는다는 점이 불편하다. object 가 inner function 까지 전달되기 때문에, inner function 에서는 사용하지 않는 object 의 다른 멤버 변수에 접근하는 등, 모듈화하기에 좋지 않다. 그리고 inner function 이 object 에 의존적이어지는 문제도 있다.
	- 특수한 작업을 하는 중인지를 flag 에 기록해두고 매 loop 마다 체크하여 필요한 routine 실행하도록 하기.
		- 매 loop 마다 어떤 상태인지 flag 를 확인해야하는 overhead 가 존재한다. 하지만 코드가 명확해지고 모듈화에 유리하다는 장점이 있다.

2021-10-09
- if 를 여러번 호출해야하는 함수가 있다면, 각 case 를 나누고, 그 case 에서 실행할 함수를 작성한 후 static array 에 저장하고, case 별로 index 를 return 하는 함수를 작성하여 static array 의 그 index 번째 함수에 접근하여 호출하는 방식이 좋겠다. static 사용에 제한은 없다.
	- 또, static 을 사용할 때는 thread safe 하게 만들기 위해, 변하는 값이 아닌, 상수형 값에 대해서만 사용하는 것이 좋겠다. 그럼 즉, const 값이네? 거기에 함수가 실행되어야만 처음으로 static 변수의 값이 초기화되니 lazy 하다고 할 수 있다.
- 함수의 분류
	- method: structure type 전용으로 묶인 함수
		- ex) _alloc, _init, _new, _free, 혹은 그 structure 전용 기능들
	- extension: 기존 structure 를 위한 나만의 추가적인 전용 함수
	- util: 분류되지 않은 함수 -> 이후 분리되서 독립적인 module 이 될 수 있다.
- 함수의 이름 앞에 lmt_ 접두사를 붙일 필요는 없다고 생각한다.
- 특히 이런 접두사는 structure 의 이름을 원천적으로 구분지어서 일반적인 structure 와 구분지을 때는 유용하지만. 누가 이 함수를 작성했는지를 구분하기 위한 목적으로 prefix 를 붙이는 것은 옳지 않다고 본다. 프로그램적 관점에서 볼 때, 하나의 프로그램 코드는 한 명의 사람이 작성한 것처럼 작성되어야 하는데, 작성한 사람을 구분하기 위한 목적의 prefix 는 이에 모순되기 때문이다.
- 하나의 ui 를 구성할 때 제공하는 기능의 범위에 따라 3 단계로 분류할 수 있다.
	1. 모든 것을 직접 컨트롤 할 수 있다.
	2. 제한적으로 직접 컨트롤 할 수 있다.
	3. 직접 컨트롤 할 수 있는 것이 없다.
- 어차피 git 의 기록은 github 에서 파일별로 message 가 표시된다. 따라서 파일을 생성했다는 message 등은 기록할 필요가 없는 것이다. message 에 파일 자체의 생성 소멸을 기록하기 보다는, object 나 function 에 중점을 둔 기록을 남기자.
- swift 의 Array structure 에는 pop()을 구현할 필요가 없었다. remove 만으로 특정 위치의 element 를 제거할 수 있고, 반환값으로 나온 그 element 는 사용해도 되지만, @discardableResult directive 가 붙어있기 때문에, 그냥 무시한다면 warning 도 뜨지 않고 ARC 가 알아서 처리할 것이다.

2021-10-07
- 'ctags': aux ctags . .
- 지금 하고 있는 일이 어떤 경로로 지금에 이르렀는지 꾸준히 기록해두자. 뭘 위해 뭘 하고 있었는지 까먹는 경우가 종종 있다.
- 이미 compile 된 파일의 header 파일을 수정하는 경우 Makefile 을 해당 header 파일이 compile 을 위한 source file 의 의존성으로 고려하지 않기 때문에 re compile 되지 않는다

2021-10-06
- 'git branch -d -r origin/jeonpark_new'

2021-10-05
- 내가 짠 코드를 직접 읽기 보다는 위에 적힌 설명을 읽고 이해하기가 쉬웠다면, 코드를 예쁘게 작성하고 있지 않다는 뜻 아닐까?
- 실행 흐름에 따라 프로그램을 쌓아나가듯이 제작하면 추가적인 코드 테스트용 코드가 적어질 수 있다.
	- 만약 각자 맡은 모듈을 제작하고 결합하려고 한다면, 각 모듈별로 테스트용 코드가 필요할 것이다.
		- 하지만 각 모듈읠 안정성을 검증하기에는 더 좋을 것이다.

2021-10-04
- 한 번 잠을 자기 시작하면 3 시간은 자게 된다. 잠을 자지 않기 위해 노력을 해보도록 하자. 가장 좋은 방법은 생각했던 프로그램을 빠르게 코딩하는 것이다.

2021-10-03
- 코드의 원본에 직접 주석으로 설명을 다는 것이 아니라, 마치 숫자로 표시하고 밑에 주석을 달듯이 설명을 추가하면 보다 기존 코드를 방해하지 않는 채로 설명이 가능해질 것 같다
- xxd test.txt | xxd -r
- xxd test.txt | xxd -r -s 100
- echo "00000010:31" | xxd -r - <path>
- echo "100:41" | xxd -r > <path>
- echo "100:41" | xxd -r -s -0x100 > <path>
- 'man -k <keyword>'
- 'apropos <keyword>'
- 'which, type'

2021-10-02
- 제품을 만든다는 것은 가능한 모든 것을 우겨넣는 것이 아니다. 핵심적인 것을 추가하고, 불필요한 것은 차단하는 것이다. UNIX 도 그런식으로 모델을 디자인하여 구현된 것이다.

2021-09-27
- 함수가 반환하는 값에 따라 함수가 에러 상태로 반환되었는지 등을 확인하는 것은 필수적인 과정이다. 그리고 내가 그 함수의 에러 여부를 어느정도 입력값 등으로 통제할 수 있는가도 제대로 파악해두는 것이 함수를 제대로 사용하는 것이다
- 'Liemani/cLibrary' 에서 'general class' 를 구현하기 위해 'kernel class' 를 구현했었는데, 따라서 'kernel class' 는 'general class' 의 기능을 사용하는 것이 아니라 그 골격을 구성하는 구조로 만들었다.
	- 마찬가지로 os 의 page 관리 시스템이 메모리 할당을 담당할텐데, 자기 자신의 메모리 할당에 대해서는 generic 한 함수를 사용하지 않을 것 같다	- 이런식으로 우리는 단순히 malloc() 이라는 함수를 사용할 때, 사실 이 함수가 제대로 작동하기 위해서는 시스템이 그 기반을 마련해주기 때문에 가능한 것이다
- 프로그램 곳곳에서 magic number 를 마치 약속된 고정 수 인것처럼 사용하는 것이 아니라 define 등으로 상수를 선언하여 사용하는 것이 좋다
	-  상수 값을 바꾸어도 실제 문서에는 상수의 이름이 기록되어 있기 때문에, 모든 문서의 해당 상수를 변경할 필요 없이 완성된 프로그램의 상수 값을 간단히 수정할 수 있는 장점이 있다.
- 자료를 잘 모아두고 정리하는 것은 현대 사회에서 매우 중요한 작업이다. 그런데 이를 raw 하게 처리해주는 프로그램이 적다는 것이 아쉬울 따름이다. 데이터 자료를 구조화하는 standard model 을 정의하고 이로 encode, decode 하는 프로그램을 만들면 좋을 것 같다
- 'git rebase -i' 는 순서를 변경했을 때 단순히 기록된 차이점을 사용하는 것이 아니라, 각 commit 의 tree 를 그 때 그 때 비교하여 새로 추가된 파일을 탐색하는 것 같다

2021-09-21
- 'git checkout --ours -- <path>'
- 'git checkout --theirs -- <path>'
- 포인터 타입의 값을 읽고 쓰는 것과, 일반 변수를 읽고 쓰는 것에 속도 차이가 있을까?
	- 어셈블리 코드를 비교해봐야 알 수 있을 것이다
- 'git cherry-pick A^..B'
- 'git cherry-pick A..B'

2021-09-20
- 'man 2 execve'
- 'man 5 a.out'
- 'man 1 as'
- 'man 1 ld'
- 'man 7 environ'
- 'execve()' 가 성공하면 닫히고, 실패하면 닫히지 않도록 특정 fd 를 설정할 수 있다(fcntl()로)
- argv 는 항상 null terminate 임이 보장되기 때문에 execve 의 두번째 인자로 사용할 수 있다
- 't_lmt_string *lmt_string_split_first(t_lmt_string *string, size_t count)' 처럼 전 후로 어차피 string->count > count 인지를 판단해야만 한다면, 굳이 이 함수의 구현에서 그 작업을 하지는 말자
	- 이 함수 내부에서 string->count > count 에 따른 처리를 해 준다고 해도, 호출부에서 return value 가 empty 인지를 확인하는 추가 작업을 해야하기 때문에, 처음부터 string->count > count 여부를 호출부에서 처리하도록 디자인하자
- [Apple Thread](https://developer.apple.com/documentation/foundation/thread)
	- When you need to perform a lengthy task, but don't want it to block the executioin of the rest of the application
	- In particular, you can use threads to avoid blocking the main thread of the application, which handles user interface and event-related actions
	- Threads can also be used to divide a large job into several smaller jobs, which can lead to performance increases on multi-core computers
- 프로그램이 종료되면 해당 프로그램에서 생성된 thread 들은 알아서 종료되는 것일까? 어떤 상황에서라도?
- [Thread wiki](https://en.wikipedia.org/wiki/Thread_(computing)
- 다 multi-thread 로 처리하면 되지 multi-process 는 왜 사용하는 거지?
	- minishell 과 philosophers bonus 가 multi-process 를 사용한다
	- thread 처럼 자원을 공유하지 않고 완전 별개의 프로그램처럼 취급하고 싶을 때 유리할 것 같다
	- A process is a unit of resources
	- A thread is a unit of scheduling and execution

2021-09-19
- predicate: iterate 하게 traverse 하면서 참과 거짓을 따질 때 그 참 거짓을 분별하는 함수를 predicate 라고 한다

2021-09-18
- 다양한 기능들을 복합적으로 섞지 말고 가능하면 쪼개서 추가/제거가 쉬운 구조로 만들자
- 다양한 타입의 list 를 구현할 때, 한 번 list 를 구현하고 사용하는 방법은 크게 2 가지가 있다
	- 'void *' 타입 의 member variable 을 content 로 갖는 list
		- 이 경우 간단하게 구현하여 사용이 가능하지만 element 의 값에 접근할 때 content 의 주소로 접근해야하는 오버헤드가 존재한다
	- list 로 만들 구조체를 위한 전용 list 형태의 구조체
		- 이 경우 각 list 구조체가 해당 type 의 구조체 데이터를 직접 소유하므로, 주소를 통해 데이터에 접근해야하는 오버헤드는 존재하지 않지만, list 화 할 type 에 대해 각각의 list 형태의 구조체를 정의해야만 하는 번거로움이 따른다, 따라서 실질적으로 이 것을 지원하기 위해서는, 이를 지원하기 위한 추가 작업이 선행되어야 한다
- list 는 append 에 불리하다
- 따라서 append 를 하고자 한다면 list 를 수정해서 사용해야만 한다
- set, array, list, stack, queue, dictionary, sequence, iterator
- sequence 를 구현하면서, append 함수를 만드는데, 만약 dummy node 를 두지 않는다면 append 시에 sequence 의 last 가 NULL 인지를 check 하여 다른 행동을 하도록 만들어야 한다. 이것이 싫어서 메모리를 조금 차지하지만 dummy node 를 두었다
- sequence 와 collection, 이 둘은 배열적 특성인 random access 가 가능한가를 기준으로 구분된다
	- sequence 는 random access 를 지원하지 않는다
	- collection 은 random access 를 지원한다
- traverse 는 방향과 차원에 상관 없이 탐색하는 느낌이고, iterate 는 선형적으로 진행하는 느낌이다

2021-09-16
- data segment 의 값을 프로그램이 바꾸려고 하면 bus error 가 발생한다
- general command tty: print current ttyname
- man stty
- man 4 termios
- [ieee](https://ieeexplore.ieee.org/document/6880751)에서 발견한 문서의 doi 를 [sci-hub](https://sci-hub.se)에서 검색하여 문서를 다운로드 할 수 있다?
- success & failure
- ps xao pid,ppid,pgid,comm
- ps -o tty,pid,ppid,pgid,comm

2021-09-15
- 생각은 기록보다 빠르다, private 암호와 등으로 속기 기술을 익힌다면 어떨까?
	- 복호화하여 public 이 이해 가능한 형태로 바꾸는 기술이 동반되어야 할 것이다
- minishell tokenize: structure 를 재귀적으로 사용했다면 어땠을까?
- mathmatical expression 을 tokenize 해보기
- <C-f>
- <C-b>

- <M-f>
- <M-b>

- <C-a>
- <C-e>

- <C-_>: undo
- <C-x C-u>: undo

- <C-d>
- <C-h>

- <M-d>
- <M-DEL>
- <C-w>

- <C-y>

- <M-digit><command>
- <M-TAB>: insert a tab character
- <C-t>: swap two characters
- <M-t>: swap two words
- <M-u>: uppercase current word
- <M-l>: lowercase current word
- <M-c>: capitalize current word
- 공부를 할 때 무엇을 참조했는지 기록해두는 것이 좋겠다
- [what is a buffer overflow](https://www.veracode.com/security/buffer-overflow)

2021-09-06
- 종이처럼 직접 만지고 필기할 수 있는 모니터 -> 아이패드처럼 필기가 가능하도록
- 더 나아가, 펜으로 프로그래밍이나 다양한 조작을 가능하도록?
- 'echo $LINES': 터미널의 출력 줄 수를 담고 있는 변수의 값을 출력한다
- 'echo $COLUMNS': 위와 유사
- 'setupterm()': env 와 terminfo 사용하여 terminal type 변수 하나를 생성한다

2021-09-04
- 인터넷의 정제된 페이지를 가져와서 vim 처럼 보고 싶다면, vim 에 인터넷 페이지를 정제하여 읽어오는 기능을 넣으면 되는 것이 아닐까?
  - 하지만 그러려면 vim script 등을 배워야겠지

2021-09-02
- 'man 5 term' 을 보니 지금과 같이 16 진수 체계를 사용하기보다 8 진수를 사용한 기록이 눈에 띄었다. 아마 옛날에 8 진수와 16 진수 체계가 혼용되던 시절, 초기에는 단순히 아라비안 숫자 체계가 0 부터 9 까지 존재하기 때문에 표기가 가능한 8 진수 체계가 사용되었지 않았나 싶다. 지금 와서는 0 부터 f 까지 사용하는 16 진수 체계가 더 자연스럽고 통용되었지만 말이다

2021-09-01
- vimsession 은 폴더 이름이 바뀌는 등, 외부의 수정이 가해졌을 때 이 변화를 인지하지 못하는 문제가 있다
- 왜 보기에 지저분한 html 을 사용해야만 하는가? 시각적으로도 더 읽기 쉽고 가벼운 언어를 사용할 수는 없는가?
- 'man 2 read' 를 보면 '#include <sys/uio.h>' 가 있는데, 이는 readv 의 인자인 iovec 를 정의하고 있기 때문에 추가하는 듯 하다, 만약 read()만 사용한다면 sys/uio.h 를 include 할 필용는 없을 것이다
- 내가 프로그램 지능이 나보다 낮은 사람에게 알려줄 수 있는 것은 앞길과, 그 시기에는 원래 그렇게 힘들다는 것이다

2021-08-31
- 가령, 모든 데스크 셋업을 커버할 수 있는 책상을 가지고 싶다고 하자
  - 그렇다면 왜 그런 책상을 원하는 것일까?
  - 그것은 지금 내 책상이 어떤 나의 이상적인 셋업을 커버하지 못하기 때문이다
  - 그렇다면 사실 '모든 데스크 셋업을 커버할 수 있는 책상' 은 문제를 해결하는 방법 중 하나이다
  - 따라서 어떤 사람이 원하는 것이 있다면, 그것은 해결 방안 중 하나일 것이기 때문에
  - 문제가 무엇인지를 확실히 하는 작업이 우선적으로 필요할 것이다
  - 하지만 대부분의 사람들은 문제가 무엇인줄 알며, 그에 대한 적절한 해결 방안을 제시한 것일 것이다

- https://osxdaily.com/2006/12/19/command-line-keyboard-shortcuts-for-mac-os-x/
  - <ctrl-a>: go to the beginning of the line
  - <ctrl-e>: go to the end of the line
  - <ctrl-u>: clear the line before the cursor
  - <ctrl-k>: clear the line after the cursor
  - <ctrl-w>: delete the word before the cursor

2021-08-27
- 컨벤션 관리 파일을 만들어서 컨벤션을 기록해두고 버전관리도 하면 어떨까?

2021-08-20
- 'traceroute <ip>': ip 로 가는 경로의 ip 들을 출력한다
- 'arp': local network 를 출력한다

2021-08-15
- OOP 는 기본적으로 다양한 주소를 무리지어서 하나의 그룹을 구성하기 위해 탄생한 것이 아닐까?
  - 모든 작업에서 1차적으로 발전할 때 그룹을 형성하는 것이 중요하다고 생각한다. 파일 시스템처럼 directory 를 만드는 것이다. 이를 위해 어떤 기준으로 그룹을 지을까가 중요해졌고, 여기서 물체 중심으로 관련된 주소들을 그룹지어서 저장하는 OOP 가 발전한 것 같다

2021-08-14
- xxd test.txt
  - '-s <address>'
    - xxd -s 0x10 test.txt
  - '-l <address>'
    - xxd -l 0x10 test.txt

2021-08-05
- 게임의 요소: 시청각의 값과 변화량
  - 시각 축 값: 그래픽
  - 시각 축 변화량: 모션
  - 청각 축 값: 배경 음악
  - 청각 축 변화량: 이펙트 사운드

1) 만약 각 A 가 90 도 이하라면
    각 B 가 45 도 이므로 각 C 는 180 - 각 A - 각 B 이다
2) 만약 각 A 가 90 도 라면
    각 C = 90 - 각 B
3) 만약 각 A 가 90 도 이상이라면
    각 C = 180 - 각 A - 각 B 이고,
    각 A > 180 + 각 B 이면 ABC 는 삼각형이 아니다

이런 식으로, 하나의 서술에는 하나의 가정만을 두는 것이 가독성 측면에서 좋을 것 같다

2021-07-19
```
...

print normal
if (fail)
{
	print additional fail message
}

...
```

- 함수 도중에 이런 식으로 하나의 흐름에 분기를 두는 것은 가독성을 낮춘다
- print 와 if 문을 분리하는 시각적 효과가 있으며, print 가 위의 흐름에 포함될지 아래 if 문의 흐름에 포함될지 중의적이어진다

```
...

if (success)
{
	print normal
}
else
{
	print normal
	print additional fail message
}

...
```

- 이렇게 print normal 이라는 statement 가 두 번 들어가지만, if 문 하나로 모듈화해 놓는 것이 위 아래 흐름이 존재하는 상황에서는 더 좋다

```
...

print_state()
{
	if (success)
	{
		print normal
	}
	else
	{
		print normal
		print additional fail message
	}
}

...

print_state()

...
```

- 이런식으로 구분된 모듈은 하나의 함수로 만들어주는 것이 가독성 측면에서 최고로 좋다

```
...

print_state()
{
	print normal
	if (fail)
		print addtional fail message
}

...

print_state()

...
```

- 이제 하나의 모듈로 묶여 중이적인 부분이 해소되었으므로 print normal 을 두 번 쓰지 않고, 실패 시에면 추가 실패 메세지를 출력하도록 해도 가독성이 떨어지지 않는다

2021-07-17
- 요구사항에 대한 자세한 내용은, 직접 만들어보고 나서야 기준을 세울 수 있는 경우가 존재한다
  - 그런데 막상 만들어보고 나서, 기존의 요구사항을 까먹기도 한다
- 'git reset --hard <commit>': branch 를 옮기고 working directory 의 파일들도 commit 의 것으로 교체한다
- 'git reset --soft <commit>': 현재 branch 를 commit 으로 옮기지만 working directory 의 파일들은 변경하지 않는다
- 일일이 모듈화된 코드를 넣었다 뺐다 하는 것이 아니라 git 으로 해당 코드를 버전 관리 하면서 필요하면 적용된 코드를 넣고, 필요 없으면 해당 버전을 빼는 방식으로 진행하면 좋겠다(완벽히 유기적으로 연결될 수는 없겠지만)
	- 순서와 계층이 생길 수 밖에 없다
	- A > B > C 순서로 코드를 작성했다면 C 는 A 와 B 에 영향을 끼치게 되고 B 는 A 에 영향을 끼칠 수 있다. 이 상태에서 A 를 뺀다고 했을 때 B 와 C 는 A 에 의존적이기 때문에 세부적인 부분의 수정이 불가피할 것이다

2021-07-16
- 이런식으로 한 줄이라도 오늘 생각한 것을 기록하는 것이 작은 성취감을 얻을 수 있는 귀한 행동인 것 같다
- 해야 할 일을 전부 적어놓고, 우선순위를 매기자. 더 급한 것을 먼저 하며 하고 싶더라도 당장 급하지 않은 경우는 반드시 뒤로 미루도록 하자

2021-07-15
- const 는 해당 포인터가 가리키는 변수 내부의 포인터가 가리키는 변수의 값을 변경하는 것도 불가능한가?

2021-07-09
- function prototype 의 argument name 에는 argument name 을, function define 의 parameter name 에는 parameter name 을 기입하도록 해보자
- general Debug commit 과 delicate Debug commit 을 구분해도 좋았을 것다
- commit 에는 무엇이 기록되어 있을까? 다시 한 번 확인을 해 볼 필요가 있다
- string 을 tokenize 할 때 단순히 특정 delimiter 로 쪼개어 word 단위로 저장하는 것이 아니라 앞뒤 문맥을 보고 해당 word 의 type 을 결정하는 것이 필요하다. 또한 word 단위가 아니라 의미있는 word 들의 묶음을 하나의 token 으로 묶어서 처리할 필요가 있다
	- structure 를 재귀적으로 사용했다면 어땠을까?
- process's filedescriptor table 에서 fd index 번재의 file data structure 를 읽고 사용 가능한 system call 함수가 해당 fd 의 file 에 사용 가능한지 판단한다

2021-07-08
- 'launchctl limit': show limit data

2021-07-07
- 요구사항을 분석하는 능력이 부족하다
- n 이 m 개 있는 것을 표현하는 방법
  - (mn | n * m)
- pseudo code 의 경우 시연용으로 작동 가능하도록 만들려면, 시연용 input 에 대한 output 을 출력하도록 만들어 놓는다(내부 구현은 없어도 된다)
- 역시 조금 불필요한 동작이 있더라도 빠르게 구현하는 것이 더 중요한 것 같다. 아무리 잘 만든다고 오랫동안 공들여도 당장 작동하지 않는다면, 차라리 2~3 배의 자원을 사용하더라도 일단 작동하는 것이 더 좋다

2021-07-06
- 'ps -f <pid>': process 의 ppid 를 알 수 있다
- 요구 사항이 있으면 요구사항을 최저 사양으로 설정하고 전체적 추상화를 진행하는 것이 좋을 것 같다
- 상대가 원하는 정보가 따로 존재한다
  - 다량의 정보를 그냥 쏟아내는 것은 좋지 않다
- 피드백을 잘 해라
  - '너무 작아서 잘 안들렸어!'

2021-07-05
- 팀원들간의 사적 일정으로 인해 격차가 발생할 수 있다. 이 경우 일정을 잘 조율하지 않으면 부담이 가해질 수 있다
- 말을 조금 더 조심스럽게 하자
- 너무 말을 억세게 한다
- 상대방도 말을 더 부드럽게 할 수 있도록 내가 유도해서 행동해보자

2021-07-04
- 화를 내지 않도록 조심해라! 화를 내면 내가 생각해보지 못했던 상대의 새로운 의견을 들을 기회가 사라질 수 있다

2021-07-03
- '~/.vimrc' 로부터 적용된 내용은 vimsession 에 저장되고, vimsession 을 open 할 때는 '~/.vimrc' 를 읽지 않는다
- dm 메세지와 다르게 facebook 처럼 나의 line 에 메세지를 남기는 방식이 확실히 전파력도 강하고 가볍게 글을 남길 수 있어서 장점이 있는 것 같다

2021-07-02
- 잘 모르는 것에 대한 부분에서는 목소리를 높이지 말자. 잘 알지도 못하면서..

2021-06-30
- 나는 왜 타인을 무시하고 들어가는가?
  - 가치관이 다른 사람을 인정할 수 있는가?
- 내가 의견이 너무 강하다
- 물어보자 왜 왜 왜인지 물어보자
- 상대의 말을 더 잘 들으려고 노력하자

2021-06-29
- 팀원 각각의 특성을 잘 파악하는 것이 중요하다
- 대화는 한 명이 다른 한 명에게 생각을 전달하는 것이다. 혼자 말하는 것이 아니다. 전달하고자 하는 생각이 무엇인지 확실히 해둬라

2021-06-28
- 시간이 넉넉하지 않을 때 대화를 하지 않는 것은 좋지 않다
  - 시간이 넉넉하지 않다는 것을 대화를 해서 알리도록 하여라!
- 규칙이 없다면 둘이 섞일 수 없다
  - 각자가 맡은 부분만을 담당해야 한다
- 규칙이 있다면 둘이 섞일 수 있다
  - 각자가 하고 싶은 부분을 건들일 수 있다
- detach 하면 thread 가 종료될 때 내부 할당이 free 될까?

2021-06-27
- 끝내기 전에 나의 성장을 위한 감사를 표현하자
- "너무 무리하지는 말어"
  - 이렇게만 말하면 상대가 여러 의미로 해석이 가능하다
  - 명시적으로 의미 전달을 해야 한다
    - 우리의 목표는 단거리 달리기가 아니다! 라는 등!
- 상대 말에 대한 묵언
  -> 상대 말에 대한 부정적 의견 표출로 해석
- 말의 높낮이를 비정상적으로 꼼
  - 말이 진정성을 낮추고 장난칠 때 하는 행동
    - 상황에 따라 상대를 조롱하는 것이 될 수 있다
- 상대는 하고 싶은 것이 있는데, 내가 다른 것이 눈에 보인다고 그 것을 얘기하면, 상대의 입장에서는 자신의 문제를 해결하지 못한 채 추가적인 문제가 생기는 것이다!

2021-06-26
- ls 에 파일 내용을 출력하는 기능이 있더라
- 설명을 할 때 평가를 받는 것처럼 중간 단계를 건너 뛰고 결과 및 큰 그림을 설명하는 문제
  - 상대에게 맞춰줘야한다!
  - 상대가 나의 설명을 이해하지 못하는 것은, 내가 상대가 얼마나 알고 있는지를 이해하지 못하고 있기 때문이다
- 단 usleep(1)만 해도 31019 usec 만큼이 걸릴 수 있다 (다른 thread 가 열심히 돌아가고 있다면)
  - 모든 작동이 한 번에 오래 걸리지 않도록 적당히 suspend 를 해주도록 하자 (그래야 thread 가 골고루 돌아갈 것 같다)

2021-06-25
- signal 에 대해 물어보셨을 때 'man signal' 을 보여드리면 더 좋았을 것 같다!!
- 상대가 자신은 뭘 쓴다고 하면 그에 대한 반응을 해주자!! 가볍게!!
  - 기술 1. 오,, 어때요?
    - 단순 의견 질문
  - 기술 2. 오,, 이거랑 비교해보면 어때요?
    - 비교 대상 존재 시 비교 질문
  - 기술 3. 오,, 노트북에서도 편했었는데, 편할 것 같아요
    - 경험을 토대로 의견 제시
- 문제에 대한 질문
  - 기술 1, 대답 연기
    - 생각 좀만 해봐도 될까요?
- 한 번 대화를 할 때 제대로 의미를 전달하도록 하자!
  - 한 번에 잘 전달하지 못했다면 여러 번 말을 번복해야하는 수고가 발생한다
- 다른 사람이 내 코드를 볼 때 어떤 식으로 볼지를 생각해보는 것도 좋겠다
  - 만약 보조 자료가 있다면 학습 속도가 비약적으로 빨라질 것이다 (전체적인 데이터의 흐름 등)
  - 만약 코드만으로 분석을 해야 한다면 'main()' 부터 시작하여 직접 코드의 흐름을 분석해야 할 것이다
    - 이 경우는 내가 직접 지원해 줄 필요는 없지만, 당사자는 함수의 이름을 보고 접두사, 접미사를 통해 대략적인 역할을 파악할 수도 있다

- 긍정적이냐 부정적이냐는 나의 관점에서 판단하는 것이 아니라 타인의 어제와 오늘을 비교하여 결정하는 것이다
  - 이것을 못하면 다양성의 긍정적인 면을 인정하기 힘들어질 것 같다

2021-06-24
- 함수가 pointer 를 인자로 받을 때는 그 인자가 const type 인지 아닌지가 중요해진다!! 변경되서는 안되는 인자라면 const 를 명시해주는 것이 좋다
- 멘토 특강(오디오 신호 이해 및 딥러닝 음성인식 (Speech Recognition) (주) 보이스프린트 대표 김광호
{
	feedback 바라는 점까지
	소리 인식, 음성 인식, 자연어 인식 (언어 모델)
	오디오 신호 -> 시계열 데이터
	언어모델
	트랜스포머 버트 쥐피티
	강 인공지능: 사람 같은
	약 인공지능: 특정 영역에서 성능을 발휘함
	최적경로 알고리즘?
	옛날에는 SVM 이라는 것도 있었다고 한다
	ANN 이 발전되어 Deep Learning 이 되었다
	deep learning < machine learning < ai
	google tensorflow https:// 'a neural network playground'
	regression, classification: 숫자 조정, 분류
	hidden layer 의 neuron 은 선 하나 하나를 의미한다
	여러 neuron 으로 형태로 구분해낸다
	가중치와 bias 로 선이 그려진다
	voice, non_voice(music)
	화자 인식, 음성 인식, 음성 합성
	소리를 여러 파형으로 분할
	푸리에, 스펙트로그램 (소리를 분할)
	자연어 처리는 앞 뒤, 등 주변 단어를 고려한다
		주변 벡터와 비슷한 벡터로 인식한다
	transformer papef
	sound -> encode (number) -> decode (human word)
	local optimal
	학회
}
- 이런.. 오늘은 terminal 이 평가 프로그램 실행 중 튕기는 현상으로 인해 디펜스를 원활히 하지 못했다.. 확인해보니 하드디스크의 용량이 다 차서 그랬던 것 같다.. 다음부터는 이런 상황에 하드디스크 용량을 잘 확인해보도록 하자..
- 나는 exit_code 도 잘 관리를 해뒀으니 문제가 발생하면 exit_code 를 확인해봤어도 굉장히 훌륭한 방법이었을 것 같다!!
- 디펜스 등록 이후에 문제를 발견했다면 빠른 취소보다는 디펜스를 한 번 해보는 게 도움이 될 것 같다

2021-06-23
- 감정을 잘 모르는 것이 아니라 이해하는데 시간이 좀 걸리는 것 아닐까?
- 나는 처음에는 다 괜찮은 것처럼 말해놓고 나중에 가서는 딴 소리를 하는 것 같다?
  - 나는 내 생각보다 그렇게 다른 사람의 의견을 다 수용할 수 있는 사람이 아닌 것 같다
- SIGUSR1 의 handler 를 호출하고 SIGUSR2 로 interrupt 를 하고 다시 SIGUSR1 signal 을 줬더니 반응이 없었다
  - handler 내부에서 empty mask 를 가진 sigaction 으로 새로운 sigaction 을 설정해주었지만 그럼에도 SIGUSR1 signal 에 interrupt 되지 않았다

2021-06-22
- minilibx
  - https://github.com/qst0/ft_libgfx#minilibx
  - https://harm-smits.github.io/42docs/libs/minilibx
- semaphore 는 thread 에서도 사용할 수 있었던 것으로 기억하는데, process 간에서도 사용할 수 있는 건가? 애초에 process 간에도 같은 메모리 공간의 변수를 사용할 수 있나? 그럼 반대로 mutex 는 process 간에 사용될 수 있나?
- 주석을 곳곳에 넣어서 언제나 완성된 코드를 유지하도록 하자! (pseudo 코드지만)

2021-06-21
- 생각을 못했던 부분을 지적당한다면 순간 당황을 할 수 밖에 없다. 나는 생각을 해본 부분이지만, 상대는 생각을 못 한 부분이기 때문이다. 이 경우 상대방에게 생각 할 시간을 넉넉하게 주는 것이 좋을 것 같다

2021-06-20
- 통신 장애
  - 1. 잘못된 값이 전달: checksum 으로 확인
  - 2. NAC 를 사용하는 경우 오작동으로, 정상적인 상황에서 데이터 수신 중에 NAC 전송
    - NAC 는 전송 실패 확률이 낮은 경우 사용하는 acknowledge flag 인 것 같다. 매번 ACK 를 사용하지 않아도 되어 속도를 조금이나마 높일 수 있을 것 같다. 나의 경우 signal 이 사라지는 경우도 존재하는 등 전송 실패 확률이 높기 때문에 NAC 를 사용하지 않는 것이 좋겠다
- 내가 도와준다고 하는 것이, 상대는 항상 좋게 생각하는 것은 아니다
  - 도와주고 싶다면, 상대가 도움이 필요한지를 먼저 물어보는 것이 예의이다
- leaks 가 정상적인 상황이 아닌 것 같다. leaks 는 대상 프로그램의 실행을 잠시 block 해두고 검사를 진행하는 것은 아닐까?
  - 말일 그렇다면 signal 로 인해 발생한 SIGUSR1 handler 가 leaks 로 인해 block 상태에 놓이고, 이 상태에서 client 로부터 SIGUSR1 이나 SIGUSR2 가 입력되었을 때 이 signal 을 무시하게 되면서 신호가 씹힐 수 있다
- 일반적으로 interrupt 가 되어 실행되는 함수는 끊기지 않고 실행되거나, 그 함수가 반환되어야 원래 하던 일이 실행되기 때문에 가능하면 가볍게 구성하라고 한다. unix signal 의 경우는 우선 실행될까? 아니면 system 에 의해 여타 thread 와 마찬가지로 처리될까?
- signal handler 가 실행중인데 block set 에 지정한 signal 이 들어올 경우 이를 1 회에 한하여 들어왔음을 체크해두었다가, 낮은 순서대로 handler 를 호출한다
- signal handler 내부의 system call 은 signal 로 fail 하지 않는다
- mask 로 block 되지 않은 signal 이 들어오면 signal handler 를 실행중이더라도 system call 이 fail 한다
- BIT_WAIT_INTERVAL 은 bit 가 손실된 것을 막아야 한다. 이것이 bit 의 늦은 전송을 막는다면 정상적인 상황도 error 로 간주되며 속도가 저하될 것이다. 따라서 일반적으로는 정상적으로 손실 없이 전송될 것이기 때문에 (손실률이 낮기 때문에)이 수치는 높게 설정하여 실수로 bit 가 늦게 들어 오는 경우에 발동되지 않도록 해야 한다 (비트 손실 발생 패킷 빈도가 1% 라면 bit 전송 간격 / 1% 정도?)
- sample 을 통해 bit 손실률과 packet 전송 실패율을 계산하여 각 interval 에 적용하는 것도 좋겠지만, 이 프로젝트에서 요구하는 사항은 아니니, 이정도로 하고 마치자
- 나는 말을 하는 사람이 말을 구체적으로 해야 한다고 생각했고, 상대는 말을 듣는 사람이 부족한 부분을 질문을 해야 한다고 생각했다
  - 둘 다 맞는 건데, 나는 질문을 하지 않았고, 상대는 말을 정교하게 하지 못했다

2021-06-19
- 상대가 무시 당한다는 느낌을 받지 않게 하기 위해서는 내가 계속 말을 해야 한다
  - 1. 목적 잊지 않기
  - 2. 상대가 물었으면 그에 대한 답을 하자 (상대가 그 말을 한 표면적인 의미부터 제대로 이해하자)
  - 3. 실수는 빠르게 정정하자 (이것도 가능하면 말로 정보를 많이 주는 것에 속한다)
  - 4. 머릿 속으로 생각만 하지 말고 말로 전달을 해야한다 (무슨 생각을 하고 있는지 상대방에게 공유해야한다)
  - 5. 그럼에도 불구하고 불필요한 말은 하지 않는다
  - 6. 말은 항상 쉽게 해야한다 (괜히 꼬거나, 나쁜 것 처럼 말하고 좋은 말을 하거나, 반대로 좋은 것 처럼 말하고 나쁜 말을 하거나 하지 말자, 이해할 수 없으면 재밌지도 않다, 상대는 불안하기만 할 것이다)
- 나와 비슷하게 생각하는 사람은 대화가 잘 통할 것이다. 반대로 사고의 흐름이 다른 사람과는 말이 잘 통하지 않을 것이다
  - 대화가 잘 통한다는 것은 바로 전에 나눈 대화 다음 대화서 서로 어느 정도 예측 가능한 방향으로 진행되는 것이다
  - 또한 서로 전달하는 말에 들어 있는 정보의 양이 서로 불편하지 않고 납득할만한 양일 것이다
- 다른 프로그램이 같이 동작하면 기본으로 설정한 BIT_SEND_INTERVAL 을 넘어가는 interval 이 발생할 수 있다
- SIGUSR 의 특징인 것일까?
- infinity_leaks 를 실행하니 signal 을 그냥 출력만 해도 씹히는 현상이 있다
  - 00100000000000000000000000000000100000000000000000000000000000001010101001101100100000000000000001100101100100110111111111111111 (앞에 한 번 001 만 출력되고 다음 전송은 제대로 출력됨)
- 실패할 때 NAC 를 전송하여 재전송을 요청하는데, 그냥 가만히 있고, client 가 ACK 를 받지 못할 때 데이터를 재전송하도록 하면 어떨까?

2021-06-18
- 'echo "obase=2; $var" | bc': 숫자를 2 진수로 출력하기
- 'echo "$((2#<binary number>))"': Binary 를 decimal 로 출력하기
- 'echo "obase=10; ibase=2; 10" | bc': obase 가 ibase 보다 먼저 나와야 한다
- bfs 와 lss 의 구조와 방식을 설명하는데 조금 더디다는 것을 깨닳았다
- 스스로 생각하고 대답하도록 물어보고 난 후의 대답에는 상대가 더 그것을 자신의 생각이라고 여기고 인정하게 된다
- 주어진 질문을 주체적으로 해석하여 답을 내는 것은 중요한 기술이다. 하지만 사람과 대화할 때 이 기술만 사용할 필요는 없다

2021-06-17
- 1. 사용 사례, 어떻게 사용할지를 조사하여 데이터 확보하기
  - 주의: 사용 가능한 모든 케이스가 아니라, 소요 시간이 가장 짧은 최고의 사례를 모아라
- 2. 구현 및 테스트
- client 가 pid 를 전달할 때 checksum 오류가 발생하면 서버의 NAK 신호도 오지 않고 client 가 pause 에 빠져버리는 문제
  - receive signal 도 출력해보면서 pause()가 왜 안 풀리는지, 어떻게 둘 다 puase()가 될 수 있는지 알아보기
    - client 가 pid 를 전송한 후 pause 에 빠져서 server 가 client 에게 packet 을 보내지 못했다
- sigaction 의 3 번째 인자: 기존 처리 방법을 저장할 struct sigaction 의 주소

2021-06-16
기존에 정의해 놓은 structure 의 구조를 변경할 경우 할 작업이 많아진다. 이를 자동화해도 재밌을 것 같긴 한데, 지금 상태에서 다른 사람들은 이를 어떻게 해결하고 있을까?

2021-06-15
- 종종 대화 중에 서로 다르게 이해하는 '같은' 단어를 사용하여 혼동이 생기곤 한다
  - 전문 지식을 전달하는 글도 어떤 단어에 보다 많은 의미를 부여하여 사용하기도 한다
    - 가령 'block' 이라는 단어를 사용할 때, 단어 그대로 의미의 '막다' 라는 의미 이외에도 'block' 이라는 것을 통한 추가적은 내부 구현을 내포하기도 한다 (어떤 변수가 어떤 값을 갖는다던가)
- pdf 를 작성할 때 제일 앞에 index 페이지를 만들고, 각 페이지마다 쪽 수를 표기하자
- 'kill -SIGUSR1 <pid>' 와 같이 검증된 read/write 도구 하나만 주어져도 새로운 개념에 적응하기가 훨씬 쉬워진다!!
- apple 에서는 unsafe 한 경우 함수 정의에 포함되는 것 같던데 그런 방식도 좋은 것 같다
- 'usleep(13)' 정도까지 전송 에러가 발생했다 (아마 signal handler 함수의 처리 시간과 관련이 있을 것 같다
- 개념 접근 단계
  - 1. 모든 값을 확인해보기 (어떤 변수에 어떤 값이 들어있고, 상수는 실제 어떤 숫자 값인지)
  - 2. 값 변화에 따른 결과 관찰하기
  - 3. 입맛대로 코딩하기
- structure 는 생각보다 순서에 의해 내부 구조가와 크기가 달라질 수 있다

2021-06-14
- level design: 처음에는 버튼을 누르는 수준으로 매우 쉽게 만들더라도 그 버튼에 쓰여있는 글씨 등에는 사실 다 의미가 있다. 이것을 이해하는데에는 하나의 level 을 거치는 것이 필요하다
  - 즉, 하나의 level 에는 단순히 그 목표를 달성하는 것 이외에도, 주변 환경과 정보들의 의미를 이해하는 숨은 목표도 있다
    - 이런 식의 널리 퍼지지 않은 개념을 계속 이해하고 적용하는 것이 중요하다. 이것이 미묘한 차이를 만들고, 이것이 품질의 차이가 된다
	  - 더 나아가 이런 개념을 도입하려는 팀원들을 잘 격력하는 것도 중요하다
  - 시간을 느끼게 해주어야 한다
    - 개념을 설명할 때 그 개념이 실제 사용되는 것을 간접 체험시켜주는 것도 중요한데, 이 때 그 개념에 소요되는 시간이 어느정도일지 전달하는 것이 중요하다
	  - 하루에 한 번 발생하는 개념을 자주 사용하는 것으로 이해할 수도 있다
	    - 이런 괴리가 발생했을 때 어리둥절함 및 무언가 잘못된 느낌을 겪을 수 있다
		  - 만약 개념을 기초부터 이해했다면 스스로 소요 시간을 계산해볼 수는 있다. 이 경우 외부로부터 소요 시간을 입력받지 않아도 괴리감이 발생하지 않으며, 따라서 부작용도 없다
- git 은 변경 내용을 다양한 방법으로 수정할 수 있다
  - 이를 응용해서 적절한 delimeter 로 git commit 을 구분짓고, 필요한 commit 을 골라 적용할 수도 있다!!!!
    - 가령 debug 를 위한 코드를 commit 하고, bugFix 를 commit 하면, debug 를 위한 코드 변경사항을 제하고 bugFix 를 위한 변경 사항만 적용시킬 수 있다
- remote tracking branch 로 branch 를 만들면 해당 branch 의 remote 가 remote tracking branch 가 track 하는 remote branch 로 설정된다
- 'git branch -u <remote tracking branch> <branch>': branch 의 remote branch 를 remote branch 로 설정한다
- c 에서 함수 포인터 타입을 정의할 때, 내부에 인자가 있으면 내부 인자가 진짜 인자고, 외부에만 인자가 있으면 외부 인자가 인자다
  - 'void (*(int))(int)': 'void (*)(int)' 를 반환하고 'int' 를 인자로 하는 함수
  - 'void (*)(int)': 'void' 를 반환하고 'int' 를 인자로 하는 함수
- 프로토콜이 필요한 이유는 두 기기가 정보를 주고받을 때 사용하는 시간과 계산하는 시간 간격이 하드웨어에 따라 서로 다를 수 있기 때문에, 이런 문제를 극복하고 원활한 소통을 하기 위해 서로 약속된 프로토콜을 따른다
  - 서로 안정적으로 통신이 가능하도록 구성된 '프로토콜' 을 따르면 안정적인 통신이 가능하다

2021-06-13
- ':args `find -L . -iname \*.\[hc\]`' in vim
- 저번에 멤버변수의 type 으로 다른 structure 를 사용할 경우 그 structure 의 header file 을 include 해야 했던 것으로 기억하는데, 이를 한 번 더 검증했으면 좋겠다
  - 만약 그래야 한다면 하던데로 header file 에서 다른  structure 를 include 할 때 type.h 파일을 따로 만들어서 타입에 대한 정보를 먼저 주고 실제 header file 을 include 해야 할 것이고, 아니라면 그냥 type.h 파일만 include 해줘도 괜찮을 것이다
- core data 를 다루는 structure 는 의존성을 끊고 잘 캡슐화하자
  - 그래야 여기서도 쓰고 저기서도 쓸 수 있다!

2021-06-12
- ':vimgrep /<word>/g <paths>' in vim
  - ex> ':vimgrep /ft_atoi_push_swap/g **/*.[hc]'
  - ex> ':vimgrep /ft_atoi_push_swap/g %': '%' means filepath of active buffer
  - ex> ':vimgrep /ft_atoi_push_swap/g ##': '##' expanded to represent each of the files from the arglist
- ':cnext', ':cprevious' in vim
- ':cfirst', ':clast' in vim
- ':copen', '<cr>', ':cclose' in vim
- By default, the driver converts a Control-D character at the start of a line into an end-of-file indicator
- In windows, actual EOF character exists
- test 'cat' to figure out the behave of <c-d>
- '<c-v><c-@>' in vim: write NULL character
- 다음 프로젝트를 진행할 때는 요구사항을 우선 빠삭하게 분석하고 시작해볼까?
- 오늘은 또 이상한 메모리 관련 문제가 있었다. 원래 존재하던 메모리의 주소가 계속 지워지는가 값이 0 으로 초기화가 되는 것이다. 그래서 lldb 로 위치를 찾아내고 (그런데 이 과정에서 lldb 는 처음에는 segmentatino fault 가 뜨다가 몇 번 브레이크 걸고 시도하다보면 다음 run 부터는 계속 성공하는 이상한 일도 있었다, 다시 껐다 키면 또 segmentation fault!?), lldb 로는 이해할 수 없는 일이 일어나서 printf 로 값을 출력해보니 확실히 특정 함수 호출을 기점으로 이상한 값이 적용되고 있었다 (특히 더 이상한 것은 그 함수는 문제의 구조체를 받지조차 않는다는 것이다). 문제의 원인은 할당하지 않은 변수를 free 해서 벌어진 일이었다. 그 변수에는 임의의 (어쩌다가 무조건적으로 특정 구조체의) 값이 들어있었고, 그 주소를 free 하자 필요한 구조체가 초기화된 것 같다. 그래서 해당 변수를 특정 구조체 안에 넣어서 구조체가 할당, 해제 될 때 직접 관리하도록 하여 불안전한 값이 들어가는 것을 방지하였다
- settings set target.input-path <path>

2021-06-11
- alias 는 read-only 인 constant 고, variable 은 read-write 인 variable 이다
- local repository 는 'git branch -m <old_branch> <new_branch>' 로 이름을 쉽게 변경할 수 있지만, remote branch 에서는 이가 허용되지 않는다
- 'du -sh <path>': Print disk usage of 'path' directory or file with human-readable
  - 기본적으로 파일을 위한 디스크 공간은 (클러스터 맥에서는) 4.0K 를 한 단위로 제공된다
    - 1 byte 만 사용해도 4.0K 를 할당 받는 것
  - 'du -c': Display a grand total
- 'sort -n': Sort fields numerically
- 'seq 1 10 | sort -nr': Display 10 ~ 1
- 'sort -t <character>": Use character as seperator
- 'bluprint' branch 를 작성할 때는 제대로 된 기능을 수행하는 것이 아니라 default 로 정의된 constant 값을 직접 적용하는 정도로 구현해둔다
  - 그리고 실제 구현해야할 목록에 넣어둬서, 현재 작업이 필요한 목록을 항상 최신으로 유지한다
- 'main' branch 의 '/.project/' 에는 merge 해야할 사항을 기록해둔다
- '!=' 이나 '==' 은 처음 이후 else 보다 판단문 자체로 인한 분기를 강조한다
- 함수의 이름은 그 함수가 어디에 초점을 맞췄는가로 정한다.
  - 함수의 기능이 중요한 것인지, 함수가 반환하는 값이 중요한 것인지
  - 또, 가독성을 높이기 위해 함수의 이름은 거시적 관점으로 결정하는 것이 좋다
- 모든 null 입력에 대한 guard 를 하는 것보다, 필요에 따라서는 error 를 발생하도록 하는 것이 문제 지점을 탐색하는 데 유리할 수도 있으르 것 같다
- ':args `find . -iname \*.\[hc\]`' in vim

2021-06-10
- shell parameter expansion
  - 'repositories=(${repositories/#/$git\/})'
- 'set -- $vimsession; vimsession=$1': Get first word from string
- '`.' in vim: Takes cursor to the position where you made the last change
- '+' 와 '-' 로 증감이 가능한 변수 'var' 가 있다, 이는 생물인가?
- ':cd %:h' in vim: See ':help expand'
- 'seq' in cli

2021-06-09
- 어떤 프로그램 실행 전에 항상 어떤 코드를 실행시키도록 하는 방법
  - 1. precmd_function 목록에 추가하여, 모든 command 에 대해 선행 작업을 하도록 한다
    - 'precmd_function+=( precmd_vcs_info )'
  - 2. alias 로 shadowing 하여 reculsive 를 막으면서 특정 작업을 선행하도록 작성한다
    - ex> 'alias ls="ls -Alp"'
  - 3. 목표 프로그램이 실행될 때 선행적으로 하는 작업이 있다면 원하는 코드를 수행하도록 작성한다
    - ex> '.zshrc', '.vimrc'
- 'git config --edit --global': Open global git config file
- 'git config --get --global core.excludesFile': Show the value of variable
- set, type, typeset, alias, env, declare
- function 을 propagate 하여 사용해보려고 했으나 FPATH 가 기본적으로 subshell 에 전달되지 않고 이를 '.zshrc' 없이 구현하는 방법을 찾아보았으나 정보가 없어서 포기하기로 한다
- function 을 일절 사용하지 않고, subshell 에도 특정 기능을 할 수 있도록 하기 위해서는 '.sh' 파일을 작성하기로 했다.
- shell script 에는 c 에서 exit 과 같이, 실행 중이 프로그램 자체를 나가는 역할을 구현하기가 어렵다. 그래서 언제나 프로그램을 종료할 수 있는 c 와 다르게 깊이를 주지 않고 source 를 이용하여 서로가 서로를 호출하도록 작성한 뒤, exit 으로 현재 shell 을 종료하는 방향으로 진행해보자 (return 은 실행중인 sh script 를 닫는다)
- shell script 의 if 문은 마치 하나의 script 처럼 판별식의 인자를 $1 에 넣는다
- aux 에서, 필요한 파일을 alias 하고는 싶으나 zsh 을 호출해서 사용하고 싶다 (exit 하고 싶어서)
  - '.zshrc' 와 'aux' 에서 공통적으로 사용할만한 것들을 따로 빼서 두 파일이 모두 호출 가능하도록 구성해보자
    - 그런대 'aux' alias 는 둘이 서로 다르긴 하다..
- 'a=(${(s/:/)string})'

2021-06-08
- 'c rename t_sort t_sort_type'
- 'basename 'git rev-parse --show-toplevel''
- ':h <option>' in vim: Search help page for vim
- 'env': List exported environment variable
- 'set': List local environment variable
- '>' 나 '<' 는 파일을 input 으로 읽는다
- '|' 는 앞 command 의 stdout 을 뒤 command 의 stdin 으로 준다
- 'xargs <utility>' 는 stdin 을 utility 의 인자로 하여 실행한다
- 파일로부터 직접 읽고 쓸 때는 꺽쇠를, 다른 처리를 한 결과를 입력으로 할 때는 파이프를 사용한다
- alias 정의 안에 $()로 다른 프로그램을 실행하면 실행 시 처음 한 번만 프로그램을 호출하여 값을 저장한다
- alias 로 특정 파일을 호출할 때, 정확한 위치를 적어주는 것이 아니라 대상을 search 할 directory 를 적어주면 편할 것 같다
- zsh 뒤에 인자가 여러개이면 가장 처음 인자만 실행된다
- 'vimsession' 이 현재는 새로운 zsh 을 만들고 그 안에서 session 을 여는 것 같은데 굳이 그럴 필요가 없을 것 같다
- dirname basename absoulte relative path realpath
  - 'dirname <path>': Return directory name of path.
  - 'basename <path>': Return base name of path. (<path> = <dirname>/<basename>)
- shell script
  - '$0' first word of command string
- 'find' command 의 option 중 '-name' 은 case sensitive 하고 '-iname' 은 case insensitive 하다
- basename 의 버그: 인자가 2 개 일 때 첫 번째 인자만 처리한다
- 'for word in hello world; do echo $word; done'
- '<C-k>' in cli: Delete to the end of the line
- '<C-w>' in cli: Delete backward to the beginning of the word
- '<C-t>' in cli: Transpose two characters
- '<S-Command-double_click>' in terminal: Select path or URL
- '<Command-e>' in terminal: Find selected word
- '<Command-double_click>' in terminal: Open URL
- 'drag-and-drop file from finder' in terminal: Add the complete path to a file
- '<O-click>' in cli: Reposition the insertion point
- 셸 스크립트를 실행할 때는 새로운 셸에서 실행하는 것을 원칙으로 하자(모듈화)
  - 단, alias 설정등 셸 윈도우를 처음 띄울 때 필요한 설정은 source 로 실행한다
  - 간단한 함수 수준도 모듈화해서 사용하는 것이 좋겠다. 정말 빈번히 사용하는 것만 
- set, typeset, alias, env
- function 은 실행중인 shell 상에서 호출되면, 블럭 안에서 바꾼 변수의 값이 밖에서도 유지된다
- all 을 .PHONY 에 적어두지 않았을 때 all 이라는 이름을 가진 파일이 존재하는 지는 의존성이 없고, 의존성에 명시된 파일이 존재하는지 확인하여 없으면 rule 을 실행한다
- rule 의 dependency 와 상관 없이, .PHONY 에 명시했는지 상관 없이, 파일이 없는데 실행하고 나서 파일이 생성되지 않고, 실행 가능한 recipe 이 존재하면 rule 이 실행된다
- 통찰력있는 분석을 제시했는가, 그러지 못했는가, 이는 한끝 차이지만 중요한 차이이다

2021-06-07
- [stackoverflow/How can I delete a newline if it is the last character in a file?]
- how to implement hash function?
- 'git ls-remote <remote>': 로 romote repository 를 list 할 수 있다
- 'bash' 에서는 'POSIX sh' 과 달리 '[[' 를 사용할 수 있는데, 이를 사용하면 내부에서 변수를 사용할 때 double quote 를 사용하지 않아야 한다
- '$?' 는 이전 판단문의 결과를 출력한다
- 'git tag -d <tag>'
- 'git push -d <remote> <tag>'
- 'git ls-remote --tags'
- 'git show <branch>:<file>'
- 'git checkout <branch> -- <file>': also do stage
- ssh 관리는 env 가 해주나?
  - 지금은 따로 관리 안해주고 직접 ssh 구축 후 git clone 하게 되어 있는데 이후에는 봐서 없으면 해달라고 요청 메세지 보내고 다시 시도해주세요 > 이런 식으로
  - 그리고 환경 구축하는 script 를 모듈화할 수 있는지 생각 해보자
- [nvie/A successful Git branching model](https://nvie.com/posts/a-successful-git-branching-model/)
  - 여기에서 말하는 git model 은 dev 에 feature 들을 merge 할 것을 목표로 한다
  - 만약 나의 seoul42_project repository 처럼 각 프로젝트(== feture branch)를 굳이 하나의 main branch 로 통합할 필요가 없다면 발산형으로, 브랜치 끝을 tag 로 장식해두면 좋을 것 같다
    - 작성한 feature branch 들을 통합해서 하나의 실행파일을 생성하는 것을 목적으로 하는 경우 main branch 로 merge 하는 것이 맞을 것이다
- 작업 수행 흐름
  - 1. 예측한다
  - 2. 시도한다
  - 에측하지 못한 일이 발생했을 때 행동 방침
    - 모든 사람이 해당 사안에 대한 의견을 제시한다
    - 최종적으로 실현 가능한 유용한 방안을 추려낸다 (갯수는 상관 없다, 납득 가능하면 상관 없다)
    - 기록으로 남겨두고 한가지를 선택해서 시행 (다수결을 하든 랜덤을 하든, 어차피 다 경험이 된다)
    - 이후 좋았는지 나빴는지 회고 (및 기록을 통해 경험 축적)
- 도시를 건설한다고 생각해보자
  - 우선 조악하더라도 기능적으로 '도시' 라고 부를 수 있을 만한 것, 혹은 도시를 '흉내'내는 것을 만든다
  - A 건물과 B 건물을 각각 짓고 있는데
  - B 건물이 A 건물의 상하수도관을 연장해서 사용하려고 할 때
  - A 건물이 상하수도관을 수정하려고 하면 B 건물에도 영향이 간다
  - 그럼 이를 미연에 방지하기 위해 전체 상하수도관 관리를 분리해두고
  - A 건물과 B 건물은 상하수도관 infra 위에서 생성한다고 할 때
  - 만약 B 건물이 상하수도관을 바꾸고 싶다면 상하수도관을 바꾼 후 이를 rebase 해서 사용하고
  - 상하수도관을 사용하는 모든 대상은 바뀐 상하수도관을 rebase 해서 사용하면 될 것이다
    - 근대 그러면 B 건물 담당자가 바꾼 상하수도관 변경 사항이 A 건물에 영향을 주면 어떻게 하지?
    - 거기다가 상하수도관 뿐만 아니라 건물을 위한 전기, 도로, 등 많은 infra 들은 어떻게 의존성을 두지?
  - 즉 모든 infra 위에 건물을 짓는 것이 아니라
  - infra 와 건물이 같은 계층급의 feature branch 에 속하게 되는 것이다
  - sudo function 만 작성해두고 이 sudo function 을 implement 하는 feature branch 를 만드는 것이다
  - release branch 는 외부 공개를 위한 
  - dev 는 모든 feature branch 의 base 이다
  - feature branch 들의 기능을 사용하는 app logic 을 작성하는 코드 또한 따로 feture branch 를 만들어서 작성 후 merge 해야 할 것이다
    - 이 때 이 branch 는 우선 sudo function 을 사용한다
  - 만약 새로운 feature branch 의 요구가 필요하고, 이를 기반으로 하는 sudo code 가 dev 에 추가되어야 할 경우에는 dev 자체를 update 한다
  - 그러면 다른 feature branch 들은 새로운 sudo code 를 사용할 수 있게 되고, 동시에 sudo code 를 위한 feature branch 를 만들 수 있게 된다
  - feature branch 가 완성되면 dev 는 그 branch 를 merge 하고 임무를 마친 feature branch 는 delete 한다
  - release tag 는 외부 공개용으로 완성된 commit 에 tag 한다
  - hot fix 가 있을 경우 hot fix 를 적용하고 hot fix version 으로 tag 한다
  - prerelease branch 는 차세대 공개할 release version 을 완성시키기 위해 버그를 수정하고 작동을 테스트해서 마무리하는 branch 이다
  - prerelease branch 의 목표를 달성하면 release tag 를 붙이고 hot fix 와 유사하게 dev 와 merge 한 후 계속 dev branch 를 rebase 추적한다
  - dev branch 는 차세대 release version 을 위한 feature 들을 수합하고 대기한다
    - 차세대 prerelease branch 도 항상 존재한다
  - 만약 건물 A 와 건물 B 를 위한 feature branch 를 만들어서 사용하다가 상하수관을 분리해야하는 일이 발생한다면
    - 1. dev 에 sudo code update
	- 2. sudo code 를 implement 하는 feature branch 생성 및 기존의 open branch 들을 최신 dev branch 로 rebase
- git 을 연습하는 용도의 도시 건설 project 가 있으면 재밌겠다
- apple 의 통합 기능은 연결이 가능한 환경에서는 훌륭한 사용 경험을 선사하지만 조금이라도 문제가 생기면 고질적은 치유 불가능한 문제가 되어 버린다
  - ex> 클러스터 컴퓨터의 apple id 적용 시 나타나는 버그
    - 이런 경우 직접 관리 가능한 방법이 있으면 유용하다
- 시간을 신경쓰지 않고 집중하기 위해 시야에 들어오던 시계를 제거했더니 효과가 좋았다. 무심결에 시계를 보았는데 없어서 시간을 알 수가 없어서 좋았다
- 꼼꼼해지는 과정은 마감을 여러 번 거치면서 학습하는 것이다. 매 번 꼼꼼하기 위해 노력하는 것은 그다지 효율적이지 않을 수 있다
  - 기준 자체는 높게 제시하되, 제출물을 제출할 때에는 제한이 없게 해서, 여러 번 시도하도록 유도하자
- 내가 평가를 한 시간 씩 진행하면 한 숨을 내쉬기 시작하는 분이 한 분 있는데, 어떻게 하는 것이 옳바른 해결책일까?
- 에어컨을 켜 놓은 후 창문이 열려있는 상황에 대한 해결책
  - 누군가 에어컨을 켰다, 누군가 창문을 열었다
  - 어어컨을 끄는 사람은 없다, 창문을 닫는 사람도 없다
- hard link 는 같은 inode 를 사용하는 파일을 생성하는 것이다
  - 그런데 이것은 file system 의 구체적인 특징이기 때문에 OS 공통의 file system 을 추상화한 git 의 경우 hard link 를 file 로서 기록하고, symbolic link 는 구체적인 inode 연결 이외의 공통적인 file system 특징이므로 일반 파일과 구분하여 기록한다

2021-06-06
- 삭제된 'remote branch' 를 track 하는 'remote-tracking branch' 가 local 에 남아 있을 때 없애는 방법: 'git branch -dr origin/<branch>'
  - '-r' option 은 'https://git-scm.com/docs/git-branch' 에서 확인할 수 있으며 'remote-tracking branch' 를 의미한다
- 확실히 void * 를 사용해서 generic 한 값을 담을 수 있도록 구성하는 것이 코드 재사용에 굉장히 큰 역할을 하는 것 같다. C++ 이나 swift 처럼 generic type 을 위한 코드를 생성해주는 기능이 없다면(추측) 컴파일 단계에서 처리 불가능한 부분을 가능한 run time 에서 적용이라도 하기 위해 'void *' type 으로 content 를 정의하여 generic 한 structure 를 구성해보도록 하자
- 에어컨을 틀고 싶다면 창문을 다 닫았으면 좋겠다! (환경을 소중히!)
- 비교문을 작성할 때는 대소 관계에 따라 작은 것이 왼쪽, 큰 것이 오른쪽에 작성하는 것이 '아니라' 주어 역할을 하는 것이 왼쪽, 비교 값이 오른쪽에 두도록 하자 -> 문장처럼
- big o 계산 -> 수열의 합, 시그마 계산, 수열을 함수로 만들고 적분
- 다음에는 에러 전용 구조를 만들도록 하자

2021-06-05
- 프로그램 함수 작성 시 함수의 종류는 크게 2 가지로 나눌 수 있다
  - 첫 번째는 기능을 구현하는 함수이다
    - 추상적인 동작이 중요한 것이 아니라, 하나의 구체적인 기능을 구현하기 위해 작성하는 함수이다
	- 이런 함수는 자신이 수행하는 기능을 중심적으로 서술해야 가독성이 좋다
  - 두 번째는 추상적인 동작을 구현하는 함수이다
    - 구체적인 동작이 작성되어 있지는 않지만 다른 함수들을 호출하면서 추상적인 동작을 수행한다
	- 이런 함수는 전체적인 흐름을 중심으로 서술하면 가독성이 좋다
- 빡센 최적화를 할 때는 내가 함수의 입력값과 출력값을 제한하면서 특별한 case 의 guard 를 넣지 않을 수도 있지만, 프로그램의 크기가 조금씩 커지고, 모든 것을 control 할 수 없는 경우, 다 기억하지 말고 적절히 guard 를 하도록 하자
- 최적화 전용 기능은 주 작업과 상관이 없는 내용이므로 분리하여 껐다 켰다 할 수 있도록 구성하면 좋은 것 같다
- 프로그램을 확장하는 방법 1. 원래는 상수, 변수를 사용하던 부분을 변수, 함수를 사용하도록 바꾼다
- '=' 는 강조하는 기능이 있다
  - 만약 '=' 를 사용하면 해당 부분이 강조되는 것이고, 사용하지 않으면 이후 부분이 강조된다
- create, edit, delete
- 실제 파일을 삭제하는 'git clean' command 가 실행되기 위해서는 '-f' 옵션을 줘야 하도록 만든 것이 마음에 든다. 마치 '정말 실행하시겠습니까?' 라고 묻는 것 같이 보인다
- 저 지랄맞은 현충일 캘린더 알림은 왜 계속 뜨는거지?

2021-06-04
- 전에 한 번 빼먹고 특별한 값에 대한 basis_vector 적용을 그냥 넘긴적이 있는데, 이로 인해 오늘 원기둥을 출력할 때 0,1,0 을 normal 로 하는 원기둥의 위, 아래 면을 그릴 때 제대로 출력되지 않는 문제가 있었다. 새로운 기능을 구현할 때는 그 기능을 구현하기 위한 sudo code 를 작성하고, 더 필요하다고 생각이 나면 그 즉시 코드에 sudo code 를 바로 바로 추가하여, 구현하려고 생각만 하고 잊고 마는 일은 없도록 하는 것이 좋겠다
- 지금 bfs 와 lss 를 위한 데이터 및 인스트럭션을 각각 작성했는데, 이것 외에도, 마치 서버와 클라이언트처럼, 서버역할을 하는 데이터는 공통으로 두고 이를 통해 bfs 및 lss 전용 structure 를 다뤘으면 어땠을까?
- 제발 키보드 좀 가져오자!! 클러스터 키보드 고장난거 걸리면 너무 불편하다!!
- push_swap 의 경우 instruction 과, 가장 알맞은 구조를 작성하고, 이 구조를 가져와 사용하는 형식으로 진행했으면 더 좋았을 것 같다
- 자동으로 .c-.h pair 생성하는 프로그램
- typedef 보다 structure 를 사용하면 확장성 측면에서 유리하다
  - typedef 는 구조체와 달리 새로운 맴버 변수를 추가할 수 없어서, 이런 변경을 해야할 때는 큰 노동력이 요구된다
  - 반면 structure 는 쉽게 새로운 맴버 변수를 추가할 수 있다
- 항상 처음에는 확장하기 쉬운 유연한 구조로 프로그램 작성을 시작하자
  - 프로그램이 배포되기 전까지는 계속 계속 계속하여 프로그램이 유기적으로 변할 가능성이 있다
  - 후에 배포 전후로 성능을 개선해주도록 하자
- buffer 가 자신 만의 특수한 수정 기능을 가지고 있다면, 이름을 단순히 buffer 로 할 것이 아니라 접두사나 접미사를 붙이는 것이 좋을 것 같다
- instruction 을 화면에 출력하는 print 함수 파일도 따로 있었으면 좋았을 것 같다
- 맴버 변수의 데이터 타입은 선언만 되어서는 정의하는 것을 컴파일러가 에러를 발생시킨다. 꼭 구현을 include 해야 한다
- 텍스트를 생성하는 작업장이 있었으면 좋겠다

2021-06-03
- 'git show <commit hash>:<path/of/file>': Display content of the file to stdout.
- 'git checkout <branch or commit> -- <path/of/file>': Get file from another branch or commit.

2021-05-31
docker 를 run (또는 start) 할 때 실행한 명령이 종료되면 다른 실행중이던 명령도 다 종료되면서 container 가 exit 상태가 된다

2021-05-30
- 어떤 대상과 비교를 할 때는 그 대상과 설명하는 내용하고의 공통점과 차이점을 가능한 한 구체적으로 해야 좋다
  - 예시> 신분증 제시와 ssl
    - 공통점: 제 3 자로부터 공인 받은 것으로 자신의 신분을 객관적으로 알린다
	- 차이점: 신분증은 고객이 서비스 제공자에게 자신의 신분을 알리고, ssl 은 서비스 제공자가 고객에게 자신의 신분을 알린다

2021-05-27
- 어느 정도까지 최적화를 진행해야 하는가?
  - 사용하는 프로그램에 따라 정도가 다르다고 생각한다
  - 각 프로그램마다 가독성을 최우선으로 여기고, 그 다음에 최적화를 고려하도록 하자
  - 가독성이 떨어지는 최적화는 해당 언어를 사용하여 프로그램을 작성하는 프로그래머의 역할이 아니라 언어를 컴파일하는 컴파일러를 제작하는 프로그래머의 역할이다
0. 원형 양방향 모델, front 만 존재
1. 정렬한다
2. 거꾸로 돌면서 한바퀴를 순차적으로 돌 때 가장 큰 수부터 차례로 체크하여 숫자를 얼마까지 만나는가?
3. 그 수보다 하나 작은 수가 나올 때까지 더 작은 수는  b 로 이동시킨다, 이 때 ra 로 돌린다
4. 그 수는 b 의 하단에 보관하고 분류가 끝나면 a 로 옮긴다
5. 점차 작은 수를 가져온다, 이 때는 rb 또는 rrb 중 빠른 것을 선택한다
6. 만약 어떤 수를 탐색하던 중 그 수보다 바로 하나 작은 수를 먼저 마주치면 a 의 하단에 저장해놓으면 좋지 않을까?

2021-05-26
- 탐색의 제한을 하는 부분은 어디에 둘까?
  - instruction 과 별개로 작동했으면 좋겠다
  - 'check_should_instruction_pa() -> pa()' 처럼 instruction 을 실행할지 건너뛸지를 체크하는 함수를 instruction 전에 실행하는 것이 좋겠으나, 성능상 우선 통합하도록 하자
- 어떤 구조체를 생성할 때, 만약 값이 밖에서 자유로운 값을 설정해주려면 인자로 받도록 하고, 주변 환경에 구애받지 않는다면 내부에서 생성해주도록 하자
- 구조체도 이름이 여러개면 좋을 때가 있는 것 같다
  - branch-node 개념을 list-element 로 구현함
    - 외부에서는 branch-node 가 좋고 내부적으로는 list-element 가 좋다
- array 만 heap 에 할당하고 그 외에 정적 크기를 갖는 list, queue 등은 stack 에 할당할까 생각해 보았는데, 매번 새로운 스택에서 list 와 queue 와 array 의 주소 값을 연결해줘야하는 overhead 가 존재해서, 그냥 heap 에 다 할당하는 것이 좋을 것 같다 (한 번 만들면 프로그램이 끝날 때까지 해제 없이 사용하기 때문에)
- 다음 프로젝트는 generic 한 구조로 진행해보자. 우선 성능을 신경쓰지 않고 작성한 후, 문제가 된다면 시간 복잡도가 가장 복잡한 곳부터 수정하는 방식이다
- 아무 값도 넣지 않아도 기본적으로 작동하도록 만들자
  - 직접 값을 설정하도록 만들고, 딱 한 번만 값을 쓰도록 여러 함수에 나눠놓았더니, 어떤 값이 설정됬는지 안됬는지 확인하기가 무척 어려웠다
- count 의 증가는 앞에서, 혹은 뒤에서?
  - while 에서 자연스럽게 1 씩 증가하는 경우 convention 적으로 뒤에 배치하도록 하자
  - 그 외에는 우선 loop 안에 count 의 증감식을 작성하고, 다른 내부 표현식들의 위치를 결정하자

2021-05-21
- 값을 읽어서 model 을 만드는 정도의, 성능에 critical 하지 않은 경우는 하드 코딩하여 성능 향상을 추구하기 보다는 유연하고 확장적인 추상화 모델을 만들도록 하자
- name convention 을 통일하기 위해 vector3 를 p_vector3 로 하는 것이 더 좋았을 것이다
- [stackexchange/Vim search replace all files in current (project) folder](https://vi.stackexchange.com/questions/2776/vim-search-replace-all-files-in-current-project-folder)
  - ':args <file or directory>': similar 'vim <file or directory>' on cli
  - ':argdo <vim command>': do command to all open file

2021-05-20
[wiki/regular expression](https://en.wikipedia.org/wiki/Regular_expression)
- '.' 은 '\n' 을 제외한 모든 문자와 matching 된다는데 regex 는 '\n' 와 matching 은 안되는 걸까?
  - 여러 주변 환경에 따라 추가할지 말지는 취향이다
[wiki/glob](https://en.wikipedia.org/wiki/Glob_(programming))
- '*': matches any number of any characters including none
- '?': matches any single character
- '[abc]': matches one character given in the bracket
- '[a-z]': matches one character from the (locale-dependent) range given in the bracket
- '[!abc]': matches one character that is not given in the bracket
- '[!a-z]': matches one character that is not from the range given in the bracket

2021-05-18
```zsh
Undefined symbols for architecture x86_64:
  "_bmp_write_image_to_file", referenced from:
      _generate_image in t_application.o
ld: symbol(s) not found for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
make: *** [miniRT_debug.out] Error 1
```
  - 위와 같은 메세지를 띄우며 컴파일이 한참 진행중이다가 완료되지 못하고 끝에 link error 가 발생하는 경우가 있다
    - 이 경우 컴파일러가 해당 함수가 존재함을 function prototype 을 통해 인지했기 때문에 컴파일 에러가 발생하지는 않았지만 프로그램의 binary code 를 생성하기 위해 찾아보니 실제 해당 함수의 binary code 가 존재하지 않는 경우 출력되는 에러 메세지이다
- [linuxconfig/Understanding of ls command with a long listing format output and permission bits](https://linuxconfig.org/understanding-of-ls-command-with-a-long-listing-format-output-with-permission-bits)
  - permission / number of linked hard-links / owner of the file / to which group this file belongs to / size / modification or creation date and time / file or directory name
- directory 를 hard link 로 만드는 것은 간단하지 않다, 그러므로 libft directory 를 hard link 로 만들어서 사용하는 것은 norm 을 벗어나고 나서 생각하자

2021-05-17
-[superuser/How to sort first directories then files etc… when using “ls” in Unix](https://superuser.com/questions/109537/how-to-sort-first-directories-then-files-etc-when-using-ls-in-unix)
  - ls | sort -k1,1 -k9,9 -r
- 화면에 vim 을 10 개 이상씩 가득 띄워놓고 보는 것은 솔직히 썩 바람직한 방식은 아닌 것 같다. 오늘 keynote 로 struct 간의 reference 그래프를 그려보았는데, 이렇게 하고 보니 전체적인 프름이 한 눈에 보였고, 어떻게 추상화할지를 판단하기 훨씬 수월했다 (전에는 거의 불가능하거나 오랜 시간을 들여야만 했다)

2021-05-13
- search keyword
  - architecture
  - underneath
  - underlying mental model and architectur
- line 을 읽는 기능과 split 을 구현할 때, 이미 많은 것을 구현한 miniRT 폴더에서 진행하는 것이 아니라 새로운 모듈을 만드는 장소를 따로 만들어서 진행하고, 기능이 충분히 구현되었다고 생각하면 그 때 합치는 것이 좋을 것 같다

2021-05-07
0x00 ~ 0x01:  2 "BM" as ascii
0x02 ~ 0x05:  4 total size of bmp file in byte (file header size (14) + dib header size (124 in v5) + color array size (width * height * bpp / 8)
0x06 ~ 0x09:  0 reserved, set 0
0x0a ~ 0x0d:  4 offset of color array (138 in v5)

0x0e ~ 0x11:  4 bV5Size: dib header byte size
0x12 ~ 0x15:  4 bV5Width: 가로 픽셀 수
0x16 ~ 0x19:  4 bV5Height: 세로 픽셀 수
0x1a ~ 0x1b:  2 bV5Planes: 1 고정
0x1c ~ 0x1d:  2 bV5BitCount: bit per pixel
0x1e ~ 0x21:  4 bV5Compression: 압축 없으면 0
0x22 ~ 0x25:  4 bV5SizeImage: 온전한 이미지 크기
0x26 ~ 0x29:  4 bV5XPelsPerMeter: 잘 모르면 0
0x2a ~ 0x2d:  4 bV5YPelsPerMeter: 위와 동일
0x2e ~ 0x31:  4 bV5ClrUsed: 위와 동일
0x32 ~ 0x35:  4 bV5ClrImportant: 위와 동일
0x36 ~ 0x39:  4 bV5RedMask: big endian 형식의 argb mask
0x3a ~ 0x3d:  4 bV5GreenMask: 위와 동일한 형식
0x3e ~ 0x41:  4 bV5BlueMask: 위와 동일한 형식
0x42 ~ 0x45:  4 bV5AlphaMask: 위와 동일한 형식
0x46 ~ 0x49:  4 bV5CSType: 42 47 52 73
0x4a ~ 0x6d: 36 bV5Endpoints: 잘 모르면 따라하기, 아마 색상의 한계를 결정
	0000040                               80 c2 f5 28 60 b8
	0000050 1e 15 20 85 eb 01 40 33 33 13 80 66 66 26 40 66
	0000060 66 06 a0 99 99 09 3c 0a d7 03 24 5c 8f 32
0x6e ~ 0x71:  4 bV5GammaRed
0x72 ~ 0x75:  4 bV5GammaGreen
0x76 ~ 0x79:  4 bV5GammaBlue
0x7a ~ 0x7d:  4 bV5Intent: 이 이미지의 의도에 대한 데이터를 담는다. 04 00 00 00
0x7e ~ 0x81:  4 bV5ProfileData: 0
0x82 ~ 0x85:  4 bV5ProfileSize: 0
0x86 ~ 0x89:  4 bV5Reserved: 0

- 코드에 압도되는 것은 좋지 않은 상황이다. 앞길이 막막해지고, 어딜 건들여야할지 바로 보이지 않을 때가 있다
- 코드의 많은 부분에 영향을 줄 경우 2 가지 경우의 수가 있다
  - 오류가 나지 않는 경우: 이 경우는 빠르게 굴러가는 프로그램을 작성할 수 있어 좋다
  - 오류가 발생하는 경우: 이 경우는 끔찍하다. 코드의 너무 많은 부분을 바꾸었기 때문에 어디에서 문제가 발생했는지 알 수 없게 되기 싶상이다
- lldb 로 특정 변수 값이 변경되는 지점을 break 하는 것이 가능 'watchpost'
- lldb 로 특정 frame 으로 이동하는 것이 가능 up, down, frame set
- 나는 위치와 방향에 따른 모든 경우를 출력 가능하도록 구현햇는데, 다른 방법으로 default 상태를 구현하고 이를 평행 이동, 회전 이동 하여 도형의 최종 상태를 출력하는 방법도 있는 것 같다

2021-05-06
- 최적화를 위한 다양한 기법은 멀리서 보면 서로 다 다르고 각각을 공부해야 한다고 생각할 수도 있다. 하지만 하고자 하는 진정한 마음이 있고, 본질을 공부한다면 그것들은 공부하지 않아도 만들어낼 수 있는 것들이다, 라고 생각한다
- t_bmp 가 엔디안을 신경 쓸 필요는 없다. 이미지를 생성하여 서버에 전송할 때 빅 엔디안이면 스몰 엔디안 형식으로 바꾼다던가, 등 작업을 하기 때문에 bmp 는 이렇게 생성된 이미지를 저장하기만 하면 된다
  - 아니다. 이미지의 주소를 받아오면서 얻는 endian 값은 서버의 endian 이기 때문에 이것이 적용된 상태로 이미지를 저장하면 안된다. 현재 프로그램이 작동하는 시스템의 endian 을 토대로 small endian 방식으로 저장하면 된다
  - endian 은 메모리와 관련된 것이라고 한다. 따라서 현 endian 을 자연스럽게 저장하면 제대로 된 bmp 파일이 되지.. 는 않을 것 같다
- 왜 해야하는가, 왜 추가해야하는가
  - 지금까지 만든 것은 어떤 기능을 가지고 있는가
  - 지금까지 만든 것은 무엇인가
    - 새로운 기능을 추가하면 기존과는 무엇이 다른가
	- 꼭 추가해야만 하는가
- 꿈을 꿔라, 그리고 끊임없이 꿈을 위한 목표를 만들어라
0x00 ~ 0x0d: bitmap file header
0x0e ~ 0x11: bV5Size
0x12 ~ 0x15: bV5Width
0x16 ~ 0x19: bV5Height
0x1a ~ 0x1b: bV5Planes
0x1c ~ 0x1d: bV5BitCount
0x1e ~ 0x21: bV5Compression
0x22 ~ 0x25: bV5SizeImage
0x26 ~ 0x29: bV5XPelsPerMeter
0x2a ~ 0x2d: bV5YPelsPerMeter
0x2e ~ 0x31: bV5ClrUsed
0x32 ~ 0x35: bV5ClrImportant
0x36 ~ 0x39: bV5RedMask
0x3a ~ 0x3d: bV5GreenMask
0x3e ~ 0x41: bV5BlueMask
0x42 ~ 0x45: bV5AlphaMask
0x46 ~ 0x49: bV5CSType
0x4a ~ 0x6d: bV5Endpoints
0x6e ~ 0x71: bV5GammaRed
0x72 ~ 0x75: bV5GammaGreen
0x76 ~ 0x79: bV5GammaBlue
0x7a ~ 0x7d: bV5Intent
0x7e ~ 0x81: bV5ProfileData
0x82 ~ 0x85: bV5ProfileSize
0x86 ~ 0x89: bV5Reserved
- BMP format 으로 이미지를 저장하기 위해 file_header[], dib_header[] 등을 만들었는데, 각 데이터의 index 를 define 하여 데이터를 쓰고, 만들어진 배열을 파일에 write 하려고 했다. 그런데 index 로 입력한 값을 그냥 배열 통채로 사용해버릴 때는 문제가 없었지만, 결국 이미지의 width, height 등은 다른 곳에서도 쓰일 수 있기 때문인데 일단은 다른 곳에 있는 데이터를 가져다가 사용하기로 했다 (width 와 height 는 p_image 로부터 등)

2021-05-05
- 테스트 환경 구성하여 테스트 진행
  - 이점: 원하는 값을 넣고 결과 값이 잘 나오는지 확인할 수 있다
  - 디버깅 툴과의 차이점
    - 디버깅 툴은 에러를 잡아내는 것: 실제 프로그램을 실행해볼 수 있지만 테스트에 비해 부담스럽고 값을 원하는데로 마구 넣어보기 번거롭다
- 프로그래머가 하는 일은 글을 쓰는 것이다. 문체도 물론 중요하지만 가장 중요한 것은 얼마나 방대한 세상을 가지고 있느냐 하는 것이다. 그리고 그것을 글로 잘 풀어냈는가이다
- 프로그램을 만드는 과정에는 재밌는 과정도 있고 재미 없는 과정도 있다. 다소 재미 없는 과정이라면 그 과정에 당신의 꿈을 담아라
  - 가령 특정 파일을 파싱하는 기능을 추가하거나, 출력된 이미지를 파일로 저장하는 기능을 추가하는 작업은 지루할 수 있다. 하지만 그것이 불가능한 경우와 가능한 경우를 생각하면서 있으면 정말 좋겠다고 생각을 하는 것이다
- 평면 도형의 normal 과 ray 의 direction_vector 과 수직인 경우 intersects, blocks 는 어떻게 처리해야 할까?
  - 평면 도형의 두께는 0 으로 생각하자
- antialising 말고 테두리 픽셀의 절확한 밀도를 계산해서 출력하면 어떨까?
- rgb 소자들이 뭉쳐 하나의 픽셀 을 보는 것처럼, 여러 픽셀들이 뭉쳐 하나의 점을 볼 수도 있다. 이로 인해 픽셀 단위의 단절된 이미지를 자연스럽게 만들 수 있다
- 기울기가 정확히 축과 평한한 경우 등 double 의 오차로 인해 충돌 여부가 판가름 나는 수도 있다. 이런 경우는 따로 처리하지 않겠다. 처리를 하는 것도 야매로 가능하지 정확한 계산은 불가능해 보인다 (이미 정확히 계산한 결과가 저런 것이다)
  - 마찬가지로, 오차로 인한 그림자 여부도 추가로 잡아주지는 않겠다
- [BMP file format](https://en.wikipedia.org/wiki/BMP_file_format)
  - bitmap 은 더 포괄적인 의미이고 BMP 는 bitmap 중 특정 포멧이다
  - 아마 최적화를 위해 프로그램 내부적으로 사용되는 이미지는 자신만의 bitmap 데이터 타입을 정의하는 모양이다

2021-05-04
- 빛이 평면 위의 점일 경우를 잘 처리해주자
- 일단 돌아가는 프로그램을 작성하라, 그리고 계속 보다보면, 그리고 반복해서 작성하다 보면, 최적화를 할만한 부분이 보인다!
  - 물론 최소한의 계획은 가지고 프로그램을 작성해야 한다
    - (최소한의 계획이라는 녀석은 주관적이다)
- 제대로 표현하지 않으면 어차피 나중에 계속 후회한다
  - 일단 내 잘못이면 나중에 후회할 확률이 높다 문젝 없더라도 사과하는 것이 맞다 그게 맞다
- x 와 z 가 모두 0 인 카메라 orientation 을 받을 때 xz_magnitude 가 0 이 되어 0 으로 나누게 되는 문제

2021-05-03
- 공유의 목적이 아닌 기록 및 보관 용도로는 잘 꾸미는 데에 시간을 투자할 필요가 없으므로 (최소한의 가독성 확보가 목표이다) md 포멧보다는 txt 포멧을 사용하는 것이 유리하다
- 우연히 발견한 것이지만 double 의 오차로 랜덤하게 0 또는 1 을 생성할 수 있을 것 같다
- pow 의 남발을 지양하고 sqrt 와 * 를 사용하자

- geometry 위의 어떤 점 P 가 line 과 geometry 가 만나는 가장 가까운 점인지를 확인하기 위해 intersects 만으로는 부족하다. intersects 는 가장 가까운 k 값을 반환하지만, 가장 가까운 점이 P 일 때 P 를 위한 k 값과 가장 가까운 k 값을 비교하면 double 타입이기 때문에 오차로 인해 같은지 판단하는건 부정확하다. 따라서 도형마다 어떤 점이 도형 위에 있는 점이라고 가정하고, 그 점이 빛을 받는 점인지 확인할 수 있도록 추가적인 함수를 둬야 좋겠다
- reference type 은 instance method 의 첫 인자로 instance 를 받고,  value type 은 instance method 의 마지막 인자로 instance 를 받도록 하면 좋을 것 같다
- vector3_init() 추가
- vector3_cos_theta() 추가
- 빛의 세기는 거리의 제곱에 반비례한다
  - 이 경우 특정 부위는 과하게 밝게 표현단다
    - 이를 해결하기 위해서는 2 차 3 차 반사를 적용해야 한다
- 삼각형은 각도록 점의 위치가 안에 있는지 밖에 있는지를 구분했다

2021-04-11
- 다음 두 함수의 차이가 있을까?

int strlen(char s[])
{
	int i = 0;
	while (s[i] != '\0')
		++i;
	return i;
}

int	strlen(char *s)
{
	char *ptr = s;
	while (*ptr)
		++ptr;
	return (ptr - s);
}

- -1L vs 1UL: unsigned long 타입으로 변환되고 비교한다면 -1L 이 더 크게 된다. 실제는 어떨까?

2021-01-28
클러스터는 예약시스템 지금은 코로나가 심해져서 예약조차 안되는 듯 하다
2.5 단계 밑으로 내려가야 클러스터 사용이 가능하다

2021-01-15
```zsh
% cat display_line.sh
$1 | wc -l
% ./display_line.sh set
      41
% sh display_line.sh set
      41
% zsh display_line.sh set
     145
% set | wc -l
     167
% source display_line.sh set
     167
% bash

The default interactive shell is now zsh.
To update your account to use zsh, please run `chsh -s /bin/zsh`.
For more details, please visit https://support.apple.com/kb/HT208050.
bash-3.2$ set | wc -l
      47
```

- 왜 set 의 결과 값이 달라지는 것일까?

2021-01-14
- 전선이 모든 주파수를 다 통과시키지 못하고 제한된 영역의 주파수만 전달이 가능한 이유가 무엇일까? [youtube](https://youtu.be/1pfTxp25MA8?t=368)
- 디지털 신호도 원하는 주파수를 만들어서 전송할 수 있을 것 같은데 굳이 아날로그 신호로 바꾸어서 전송해야 하는 이유가 무엇일까? [youtube](https://youtu.be/1pfTxp25MA8?t=386)
ttps://opentutorials.org/module/3747

2020-12-25
(T: Think, D: Do)
- T: Ratio of my study and others study
  - Just help others study, and if i get some thought of 'It's not right', then reject it
  - Never present a fish, teach how to get that
- D: More practice the way to use `find` command

2020-12-24
(Q: Question, I: Idea)
- Q: When i set the argument type of main, even making it pointer is common, making it array also possible, will there some difference?
- Q: Will it possible executing according to the extension of file in vim?
  - :set autoindent for .md
  - :set cindent for .c
- I: What about a program which show real memory state on one side and what happenning at code at the other side?
  - Simulate very little computer, so i can see the memory at one display
- Q: Can i access NULL pointer?
- Idea: mobile golf game
  - Scroll the mobile display, if your display stop at to goal, you are hole in one :D

2020-12-23
- Q: I can set the data type of function as array or pointer, if I set the type as array, will it take all feature of array? (or it's actually just pointer)
    char    str[] = "lol";
- Q: imo, `"lol"` might be stored in data block and copy it to str array, correct?

2020-12-08
1.3. x: delete a character
1.4. i: enter `insert mode`
1.5. a: enter `insert mode` with appending

2.1. dw: delete a word
2.2. d$: delete to the end of line
2.3. `command target`: dw, de, d$
	enable target example: w, e, $, 0, b, h, j, k, l, H, L, {, }
2.4. `count command`: 2w, 3e
	0: move cusor  the start of the line
2.5. `command count target`: d2w
2.6. dd: delete a line
	`count command target`: 2dd, 2dw
2.7. u: undo last command
	ctrl-r: redo last undo

3.1. p: put vim's buffer content behind the cursor
	if vim's buffer has a line, put it under line of the cursor
3.2. r: replace a character without mode change
3.3. c target: delete target and enther `insert mode`(change): ce, c$, c2w, 2cw

4.1. ctrl-g: display the path of the file and state
	G: move to the last line of the file
	gg: move to the first line of the file
	count G: move to the count line
4.2. / 'what to search': search downward
	? 'what to search': search upward
	n: search next
	N: search previous
	ctrl-o: move previous cursor position
	ctrl-i: move next cursor position
4.3. %: move to the matching bracket
4.4. :s/old/new/g: subtitute 'old' to 'new'
	:s/thee/the: subtitute only first encountered 'thee'
	:s/thee/the/g: subtitute all(globally) 'thee' to 'the' in this line
	:#,#s/old/new/g: #,# mean the line number of two line
	:%s/old/new/g: search target from whole the file
	:%s/old/new/gc: you can command by prompt whether subtitute or not

5.1. :! 'extern command' <ENTER>: excute extern command
5.2. :w FILENAME: write current file as FILENAME
5.3. :'<,'>w FILENAME: save selected range as FILENAME
5.4. :r FILENAME: read and put FILENAME file under the cursor line
	:r !ls: read and put the result of 'ls' extern command under the cursor line

how to show pressed command state?
default output resolution: 853x480

2020-11-27
which vimmemo
(in vim normal mode): ":echo $MYVIMRC"
	# You can easily find the location and name of the file on any operating system.
how to move cursor to top or bottom of screen in vim?
	# H: move cursor to top of screen.
	# L: move cursor to bottom of screen.
	# {: move cursor to previous paragraph.
	# }: move cursor to next paragraph.
why use link?
	# For to call same function as different names
what is the difference between soft link and hard link?

2020-11-05
c7r9s4% ./a.out test.dat 10
fd: 3 
[ 1]read character: ''(104) 
ret_read           : [1] 
[ 2]read character: ''(105) 
ret_read           : [1] 
[ 3]read character: ''(32) 
ret_read           : [1] 
[ 4]read character: ''(112) 
ret_read           : [1] 
[ 5]read character: '.'(10) 
ret_read           : [1] 
[ 6]read character: '.'(106) 
ret_read           : [1] 
[ 7]read character: '.'(104) 
ret_read           : [1] 
[ 8]read character: '.'(10) 
ret_read           : [1] 
[ 9]read character: '.'(10) 
ret_read           : [0] 

analyze:
test.dat has 8 bytes size.
8th byte(last character of file) is newline character.
after read last character, if you try to read more character, the return value will be 0.
if `read()` try to read impossible, it will return 0.
`read()` function return read byte size.

2020-11-4
"abcd"[2]: has something to think!
strcmp return 2 case (1. -1, 0, 1), (2. ch1 - ch2)

2020-11-1
test git when init pull would delete another file?

2020-10-21
ctrl + u: clear current terminal line befor cursor
ctrl + k: clear current terminal line after cursor
[vim] d: cut selected text
[vim] y: copy selected text
[vim] p: paste selected text before cursor
[vim] P: paste selected text after cursor

2020-??-??
echo "*"    # *
echo '*'    # *
echo /*    # *
echo *    # display all files
echo ~    # display home path
echo ?    # display all 1 character

echo "$truc"    # isACar
echo '$truc'    # truc

cat [-e]
more    # work like man page
head
tail

grep [-iv]

ls bonjour 2> error.log
ls bonjour test* > res.txt 2> error.log
ls bonjour test* 2> error.log | grep test00

cat batman.txt | grep Joker | wc -l
grep Joker < batman.txt | wc -l

echo coucou > res.txt    # write file
echo coucou >> res.txt    # append file

cat << FIN    # read until FIN
ls bonjour *.txt > resultat.txt 2>&1
cat resultat.txt

ctrl d
ctrl c
ctrl \

2020-10-14
gzip -d <file>
tar -zxvf <file>
man cut
man diff
man patch
tar -cf exo2.tar *

2020-10-13
ctrl a
ctrl e

opt <-
opt ->

ctrl u
ctrl k

hexdump

Put some unfamiliar shortcut image aside. 
