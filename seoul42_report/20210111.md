### 1. 학습 날짜

- 2021-01-11(월)

### 2. 학습시간

- 09:30 ~ 11:20 (자가)
- 17:00 ~ 18:40 (자가)

### 3. 학습 범위 및 주제

- netwhat

### 4. 동료 학습 방법

- 해당 사항 없음

### 5. 학습 목표

- netwhat 을 공부하면서 공부하고 싶은 것 공부하기

### 6. 상세 학습 내용

#### [TCP vs UDP](https://www.stevenjlee.net/2020/06/29/이해하기-tcp-와-udp-tcp-vs-udp/)

- TCP 와 UDP 프로토콜은 OSI 7 계층 중 4 계층에서 동작하는 프로토콜로서 각 호스트 간 (예> 클라이언트 <-> 서버) 데이터 전송을 위한 전반적인 조율 담당한다
- 네트워크는 회선 교환 방식과 같이 하나의 회선을 통해서만 데이터를 전송하지 않고 패킷 교환 방식을 사용하여 여러가지 경로를 통해 데이터를 나누어서 전송할 수 있다
- TCP (Transmission Control Protocol)
  - 수신 측에서 데이터를 잘 수신했는지 응답을 하면 그 때 나머지 데이터를 보낸다
  - 호스트 간 신뢰성 있는 데이터 전달과 흐름제어를 가능하게 한다
  - 일반적으로 TCP 와 IP 를 함께 사용한다
  - IP 가 데이터의 배달을 담당하고 TCP 는 전송하는 데이터의 추적 및 관리를 담당한다
  - 프로토콜 번호는 6 이다
  - 처음 TCP 세션을 시작하면 3-Way Handshaking 을 한다
    - 요청 (SYN) -> 응답 (SYN/ACK) -> 확인 (ACK)
	- 순서는 반드시 위와 같다
	- 이후 'Established' 상태가 되어 TCP 커넥션이라는 가상의 통신 회선이 구성된다
  - 데이터를 전송할 때 (세부 내용은 생략)
    - 전송 (Data) -> 확인 (ACK) -> 전송 (Data)
	- 데이터는 확인 응답 -> 전송 제어 -> 흐름 제어 를 통해 주고 받는다
	- 확인 응답에선 시퀀스 번호와 ACK 번호를 통해 데이터를 수신한 위치를 파악하여 수신을 확인한 다음 이후의 데이터를 전송한다
	- 전송 제어에선 특정 시간만큼 기다리는 동안 상대방이 데이터를 수신했다는 ACK 번호를 보내지 않을 경우 데이터를 다시 보낸다
	- 흐름 제어에선 TCP 세션에서 지정된 윈도우 사이즈를 보내는 동안에는 ACK 를 보내지 않고 연속해서 데이터를 보내면서 신뢰성을 유지하는 동시에 전송 효율을 높인다
  - 세션 종료 (세부 내용은 생략)
	- 종료 (FIN) -> 확인 (ACK) & 종료 (FIN) -> 확인 (ACK)
  - 특징
    - 신뢰성 보장 (Reliable): TCP 의 구성 특성상 패킷 손실, 중복, 순서 바뀜 등이 없도록 한다. TCP 와 함께 동작하는 IP 계층의 신뢰성 없는 서비스를 보완한다
    - 연결지향적 (Connection-oriented): 느슨한 연결 (Loosly Connected) 하며 강한 연결 가상 회선과 다르다. 또한 연결 관리를 위해 연결 설정 및 연결 해제 과정을 수행한다.
    - 연결 식별 / 다중화 / 포트번호
	  - 각 호스트의 소켓 (호스트의 IP 주소 및 포트번호) 정보로 하나의 연결 (회선) 임을 식별할 수 있다
	  - 단일 연결 뿐만 아니라 다수 연결의 동시 처리도 가능하다 (패킷 기반 통신)
	  - TCP 는 포트 번호를 참조하여 어플리케이션과의 연결점을 식별할 수 있다
	- 전이중 전송방식 (Full-Duplex, 양방향성): 호스트 간 각각의 프로세스가 서로 동시에 세그먼트를 전달할 수 있다 (데이터 순서 번호 파악 및 유지)
    - 멀티캐스트 불가능: 1:1 통신을 하므로 유니캐스트 통신을 한다. 단일 송신자와 단일 수신자 간에 단일 경로 연결이 설정되는 특징을 갖는다 (단, 차세대 전송계층 프로토콜인 MPTCP 에서는 다수의 경로와 다수의 연결이 가능해졌다)
	- 응용 계층과 바이트의 흐름으로 데이터를 주고 받는다. TCP 계층과 상위의 응용 계층 간 데이터를 주고 받는 과정을 바이트들의 연속적인 흐름으로 보고 이들을 묶어 세그먼트화하여 전송한다. 이는 응용 계층의 개발자들이 흐름제어, 회선 관리, 전송 단위 등을 신경쓰지 않도록 한다 (TCP 세그먼트: TCP 에서 IP 로 전달되는 정보의 단위, 양 끝의 TCP 모듈간에 서로 교환되는 데이터. 대게 수 백 바이트 정도 크기르 나타낸다)
	- 세그먼트화 (데이터를 패키징 처리): 바이트들을 모아서 세그먼트화하고 TCP 헤더를 붙여 이들의 순서를 제어한다. TCP 세그먼트들의 (한 번에 보낼 수 있는) 최대 크기를 MSS 라고 한다 (단, MTU 보다 더 작아야 한다)
	- 흐름 제어 (Flow Control): 송신 및 수신 속도를 일치시키는 작업을 한다. 예를 들어 서버는 100Mbps 속도인데 사용자 컴퓨터는 10Mbps 속도라면 데이터의 손실이 발생할 수 있다. 특히 이런 경우 불필요한 응답과 데이터 전송이 빈번히 송/수신 간에 발생할 수 있다. 이를 방지하기 위해 Stop and Wait 방식과 Sliding Window 방식을 사용한다
	  - Stop and Wait: 전송한 패킷에 대해 매번 확인 응답을 받고 나서 그 다음 패킷을 전송하는 방법
	  - Sliding Window: 수신 측에서 수용 가능한 윈도우 크기만큼 송신 측에서 확인 응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어 기법
	- 혼잡 제어 (Congestion Control): 네트워크가 혼잡하다고 판달될 때 (예> 특정 라우터에 트래픽이 몰릴 경우 호스트는 데이터를 재전송하여 결국 혼잡이 가중됨) TCP 는 데이터의 전송 속도를 강제로 줄인다. 혼잡제어를 위한 주요 방법으로는 느린 시작, 혼잡 회피, 수신 윈도우 및 혼잡 윈도우 크기 결정 등이 있다. 아울러 흐름 제어가 송신 측과 수신 측 사이의 전송 속도를 다루는데 반해 혼잡제어는 호스트와 라우트를 포함한 보다 넓은 관점에서의 전송 문제를 다루는 영역이다
	- 비 실시간적 응용: TCP 통신 방식의 특성상 TCP 는 데이터의 전달에 대한 신뢰성을 보장하지만 속도 지연에는 취약할 수 있기 대문에 실시간 통신이 필요한 상황에서는 대체로 UDP 를 사용한다 (예> 영상 스트리밍 서비스)
  - 헤더 상세 내용
	- Source Port (16 bit): 송신 측의 포트 번호. 응용 서비스에 따라 정해진 포트번호가 있을 수 있지만 대부분 처음 세그먼트를 전송하는 측에서 임의의 포트번호를 할당한다
	- Destination Port (16 bit): 수신 측의 포트 번호. 응용 서비스에 따라 포트 번호가 정해져 있다 (예> SSH, Telnet 등)
	- Sequence Number (32 bit): TCP 의 순서 번호. 통신을 시작하는 호스트 간 임의로 번호를 할당하여 시작
	- Acknowledgment Number (32 bit): 상대방 측에서 보낸 세그먼트를 잘 받았다는 것을 응답하기 위한 번호
	- Header Length - Offset (4bit): TCP 헤더의 길이 (4 바이트 단위). TCP 헤더는 최소 20 bytes, 최대 60 bytes.
	- Reserved (4 bit): 사용하지 않는 필드, 모두 0으로 표기
	- Flag (8 bit): URG, ACK, PSH, RST, SYN, FIN: 제어 비트 (Control bits) 라고도 한다. 세그먼트의 종류를 표
    - Window Size(16 bit): 상대방이 확인 메세지를 보내지 않고도 전송할 수 있는 최대 크기의 세그먼트를 바이트 수로 표기 (흐름 제어의 Sliding Window 기법)
    - Checksum (16bit): 헤더와 데이터의 에러를 확인하기 위한 필드
	- Urgent Pointer (16 bit): 현재 TCP 의 일련번호 (Sequence Number) 로부터 긴급 데이터까지의 바이트 오프셋 (Offset). 즉 긴급 데이터의 위치를 숫자로 표기. 따라서 해당 세그먼트의 일련번호에 Urgent Pointer 값을 더해서 긴급 데이터의 끝부분이 어디인지를 알 수 있다
	- Option (0 ~ 40 bytes): 세그먼트의 최대 사이즈를 지정하는 등 추가 옵션이 있을 경우 표시
- UDP (User Datagram Protocol)
  - 비연결형 서비스를 지원하는 프로토콜
  - TCP 와 비교하여 호스트 간 완전성 도는 신뢰성이 없는 데이터를 전달. 그러나 가상 회선을 굳이 확립할 필요가 없고 유연한 특성이 있어 효율적인 응용 계층의 데이터 전송이 필요한 곳에 적합하다
  - 프로토콜 번호: 17
  - UDP 동작 원리 및 절차
	- 요청 -> 응답, 전송 & 응답, 전송 & 응답, 전송 & ...
  - TCP 에 비해 UDP 는 전송만 할 뿐 확인 응답을 하지 않아 비교적 단순한 구조이다
  - 특징
	- 비연결성이고 신뢰성이 없으며 순서화되지 않은 데이터그램 (Datagram) 서비스를 제공한다
	  - 확인응답 없음: 메세지가 제대로 도착했는지 확인하지 않는다
	  - 순서제어 없음: 수신된 메세지의 순서를 맞추지 않는다
	  - 흐름제어 없음: 흐름 제어를 위한 피드백을 제공하지 않는다
	  - 오류제어 거의 없음: 검사합을 제외한 특별한 오류 검출 및 제어가 없다. 따라서 응용 계층 등의 UDP 를 사용하는 프로그램 쪽에서 오류제어 기능을 스스로 갖추어야 한다 (예> 별도 프로그램을 구현하는 등의 방안이 필요)
	  - 비연결성: TCP 와 같이 Handshaking 과정이 없으므로 논리적인 가상 회선 연결이 필요 없다.
	- 빠른 요청과 응답 및 멀티캐스팅이 가능하다
	  - 빠른 요청과 응답이 필요한 실시간 통신 도는 응용계층 프로그램에 적합하다 (예> 비디오 스트리밍)
	  - 1:n 의 여러 다수 지점에 동시 전송이 가능하다 (멀티캐스팅)
      - 전송 속도에 특별한 제한이 없다
	- 헤더가 단순하다
	  - 헤더는 고정 크기의 8 바이트 (TCP 는 20 바이트) 만 사용한다. 따라서 TCP 와 비교하여 헤더의 처리에 적은 리소스가 필요하다
	- 데이터 전송 단위: 메세지 (TCP 데이터 전송 단위: 세그먼트)
	- 최대 데이터 크기: 65,503 바이트 (65,535 바이트: 에서 UDP 헤더 8 바이트를 제외)
	- 사용 사례: 주로 다음과 같은 실시간성 보장 또는 빠른 연결이 필요한 서비스들에 이용된다
	  - 도메인 이름 서비스 (DNS)
	  - IPTV
      - 음성 인터넷 프로토콜 (VoIP)
	  - TFTP
	  - IP 터널
	  - 비디오 스트리밍
	  - 온라인 게임
  - 헤더 상세 정보: TCP 의 헤더 구조에 비해 UDP 헤더의 구조는 매우 단순하다
    - Source Port (16 bit): 출발지의 포트 번호. 응용 계층의 서비스에 따라 특정 포트 번호로 정해지는 경우도 있지만, 대부분 처음 UDP 메세지를 전송하는 측에서 할당하는 임의의 번호를 사용
	- Destination Port (16 bit): 목적지 포트번호를 표시. 응용 계층의 서비스에 따라 특정 포트 번호가 지정되어 있을 수 있다 (예> DNS 의 53)
	- Length (16 bit): 헤더와 데이터를 포함하여 전체 UDP 메세지의 길이를 바이트 단위로 표시한다
	- Checksum (16 bit): 헤더와 데이터의 에러를 확인하고 검출하는 필드. UDP 헤더는 에러 복구를 위한 필드가 필요 없으므로 TCP 헤더에 비해 간단한 구조이다
- MPTCP (Multipath TCP)
  - MPTCP 는 다수의 TCP 경로를 구성하고 구성한 다수의 경로로 동시에 데이터를 송수신하는 방법이다
  - 예를 들어 100 Mbps 속도의 LTE 와 500 Mbps 의 Wi-Fi 가 있으면 MPTCP Gateway 는 이를 하나의 망 인것처럼 구성하여 최대 600 Mbps 를 사용할 수 있게 해준다

#### [DNS (Domain Name Server)](https://www.stevenjlee.net/2020/07/08/이해하기-dns-domain-name-server/)

- DNS 란 전화번호부와 같은 역할을 하는 서버 또는 시스템을 의미한다
- 예를 들어 'www.stevenjlee.net' 처럼 사람이 쉽게 기억하고 읽을 수 있는 주소(또는 이름) 를 컴퓨터가 이해할 수 있는 IP 주소 (예> 192.0.0.1) 로 변환하여 사용자의 컴퓨터가 서버로 접근할 수 있도록 하는 서비스를 제공한다
- DNS 의 구조
  - 인터넷상의 모든 도메인은 . (dot) 또는 루트 (Root) 라고 하는 도메인 아래에 역트리 (Inverted tree) 의 계층 구조로 구성되어 있다
  - 예를 들어 'www.stevenjlee.co.kr' 이라는 주소는 뒤에 있는 '.kr' 부터 앞에 있는 도메인들을 순차적으로 각 단계별 서버들을 통해 확인합니다
  - 루트 도메인 바로 아래의 단계를 1 단계 도메인 또는 최상위도메인 (TLD: Top Level Domain) 이라고 부른다. 최상위도메인은 다시 국가최상위도메인 (ccTLD: Country Code TLD) 과 일반최상위도메인 (gTLD: Generic TLD) 으로 구분할 수 있다. 'www.stevenjlee.co.kr' 이라는 주소에서는 '.kr' 부분이 여기에 해당된다
  - 최상위도메인 다음 단계를 2 단계 도메인 (SLD, Second Level Domain) 이라고 한다. 'www.stevenjlee.co.kr' 이라는 주소에서 '.co' 부분이 여기에 해당된다
  - 2 단계 도메인 아래는 3 단계 도메인으로 주로 도메인명이 위치한다. 'www.stevenjlee.co.kr' 이라는 주소에서는 'stevenjlee' 부분이다
  - 'www.stevenjlee.co.kr' 에서 'www' 는 호스트명으로 부른다. 또한 주소의 체계와 구조에 따라 추가 하위 도메인 계층이 있을 수 있다 (예> mail.stevenjlee.co.kr 등) 이 단계를 4 단계 도메인 또는 서브도메인이라고 한다
- 처리 과정
  - 클라이언트가 DNS 서버에 도메인 주소의 IP 주소를 물어보고 이에 대한 답을 받는 과정을 쿼리 (Query) 라고 한다. 특히 위와 같이 계층 구조로 이루어진 여러 DNS 서버들 간에 몇 차례의 요청과 응답을 받게 되는데 이 쿼리 과정을 재귀적 쿼리 (Recursive Query) 라고 한다
  - 'www.stevenjlee.net' 의 DNS 처리 과정
    1. 사용자가 클라이언트 호스트의 웹 브라우저에 'www.stevenjlee.net' 을 입력
	2. 클라이언트의 호스트에 설정된 기본 DNS 서버로 'www.stevenjlee.net' 의 IP 주소를 물어본다 (기본 DNS 주소는 특정 네트워크 회선 사업자가 제공하는 DNS 주소로 자동 설정되어 있을 수 있다)
	  - 대부분의 경우에 클라이언트는 DNS 서비스에 직접 쿼리를 하지 않는다. 이에 DNS 계층 구조에 따라 기본 DNS 주소로 연결되는 DNS Resolver 는 중간자 역할을 하여 재귀적 쿼리를 한다. DNS Resolver 는 자주 요청되는 질의에 대해 일정 시간 동안 해당 정보를 저장해 두었다가 같은 요청이 들어오면 바로 답변을 해주는 캐싱 (Cache) 기능도 한다
	3. DNS Resolver 에 'www.stevenjlee.net' 의 IP 주소값이 있다면 클라이언트로 바로 해당 IP 주소 값을 반환한다. IP 주소값이 없다면 루트 DNS 서버에 다시 IP 주소 확인 요청을 보낸다
	4. 루트 DNS 서버는 '.net' 을 관리하는 1 단계의 DNS 서버 IP 주소로 응답한다
	5. '.net' 을 관리하는 1 단계의 DNS 서버는 'stevenjlee.net' 을 관리하는 2 단계 DNS 서버 IP 주소를 반환한다
	6. 'www.stevenjlee.net' 의 도메인을 관리하는 서버는 'stevenjlee.net' 호스팅 역역에서 'www.stevenjlee.net' 의 레코드를 찾아 웹 서버의 IP 주소 192.0.0.1 등 해당 도메인 주소와 관련된 값을 받고 이 IP 주소를 다시 DNS Resolver 로 보낸다
	  - 도메인을 판매하거나 무료로 할당해주는 서비스들은 많다. Amazon Route 53 혹은 구글 도메인 등에서 해당 서비스들을 제공한다
    7. DNS Resolver 가 클라이언트가 필요한 IP 주소를 확보하게 된다 (위에서 언급한 캐싱을 위한 해당 도메인과 IP 주소를 임시로 저장해둔다). 해당 DNS Resolver 는 이 값을 클라이언트의 웹 브라우저로 반환한다
	8. 웹 브라우저는 IP 주소로 해당 서비스에 접속하여 서비스를 웹 브라우저에 표시한다
- 유형
  - 서비스 제공자가 구매한 도메인 주소는 '이름' 과 '값' 이 매칭된 바인딩 형태로 DNS 서버에 DNS 레코드로 데이터베이스에 저장된다
  - DNS 쿼리에 대해서는 하나 이상의 DNS 레코드 값을 채운 DNS 메세지로 응답한다
  - DNS 메세지의 뒷부분에 붙게되는 레코드의 공통 형식은 아래와 같다 (데이터베이스의 튜플 형태)
	- Name: 도메인 주소
	- Value: 도메인 주소 관련 값
	- Type: DNS 레코드 유형 값
	- TTL: DNS 캐싱 정보 최대 유지 시간 (위에서 설명한 DNS Resolver 가 이 레코드에 관한 정보를 캐싱할 시간(초) 정보)
  - DNS 레코드는 아래와 같이 여러 종류로 지정될 수 있다
    1. A / 유형 값: 1
	  - 도메인 주소에 대한 IPv4 주소를 맵핑하는 역할을 한다. 하나의 도메인에는 여러개의 IP 주소가 할당될 수 있고 반대로 하나의 IP 주소에 여러개의 도메인 주소가 할당될 수도 있다 (Name -> 도메인 주소, Value -> IPv4 주소, type -> 1)
	2. NS (Name Server) / 유형 값: 2
	  - 도메인에 대한 특정 네임서버를 지정하는 역할을 한다. 만약 자체적인 DNS 를 구축하여 이용하는 경우 이 레코드를 등록해야만 해당 DNS 서버를 이용할 수 있다 (Name -> 도메인명, Value -> DNS 서버의 호스트 명, type -> 2)
	3. CNAME (Canonical NAME) / 유형 값: 5
	  - 도메인 별칭 (Alias) 을 지정해주는 역할을 한다. 따라서, CNAME 은 도메인의 별칭에 대해 맵핑되어 있는 공식 도메인의 IP 주소를 받아오도록 해준다 (Name -> 도메인 주소 별칭, Value -> 공식 도메인 주소, type -> 5)
	4. 이 쯤 되니 지금 뭘 보고 있는지 모르겠습니다. 이 아래에 다른 유형은 나중에 보고 싶으면 보는 것으로 하고 지금은 건너 뛰도록 하겠습니다.
- DNS 헤더 구성
  - DNS 헤더나 다른 헤더도 지금 생각해보니 c 로 얘기하면 structure 인 것 같습니다. 단 c 의 structure 는 데이터의 순서에 대한 정의가 없지만 네트워크 데이터들의 헤더는 비트 단위로 순서가 정해져 있다는 점이 다른 것 같습니다

#### 터미널 창에서 시간을 어떻게 출력하나?

- `date` command 로 터미널에서 화면에 시간을 출력할 수 있다

```zsh
% date
2021년 1월 11일 월요일 10시 39분 23초 KST
%
```

- 형식 지정자를 사용하여 원하는 형태로 날짜를 출력할 수 있다

```zsh
% alias record="echo \[$(date "+%y/%m/%d %H:%M:%S")\]"
% record hi
[21/01/11-17:11:42] hi
%
```

- 그런데 위와 같이 alias 를 할 경우 alias command 를 입력하는 순간에 `date` 가 실행되면서 출력되는 시간이 alias 가 되는 문제가 있다
- 이를 해결하기 위해 $ 앞에 \\ 를 추가해 alias 를 입력할 때 date 프로그램이 실행되는 것을 막았다

```zsh
% which record
record: aliased to echo [2021년 1월 11일 월요일 17시 00분 52초 KST]
% alias record="echo \[\$(date "+%y/%m/%d-%H:%M:%S")\]"
% which record
record: aliased to echo \[$(date +%y/%m/%d-%H:%M:%S)\]
```

#### [Vim (플러그인, 자동 정렬, 자동 완성)](https://bigpel66.tistory.com/24)

이 사이트에서 laststatus 변수, inoremap 에 대해 알게 되어 적용해보았다. 이번에 추가한 .vimrc 설정은 아래와 같다

```vim
set laststatus=2
if has ("syntax")
    syntax on
endif
inoremap jf <esc>
inoremap fj <esc>
```

- `laststatus` 변수를 2 로 설정하면 항상 status bar 를 보여준다
- vimscript 에서도 if 문을 사용할 수 있다
- inoremap 은 inser mode 에서 no reculsive mapping 을 정의할 때 사용한다
  - jf 와 fj 를 exc 로 정의하여 두 키를 동시에 누르면 insert mode 에서 normal mode 로 나갈 수 있도록 하였다

### 7. 학습 내용에 대한 개인적인 총평

지난 주말에 푹 쉬어 맨탈을 회복한 뒤 공부를 해서 집중이 잘 됐습니다. 적은 시간 동안 (엄청 많은건 아니지만) 비교적 많은 양을 공부할 수 있었던 것 같습니다. 매 번 시간을 확인할 때 트랙패드로 손을 옮겨 상단 바를 열어 시간을 봤는데 이제는 터미널 창에서 시간을 확인/기록 할 수 있게 되었습니다.

### 8. 다음 학습 계획

- netwhat 공부하기
  - IP
  - Netmask
  - subnet of an IP with Netmask
  - router
  - netwhat pdf 문서에 나온 문제 범위 확인하기
- get\_next\_line
- printf
