# 제출 전 확인

- subject pdf
- 42seoul-translation
- 42seoul wiki
- 평가지표
- slack
- norm
- leak
- symbolic link 를 실제 파일로 교체하기

# 일단 적어

main/util/lmt_atoi 가 "-" 를 0 으로 반환하는 문제 -> 반환 순서를 조금 뒤로
util.h 를 lmt_util.h 로 바꾸자
directory name 도 util 에서 lmt_util 로
util.c 는 lmt_write.c 등으로 함수 하나만 사용하도록
env 가 .tool/name.variable 에 의해 계속 backup 된다
  generate_c_structure 가 작동 후 저걸 삭제하도록 하자
util 에 가변 배열도 하나 만들어두면 잘 사용하겠다
subject git 에 debug branch 를 위한 commit 만들어서 보여주기!! 개꿀
'aux where <aux command>': Print the path of aux command shell script
$git 이 ~/git 이었으면 좋겠다 (programming 은 너무 길었다)
git back 관련 command 가 불필요한 git 에 대해서는 짧게 출력하여 가독성을 높여보자
unsafe/lmt_strcpy.c

# project

minitalk
{
	가능한 많은 case 를 실행 가능하도록 지원하자
	잘 작동하는지 테스트하기
	데이터 구조 작성하기
}

philosophers
{
	segfault 해결하기
	{
		잘못된 공간에 할당됐는지
		이중 free 를 하였는지
	}
	10ms 안에 dead 를 출력해야 하는데, 한 바퀴 돌고 main thread 가 다시 실행되는 데 까지 걸리는 시간이 얼마일까?
	실행 흐름을 쭉 훑어보기
	start time 과 thread created time 이 다르기 때문에 philo 가 시작부터 굶어서 죽은 것처럼 보이지만 (start time) 실제는 (created time) 살아있는 증상은 평가지에서 어떻게 판단할까?
	ms 로 들어오는 입력을 us 로 바꾸기 위해 (그래야 usleep 에 넣기 편해서) 상한 제한을 두었는데 어떤 제한이 올바른 것일까?
	philosopher가 1 명인 경우 포크가 없도록 특수 처리를 하자
	에러가 깊숙한 곳부터 끊이지 않고 잘 전달되는지 확인하기
	pthread_mutex_lock 등 error 발생 시 return value 가 달라지는 library 함수들 가드 처리하기
	lmt_exit 을 사용할 수 없으니 이전 방식대로 return 값을 확인하도록 하자 (특히 util.c 등)
	mandatory program 1 개
	bonus program 1 개
	basic rules
	{
		no norm error
		no leak
		no crash
		no undefined behavior
		several philosophers exist
		philosophers are sitting at a round table
		philosopher can do one action of three: eating, thinking, sleeping
		while eating, they are not thinking or sleeping
		while sleeping, they are not eating or thinking
		while thinking, they are not eating or sleeping
		there are some forks on the table
		philosopher must eat with two forks
		philosopher must never be starving
		every philosopher needs to eat
		philosophers don't speak with each other
			'필로소퍼끼리 포크를 집는 순서를 결정하지 않는다' 라고 생각하자
		philosophers don't know when another philosopher is about to die
		each time a philosopher has finished eating, he willl drop his forks and start sleeping
		when a philosopher is done sleeping, he will start thinking
		the simulation stops when a philosopher dies
		program options
		{
			number_of_philosophers
				== number of philosophers == number of forks
			time_to_die (milliseconds)
				if a philosopher doesn't eat during, dies
			time_to_eat (milliseconds)
				time it takes for a philosopher to eat, will occupy 2 forks
			time_to_sleep (milliseconds)
				time the philosopher will spend sleeping
			[number_of_times_each_philosopher_must_eat]
				argument is optional
				if all philosopher eat enough, simulation stop
				if not specified, the simulation will stop only at the death of a philosopher
		}
		each philosopher have number from 1 to number_of_philosophers
			seat at round table -> (1, 2, ..., $number_of_philosophers)
		any change of status of philosopher must be written as follows
			timestamp_in_ms X has taken a fork
			timestamp_in_ms X is eating
			timestamp_in_ms X is sleeping
			timestamp_in_ms X is thinking
			timestamp_in_ms X died
		must print death before to elapse 10 ms
	}
	external functions
	{
		void	*memset(void *b, int c, size_t len);		<string.h>
		int		printf(const char * restrict format, ...);	<stdio.h>
		int		usleep(useconds_t microseconds);			<unistd.h>
			typedef unsigned int useconds_t:
		int		gettimeofday(struct timeval *restrict tp, void *restrict tzp);	<sys/time.h>
		{
			struct timeval
			{
				time_t		tv_sec;
					// typedef long time_t;
				suseconds_t	tv_usec;
					// typedef int suseconds_t
			};
		}
		int		pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);	<pthread.h>
		{
			typedef struct	_opaque_pthread_t
			{
				long		__sig;
				struct __darwin_pthread_handler_rec	*__cleanup_stack;
				char		__opaque[__PTHREAD_SIZE__];
			}				*pthread_t;
			struct		__darwin_pthread_handler_rec
			{
				void	(*__routine)(void *);
				void	*__arg;
				struct __darwin_pthread_handelr_rec	*__next;
			};
			typedef struct	_opaque_pthread_attr_t
			{
				long		__sig;
				char		__opaque[__PTHREAD_ATTR_SIZE__];
			}				pthread_attr_t;
		}
		int		pthread_detach(pthread_t thread);	<pthread.h>
		int		pthread_join(pthread_t thread, void **value_ptr);	<pthread.h>
		int		pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);	<pthread.h>
		{
			typedef struct	_opaque_pthread_mutex_t
			{
				long		__sig;
				char		__opaque[__PTHREAD_MUTEX_SIZE__];
			}				pthread_mutex_t;
			typedef struct	_opaque_pthread_mutexattr_t
			{
				long		__sig;
				char		__opaque[__PTHREAD_MUTEXATTR_SIZE__];
			}				pthread_mutexattr_t;
		}
		int		pthread_mutex_destroy(pthread_mutex_t *mutex);	<pthread.h>
		int		pthread_mutex_lock(pthread_mutex_t *mutex);	<pthread.h>
		int		pthread_mutex_unlock(pthread_mutex_t *mutex);	<pthread.h>
	}
	arguments
	{
		integer parsing (is integer, range)
	}
	summary
	{
		The philosophers must never be starving
		Philosophers don’t speak with each other
		Philosophers don’t know when another philosopher is about to die
		The simulation stops when a philosopher dies
		You can’t have more than 10 ms between the death of a philosopher and when it will print its death
		Again, philosophers should avoid dying
		// is creation order not decided ??
	}
	나의 규칙
	{
		마지막 인자를 파싱했을 때 갯수는 항상 철학자의 수와 같아야 한다 (혹은 아예 인자가 없거나)
	}
	need guard
	{
		int pthread_create(&thread, NULL, handler, arg);  // 0 : error
		int pthread_mutex_init(&mutex, NULL);  // 0 : error
	}
	don't need guard
	{
		usleep(int);  // signal 을 받을 때의 작동은 신경쓰지 않는다
		gettimeofday(struct timeval *, NULL);  // 인자가 NULL 이 아니도록 신경쓴다
		pthread_detach(thread);  // 정상적인 thread 인지 신경써준다 (벌써 detach 됐거나 없는 thread 이면 안된다!)
		pthread_mutex_lock(&mutex);  // valid mutex
		pthread_mutex_unlock(&mutex);  // valid mutex, thread hold a lock on mutex
	}
}

- siteTool
  - 블로그 만들고 작성하기!!!
- variabledText
  - cli 에서 변수 값을 인자로 넣어줄 수 있으면 좋겠다
    - 'variabledText <path> -v <identifier>=<value>
  - '-o' 로 결과 파일을 직접 입력하는 것이 아니라 파일 내에 meta data 를 text 로 기록해두고 읽어서 사용하도록 하면 어떻까?
  - 변수의 값에 '\n' 를 넣을 수 있게 하려면 변수 간의 delimiter 를 '\n' 로 하면 안되는 걸까?
  - 변수 식별자를 일괄적으로 바꾸는 추가 기능
  - 다양한 경고 (위치와 해당 라인 출력)
    - 정의하지 않은 식별자 사용 경고
    - 사용하지 않은 식별자 정의 경고
    - 중복 정의된 식별자 경고
- env
  - setenv 가 basecamp 를 입력받아서 패키지를 구성하도록 변경하기
  - 전반적인 초기 과정을 추적해보자, ssh key 를 적용하기 위해서 필요한 것들 -> 어디에 적용할지 사이트 주소
- 기록이 먼저
  - 아마존 무료 클라우드 호스팅 서비스 알아보기
  - 내가 프로그램 지능이 나보다 낮은 사람에게 알려줄 수 있는 것은 앞길과, 그 시기에는 원래 그렇게 힘들다는 것이다
  - 프로그래밍 단어 정규화
  - 자동으로 웹에 백업되는 것도 좋지만, 시간이 오래 걸리는 작업이기 때문에 캐쉬를 기본으로 하고 필요에 따라 사용자에게 백업 및 풀 권한을 주는 것도 좋을 것 같다
  - link file 은 깃허브에 어떻게 올라갈까? (아니면 깃에 어떻게 기록될까?)
	- 깃에도 똑같이 링크 파일로 기록될 것 같다
	- 깃이 권한이나 등등 메타 데이터도 기록할까?
  - 생각
    - 프로그램의 구조를 다 보여주는 프로그램은 어떨까?
	  - lldb 처럼 디버깅용 프로그램인데 어떤 함수에 어떤 변수가 존재하는지 다 보여주고 어떤 변수가 어떤 변화과정을 겪었는지 연대기를 다 보여주는거지
    - 많이 생각해보면 좋을 것
      - null guard 의 형식 등 통일된 형식을 만들고 지키는 문제
    - 생각을 적게 해야할 부분
	  - 여러 이름들, 최선의 이름은 있겠지만 최고의 이름은 없다
  - how to multi line quote in md
  - == 연산자는 어떻게 0 과 1 을 반환하는가?
  - 인자가 특정 값이면 0 을 반환하는 함수?
  - ls 에 파일 내용을 출력하는 기능이 있더라
  - git log --branches 가 remote branch 는 보여주지 않는 문제
  - env 가 setenv.sh 를 실행할 때 설정해줘야하는 파일을 vim 으로 열어도 좋을 것 같다
  - va_list 인자는 기존 인자와는 다른 방식으로 작동하는 모습을 보이는 것 같다. 더 큰 크기의 인자로 받아들일 때도 입력받은 인자의 크기만큼을 가져온다. 내부적으로 어떻게 되어있는 것일까?
  - 기록 관리 프로그램 in cli!!!!
    - git 처럼 vcs 이 아니라 기록 control system 을 만들자!
	- git 에 자료를 보관하면서 보관되어 있는 자료를 쉽게 control 하는거지!
  - 블로그에 날짜 표시하기
  - 함수 이름을 여러개로 쓸 수 있도록 필요할 때마다 추가할 수 있도록 하면 결국 지저분해질 뿐이다, 따라서 문서 편집기에서 특정 이름들을 특정 상수로 바꾸도록 처리하여 서로 다른 이름을 쓰더라도 결국 같은 상수가 되도록 처리하는 것이 좋다. 일괄적으로 변수 이름을 바꾸는 기능을 상위단에서 제공하는 것이다
  - 모든 local repo 의 branch 를 출력하는 프로그램은 어떨까?
  - 문서편집기인데 모든 문자들이 저마다의 태그를 가지고 있고 특정 태그의 특정 문자나 단어를 replace 할 수 있는 프로그램
  - ':set all': display all set
  - 데이터를
  마구마구 던지면 알아서 구조화하고 정리해주는 프로그램
  - 일단 명령을 입력하기가 무조건 쉬워야 한다 (혹은 alias 를 사용할 수도 있겠지), 그러고 나서 보기 좋게 출력하는 것은 추가적인 출력 프로그램이 담당하는 것!
- 항시 정리하기
  - 북마크
  - 읽기 목록
  - 하드
  - 메모
  - 슬랙 saved
- env
  - base camp 를 짓는 것처럼 env 폴더가 존재하는 위치를 중심으로 programming 폴더를 만든다면 더 좋을 것 같다
    - 이 경우 vim 에서는 절대 경로를 사용하는데 어떻게 처리해줘야하는 것일까?
	  - 상대경로를 통해 생성한 절대결로로 해당 절대 경로 데이터를 바꿔줘야만 할까? 너무 복잡한데?
  - back command 가 인자를 받아서 해당 git repo 만 처리하도록 하자
- git
  - how to get the content of hash?
  - [Git Tips](https://github.com/mingrammer/git-tips)
- lldb
  - 특정 시그널 보내기
  - 'memory read': 메모리를 출력함
  - 변수 값 읽기 쓰기에 따른 breakpoint 설정
- 책
  - 50/288 : The C Programming Language
  - 늑향: 10 권 114p



# 미래

- state machine in printf, automata, regex
- git repo, branch name 을 가져오는 과정에서 git repo 안에 있지 않을 때 오류 메세지가 출력되는 문제
- 'zshrc' 를 할 때마다 precmd_vcs_info 가 precmd_functions 에 추가되는 문제
- 프로그램의 동작이 나의 예상과 다를 경우 해결 과정을 기록하자
  - 일단 무엇이 어떻게 동작할 것이라 예상했는가?
  - 실제 동작은 어떠했는가?
  - 예상 가는 원인은 무엇인가?
  - 잘못 알고 있던 부분은 무엇이었는가?
- 데이터를 git 으로 관리
- 여러 git repository 의 commit 을 확인할 수 있는 상위 git
- 면접 시 질문
  - 회의 분위기가 어떤가요?
- 42 seoul 언급 외의 공부해온 내용을 정리하여 블로그에 올리기
{
	하지만 그것을 위해서는 먼저 블로그가 잘 정돈되어야 할 것이다
	'-H' option 으로 include 하는 header file 의 위치를 파악하고 ctags 로 tags 생성 후 탐색하기
	컴퓨터 데이터의 format 을 어떻게 정의하고 통용할 수 있었는가를 간단한 bmp 파일을 직접 한땀 한땀 만드는 것으로 설명하는 영상을 만들면 좋을 것 같다
	파일 시스템 용어 정리, base name, path, real path, relative path etc
	각종 용어 정리
	키보드 문자 읽는 법
	miniRT 영어 용어 정리
	makefile
	lldb: breakpoint, watchpost, up, down, c, n, s, --name, --file --line
	vim: 여러 파일 수정하기
	git
	git log pretty format
	cli
	shell script
	free 후 참조 -> 바로 사용해도 잘못된 값이 들어갈 수 있음 (확률)
		malloc 의 크기이면 malloc 에러
	free 면 segmant fault
	참조면 abort 나 bus error
	report 내용
	automata
	프로그램 구조를 위한 추상화 과정과 프로그램 구현을 위한 구체화 과정: 뼈와 살
	philosophers 를 하면서 얻은 지식
	{
		thread
		mutex
		attribute
	}
}
- 사이드 프로젝트
  - 게임을 만들고 싶은데 (아니면 간단한 보조 프로그램이라도) 혼자 하는건 싫고 반드시 멀티가 가능하도록 만들고 싶다!!!!!!!
    - 개인 플레이 게임을 만드는 것도 크게 나쁘지는 않으나 재미를 얻을 수 있는 요소가 멀티에 비해 제한된다
- 읽고 싶은 책
  - code
  - jso 님이 추천해준 docker, kubernetes 근처에 있던, unix 탄생 스토리 책
  - Computer Organization and Design: 많은 대학에서 사용하는 컴퓨터 구조의 바이블
  - 성공과 실패를 결정하는 1%의 네트워크 원리
  - strunk and white
  - Real-World Software Developement
  - code (?)
  - cs
  - [modern c](https://modernc.gforge.inria.fr)
  - The C Programming language
  - https://git-scm.com/book/en/v2
  - Don't Make Me Think
  - [Laws of UX](https://lawsofux.com/)
  - Code Complete
  - Writing Solid Code
- display_memory 에 2, 3, 4 번째 인자를 통해 prev, cur, end 를 표현하도록 하기
  - add, remove, move 등의 명령어를 통해 포인터 그래픽을 움직일 수 있으면 좋겠다 ㅎㅎㅎㅎ
