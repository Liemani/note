todo near future.txt

# pc
게임 계발 모임 만들고 싶다.
내 계발 환경을 알리고 싶다.
자동으로 웹에 백업되는 것도 좋지만, 시간이 오래 걸리는 작업이기 때문에 캐쉬를 기본으로 하고 필요에 따라 사용자에게 백업 및 풀 권한을 주는 것도 좋을 것 같다
오랜만에 배터리 클램쉘을 사용하기 위해 github blog 를 보았는데, pmset 설정하는 방법만 있고 잘 설정됐는지 확인하는 방법이 없어서 불편했다. 어떤 값을 수정할 경우 동시에 눈으로 담겨있는 값을 볼 수 있는 방법이 함께 동봉되야 할텐데 왜 그것 첨가하지 않은것이지? 추가하도록 하자
aux backup 에는 시간이 꽤 걸려서 거슬린다. 모든 파일을 읽어서 backup 하는 것이 아니라 적어놓은 특정 파일만 backup 하도록 해보는건 어떨까?
- back command 가 인자를 받아서 해당 git repo 만 처리하도록 하자
초패스트 언어 시작하기 글을 언어마다 만들어둬도 좋은 참고가 되겠다
github page 에 내 git repository 를 소개하는 마일스톤 페이지 추가하기
zsh-dependent code 를 bash-compitable 하게 수정하기
mac-dependent code 를 unix-compitable 하게 수정하기
vim/help
- usr_10.txt/10.3
- usr_20.txt
- editing.txt
- change.txt
- tips.txt
vim 강의 만들기
- 빠져드는 순서: 단순 명령 -> 조합 명령 -> 커맨드 라인 명령
- vim 의 가장 큰 장점은 간편하고 효율적인 자동화이다
- <C-]> 로 특정 단어에 해당하는 위치로 이동
- <C-I>, <C-O> 로 드나들기
- 그 외 다양한 jump 기능
- vim 의 기능을 어려운 기능에서 쉬운 기능 순서로 나열한 목록을 화면에 띄워놓고 시작하기 전에 모두 한 쪽 손을 들게 한 다음 순서대로 읽으면서 아는 사람은 손을 내리게 하여 전체적인 참여자의 실력 분폴르 알아보면 괜찮을 것 같다.
이너서클을 돌파하면 게임 개발 인원을 관리해 보자.
테스트 환경을 잘 만들어도 좋겠다
- 문자열, 숫자, 문자 등을 생성하여 인자로 넣어주는 프로그램, 혹은 라이브러리
	- 각 인자는 범위 등을 지정 할 수 있다
- 각각의 기능을 직접 테스트해볼 수 있는 비효율적이지만 가독성이 꽤 괜찮은, 그리고 간단히 다양한 기능을 수행해볼 수 있는 연습용 프로그램을 항상 만들고 작업을 시작하는 것은 어떨까?
	- 일단 구조체가 존재한다면, 그 구조체를 볼 수 있는 기능, 값을 수정할 수 있는 기능을 먼저 구현한 후 작업에 착수하는 것이지
- 테스트 등을 위한 환경은 구조체 등이 hard 하게 존재하는 것이 아니라 dynamic 하게 만들고 테스트 할 수 있다면 debuging 에 도움이 될 것 같다. 고정된 것이 아니기 때문에 원하는 데로 바꿔가면서 테스트가 가능해지기 때문이다
- test program 등 유용한 shell script 를 위키처럼 관리할 수 있도록 운영하는 깃 레포를 하나 만들고 싶다
computer 의 programming spec 을 출력하는 프로그램
- size of int, long long... so on

# 조사
transfer.sh
github cli
나는 detach 가 thread 가 끝나면 자원을 새로운 thread 가 사용할 수 있도록 하는 것이라고 본 것 같은데, 이 분은 thread 를 종료시켜버린다고 말하네? 직접 확인해보자
- https://42born2code.slack.com/archives/CMX2R5JSW/p1639492207443200?thread_ts=1639491300.441500&cid=CMX2R5JSW
저번에 실행파일을 xxd 로 직접 수정해서 실행 결과를 바꾸는 작업을 해보았는데, 이 때 코드에 따라 생성되는 실행파일이 달랐었다. 코드가 어떻게 달라짐에 따라 실행파일이 어떻게 달라지는지 확인해보고, 어떨 때 실행 파일에 코드의 수정 내용이 담기고 담기지 않는지를 파악해보자. 그에따른 적절한 include 가 무엇인지 판단할 수 있게 될 것이다.
- .o 파일을 생성할 때 이미 크기가 클까? 아니면 link 과정에서 크기가 커질까?
unix lecture note 에서 more 을 구현할 때 처음 출력 scroll 을 어떻게 처리했는지 궁금하다. 그냥 일단 출력하고 본 것이었을까? 그리고 위로 스크롤 하는 것은 어떻게 구현했을까?
pull request 를 collaborator 도 받아들일 수 있던데, 권한 설정도 가능한가? 확인해보자
assembly
- static variable 을 초기화할 때 어셈블리적으로 어떤 일이 발생할까?
file system 의 구조
cli 에서 * 의 구체적 작동
- */* 는 * 을 포함하는가?
- * 는 directory 를 포함하는가?
ast
nlp
- tokenization
- stemming
- lemmatization
lexic
filedescriptors
file table
inode table
program counter(pc)
kernel panic
구조체를 반환하면 어떻게 작동할까?
- 구조체 전체를 복사하기 때문에 포인터로 하는 거에 비해 오래 걸린다는 것은 아는데, 그것이 구체적으로 어떻게 작동하는지는 모른다
- 반환값을 담는 레지스터가 존재하는 것으로 아는데, 레지스터의 크기는 고정값일 것 아닌가?
automata
- regex -> 무한 상태 머신 -> 유한 상태 머신
아마존 무료 클라우드 호스팅 서비스 알아보기
포인터가 가리키는 변수에 접근하는 것과 일반 변수에 접근하는 것의 속도 차이?
finish vs complete
va_list 인자는 기존 인자와는 다른 방식으로 작동하는 모습을 보이는 것 같다. 더 큰 크기의 인자로 받아들일 때도 입력받은 인자의 크기만큼을 가져온다. 내부적으로 어떻게 되어있는 것일까?
