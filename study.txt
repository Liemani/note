echo "*"    # *
echo '*'    # *
echo /*    # *
echo *    # display all files
echo ~    # display home path
echo ?    # display all 1 character

echo "$truc"    # isACar
echo '$truc'    # truc

cat [-e]
more    # work like man page
head
tail

grep [-iv]

ls bonjour 2> error.log
ls bonjour test* > res.txt 2> error.log
ls bonjour test* 2> error.log | grep test00

cat batman.txt | grep Joker | wc -l
grep Joker < batman.txt | wc -l

echo coucou > res.txt    # write file
echo coucou >> res.txt    # append file

cat << FIN    # read until FIN
ls bonjour *.txt > resultat.txt 2>&1
cat resultat.txt

ctrl d
ctrl c
ctrl \

2020-10-14
gzip -d <file>
tar -zxvf <file>
man cut
man diff
man patch
tar -cf exo2.tar *

2020-10-15

2020-10-21
ctrl + u: clear current terminal line befor cursor
ctrl + k: clear current terminal line after cursor
[vim] d: cut selected text
[vim] y: copy selected text
[vim] p: paste selected text before cursor
[vim] P: paste selected text after cursor

2020-11-1
test git when init pull would delete another file?

2020-11-4
"abcd"[2]: has something to think!
strcmp return 2 case (1. -1, 0, 1), (2. ch1 - ch2)

2020-11-05
c7r9s4% ./a.out test.dat 10
fd: 3 
[ 1]read character: ''(104) 
ret_read           : [1] 
[ 2]read character: ''(105) 
ret_read           : [1] 
[ 3]read character: ''(32) 
ret_read           : [1] 
[ 4]read character: ''(112) 
ret_read           : [1] 
[ 5]read character: '.'(10) 
ret_read           : [1] 
[ 6]read character: '.'(106) 
ret_read           : [1] 
[ 7]read character: '.'(104) 
ret_read           : [1] 
[ 8]read character: '.'(10) 
ret_read           : [1] 
[ 9]read character: '.'(10) 
ret_read           : [0] 

analyze:
test.dat has 8 bytes size.
8th byte(last character of file) is newline character.
after read last character, if you try to read more character, the return value will be 0.
if `read()` try to read impossible, it will return 0.
`read()` function return read byte size.


















